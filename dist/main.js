/*! For license information please see main.js.LICENSE.txt */
(()=>{var __webpack_modules__={"./node_modules/core-js/es/array/includes.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(/*! ../../modules/es.array.includes */ \"./node_modules/core-js/modules/es.array.includes.js\");\nvar entryUnbind = __webpack_require__(/*! ../../internals/entry-unbind */ \"./node_modules/core-js/internals/entry-unbind.js\");\n\nmodule.exports = entryUnbind('Array', 'includes');\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/es/array/includes.js?")},"./node_modules/core-js/es/object/assign.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('__webpack_require__(/*! ../../modules/es.object.assign */ "./node_modules/core-js/modules/es.object.assign.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Object.assign;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/es/object/assign.js?')},"./node_modules/core-js/features/array/includes.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var parent = __webpack_require__(/*! ../../stable/array/includes */ "./node_modules/core-js/stable/array/includes.js");\n\nmodule.exports = parent;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/features/array/includes.js?')},"./node_modules/core-js/features/object/assign.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var parent = __webpack_require__(/*! ../../stable/object/assign */ "./node_modules/core-js/stable/object/assign.js");\n\nmodule.exports = parent;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/features/object/assign.js?')},"./node_modules/core-js/internals/a-function.js":module=>{eval("module.exports = function (it) {\n  if (typeof it != 'function') {\n    throw TypeError(String(it) + ' is not a function');\n  } return it;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/a-function.js?")},"./node_modules/core-js/internals/add-to-unscopables.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\n\nvar UNSCOPABLES = wellKnownSymbol(\'unscopables\');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/add-to-unscopables.js?')},"./node_modules/core-js/internals/an-object.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nmodule.exports = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + ' is not an object');\n  } return it;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/an-object.js?")},"./node_modules/core-js/internals/array-includes.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");\nvar toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/array-includes.js?')},"./node_modules/core-js/internals/classof-raw.js":module=>{eval("var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/classof-raw.js?")},"./node_modules/core-js/internals/copy-constructor-properties.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");\nvar getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/copy-constructor-properties.js?')},"./node_modules/core-js/internals/create-non-enumerable-property.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/create-non-enumerable-property.js?')},"./node_modules/core-js/internals/create-property-descriptor.js":module=>{eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/create-property-descriptor.js?")},"./node_modules/core-js/internals/descriptors.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// Detect IE8\'s incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/descriptors.js?')},"./node_modules/core-js/internals/document-create-element.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nvar document = global.document;\n// typeof document.createElement is \'object\' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/document-create-element.js?')},"./node_modules/core-js/internals/engine-user-agent.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/engine-user-agent.js?")},"./node_modules/core-js/internals/engine-v8-version.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split(\'.\');\n  version = match[0] < 4 ? 1 : match[0] + match[1];\n} else if (userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = match[1];\n  }\n}\n\nmodule.exports = version && +version;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/engine-v8-version.js?')},"./node_modules/core-js/internals/entry-unbind.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");\n\nvar call = Function.call;\n\nmodule.exports = function (CONSTRUCTOR, METHOD, length) {\n  return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/entry-unbind.js?')},"./node_modules/core-js/internals/enum-bug-keys.js":module=>{eval("// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/enum-bug-keys.js?")},"./node_modules/core-js/internals/export.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");\nvar redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");\nvar copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");\nvar isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \'.\' : \'#\') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, \'sham\', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/export.js?')},"./node_modules/core-js/internals/fails.js":module=>{eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/fails.js?")},"./node_modules/core-js/internals/function-bind-context.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/function-bind-context.js?')},"./node_modules/core-js/internals/get-built-in.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n\nvar aFunction = function (variable) {\n  return typeof variable == 'function' ? variable : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/get-built-in.js?")},"./node_modules/core-js/internals/global.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/global.js?")},"./node_modules/core-js/internals/has.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty.call(toObject(it), key);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/has.js?')},"./node_modules/core-js/internals/hidden-keys.js":module=>{eval("module.exports = {};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/hidden-keys.js?")},"./node_modules/core-js/internals/html.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/html.js?")},"./node_modules/core-js/internals/ie8-dom-define.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");\n\n// Thank\'s IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing\n  return Object.defineProperty(createElement(\'div\'), \'a\', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/ie8-dom-define.js?')},"./node_modules/core-js/internals/indexed-object.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n\nvar split = ''.split;\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/indexed-object.js?")},"./node_modules/core-js/internals/inspect-source.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var store = __webpack_require__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n\nvar functionToString = Function.toString;\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (typeof store.inspectSource != 'function') {\n  store.inspectSource = function (it) {\n    return functionToString.call(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/inspect-source.js?")},"./node_modules/core-js/internals/internal-state.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");\nvar objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar OBJECT_ALREADY_INITIALIZED = \'Object already initialized\';\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError(\'Incompatible receiver, \' + TYPE + \' required\');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey(\'state\');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/internal-state.js?')},"./node_modules/core-js/internals/is-forced.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : typeof detection == 'function' ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/is-forced.js?")},"./node_modules/core-js/internals/is-object.js":module=>{eval("module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/is-object.js?")},"./node_modules/core-js/internals/is-pure.js":module=>{eval("module.exports = false;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/is-pure.js?")},"./node_modules/core-js/internals/is-symbol.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\nvar USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ \"./node_modules/core-js/internals/use-symbol-as-uid.js\");\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return typeof $Symbol == 'function' && Object(it) instanceof $Symbol;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/is-symbol.js?")},"./node_modules/core-js/internals/native-symbol.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/native-symbol.js?')},"./node_modules/core-js/internals/native-weak-map.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = typeof WeakMap === \'function\' && /native code/.test(inspectSource(WeakMap));\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/native-weak-map.js?')},"./node_modules/core-js/internals/object-assign.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\n\n// eslint-disable-next-line es/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nmodule.exports = !$assign || fails(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, \'a\', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, \'b\', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = \'abcdefghijklmnopqrst\';\n  A[symbol] = 7;\n  alphabet.split(\'\').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join(\'\') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/object-assign.js?')},"./node_modules/core-js/internals/object-create.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("/* global ActiveXObject -- old IE, WSH */\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ \"./node_modules/core-js/internals/object-define-properties.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\nvar html = __webpack_require__(/*! ../internals/html */ \"./node_modules/core-js/internals/html.js\");\nvar documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/object-create.js?")},"./node_modules/core-js/internals/object-define-properties.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);\n  return O;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/object-define-properties.js?')},"./node_modules/core-js/internals/object-define-property.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/object-define-property.js?")},"./node_modules/core-js/internals/object-get-own-property-descriptor.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/object-get-own-property-descriptor.js?')},"./node_modules/core-js/internals/object-get-own-property-names.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/object-get-own-property-names.js?")},"./node_modules/core-js/internals/object-get-own-property-symbols.js":(__unused_webpack_module,exports)=>{eval("// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/object-get-own-property-symbols.js?")},"./node_modules/core-js/internals/object-keys-internal.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don\'t enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/object-keys-internal.js?')},"./node_modules/core-js/internals/object-keys.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/object-keys.js?')},"./node_modules/core-js/internals/object-property-is-enumerable.js":(__unused_webpack_module,exports)=>{"use strict";eval("\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/object-property-is-enumerable.js?")},"./node_modules/core-js/internals/ordinary-to-primitive.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (pref !== 'string' && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/ordinary-to-primitive.js?")},"./node_modules/core-js/internals/own-keys.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");\nvar getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn(\'Reflect\', \'ownKeys\') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/own-keys.js?')},"./node_modules/core-js/internals/path.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\nmodule.exports = global;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/path.js?')},"./node_modules/core-js/internals/redefine.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\nvar has = __webpack_require__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\nvar inspectSource = __webpack_require__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  var state;\n  if (typeof value == 'function') {\n    if (typeof key == 'string' && !has(value, 'name')) {\n      createNonEnumerableProperty(value, 'name', key);\n    }\n    state = enforceInternalState(value);\n    if (!state.source) {\n      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');\n    }\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n});\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/redefine.js?")},"./node_modules/core-js/internals/require-object-coercible.js":module=>{eval('// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError("Can\'t call method on " + it);\n  return it;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/require-object-coercible.js?')},"./node_modules/core-js/internals/set-global.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\nmodule.exports = function (key, value) {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/set-global.js?')},"./node_modules/core-js/internals/shared-key.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\n\nvar keys = shared(\'keys\');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/shared-key.js?')},"./node_modules/core-js/internals/shared-store.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");\n\nvar SHARED = \'__core-js_shared__\';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/shared-store.js?')},"./node_modules/core-js/internals/shared.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\nvar store = __webpack_require__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.17.3',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'\n});\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/shared.js?")},"./node_modules/core-js/internals/to-absolute-index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/to-absolute-index.js?')},"./node_modules/core-js/internals/to-indexed-object.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/to-indexed-object.js?')},"./node_modules/core-js/internals/to-integer.js":module=>{eval("var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.es/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/to-integer.js?")},"./node_modules/core-js/internals/to-length.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/to-length.js?')},"./node_modules/core-js/internals/to-object.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/to-object.js?')},"./node_modules/core-js/internals/to-primitive.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");\nvar ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar TO_PRIMITIVE = wellKnownSymbol(\'toPrimitive\');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = input[TO_PRIMITIVE];\n  var result;\n  if (exoticToPrim !== undefined) {\n    if (pref === undefined) pref = \'default\';\n    result = exoticToPrim.call(input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw TypeError("Can\'t convert object to primitive value");\n  }\n  if (pref === undefined) pref = \'number\';\n  return ordinaryToPrimitive(input, pref);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/to-primitive.js?')},"./node_modules/core-js/internals/to-property-key.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");\nvar isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, \'string\');\n  return isSymbol(key) ? key : String(key);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/to-property-key.js?')},"./node_modules/core-js/internals/uid.js":module=>{eval("var id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/uid.js?")},"./node_modules/core-js/internals/use-symbol-as-uid.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/use-symbol-as-uid.js?")},"./node_modules/core-js/internals/well-known-symbol.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");\nvar USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");\n\nvar WellKnownSymbolsStore = shared(\'wks\');\nvar Symbol = global.Symbol;\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \'string\')) {\n    if (NATIVE_SYMBOL && has(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(\'Symbol.\' + name);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/internals/well-known-symbol.js?')},"./node_modules/core-js/modules/es.array.includes.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar $includes = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").includes;\nvar addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$({ target: \'Array\', proto: true }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(\'includes\');\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/modules/es.array.includes.js?')},"./node_modules/core-js/modules/es.object.assign.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js/internals/object-assign.js");\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es/no-object-assign -- required for testing\n$({ target: \'Object\', stat: true, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/modules/es.object.assign.js?')},"./node_modules/core-js/stable/array/includes.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var parent = __webpack_require__(/*! ../../es/array/includes */ "./node_modules/core-js/es/array/includes.js");\n\nmodule.exports = parent;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/stable/array/includes.js?')},"./node_modules/core-js/stable/object/assign.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var parent = __webpack_require__(/*! ../../es/object/assign */ "./node_modules/core-js/es/object/assign.js");\n\nmodule.exports = parent;\n\n\n//# sourceURL=webpack://sat/./node_modules/core-js/stable/object/assign.js?')},"./node_modules/hotkeys-js/dist/hotkeys.js":function(module){eval("/*!\n * hotkeys-js v3.8.7\n * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.\n * \n * Copyright (c) 2021 kenny wong <wowohoo@qq.com>\n * http://jaywcjlove.github.io/hotkeys\n * \n * Licensed under the MIT license.\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  var isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false; // 绑定事件\n\n  function addEvent(object, event, method) {\n    if (object.addEventListener) {\n      object.addEventListener(event, method, false);\n    } else if (object.attachEvent) {\n      object.attachEvent(\"on\".concat(event), function () {\n        method(window.event);\n      });\n    }\n  } // 修饰键转换成对应的键码\n\n\n  function getMods(modifier, key) {\n    var mods = key.slice(0, key.length - 1);\n\n    for (var i = 0; i < mods.length; i++) {\n      mods[i] = modifier[mods[i].toLowerCase()];\n    }\n\n    return mods;\n  } // 处理传的key字符串转换成数组\n\n\n  function getKeys(key) {\n    if (typeof key !== 'string') key = '';\n    key = key.replace(/\\s/g, ''); // 匹配任何空白字符,包括空格、制表符、换页符等等\n\n    var keys = key.split(','); // 同时设置多个快捷键，以','分割\n\n    var index = keys.lastIndexOf(''); // 快捷键可能包含','，需特殊处理\n\n    for (; index >= 0;) {\n      keys[index - 1] += ',';\n      keys.splice(index, 1);\n      index = keys.lastIndexOf('');\n    }\n\n    return keys;\n  } // 比较修饰键的数组\n\n\n  function compareArray(a1, a2) {\n    var arr1 = a1.length >= a2.length ? a1 : a2;\n    var arr2 = a1.length >= a2.length ? a2 : a1;\n    var isIndex = true;\n\n    for (var i = 0; i < arr1.length; i++) {\n      if (arr2.indexOf(arr1[i]) === -1) isIndex = false;\n    }\n\n    return isIndex;\n  }\n\n  var _keyMap = {\n    backspace: 8,\n    tab: 9,\n    clear: 12,\n    enter: 13,\n    return: 13,\n    esc: 27,\n    escape: 27,\n    space: 32,\n    left: 37,\n    up: 38,\n    right: 39,\n    down: 40,\n    del: 46,\n    delete: 46,\n    ins: 45,\n    insert: 45,\n    home: 36,\n    end: 35,\n    pageup: 33,\n    pagedown: 34,\n    capslock: 20,\n    num_0: 96,\n    num_1: 97,\n    num_2: 98,\n    num_3: 99,\n    num_4: 100,\n    num_5: 101,\n    num_6: 102,\n    num_7: 103,\n    num_8: 104,\n    num_9: 105,\n    num_multiply: 106,\n    num_add: 107,\n    num_enter: 108,\n    num_subtract: 109,\n    num_decimal: 110,\n    num_divide: 111,\n    '⇪': 20,\n    ',': 188,\n    '.': 190,\n    '/': 191,\n    '`': 192,\n    '-': isff ? 173 : 189,\n    '=': isff ? 61 : 187,\n    ';': isff ? 59 : 186,\n    '\\'': 222,\n    '[': 219,\n    ']': 221,\n    '\\\\': 220\n  }; // Modifier Keys\n\n  var _modifier = {\n    // shiftKey\n    '⇧': 16,\n    shift: 16,\n    // altKey\n    '⌥': 18,\n    alt: 18,\n    option: 18,\n    // ctrlKey\n    '⌃': 17,\n    ctrl: 17,\n    control: 17,\n    // metaKey\n    '⌘': 91,\n    cmd: 91,\n    command: 91\n  };\n  var modifierMap = {\n    16: 'shiftKey',\n    18: 'altKey',\n    17: 'ctrlKey',\n    91: 'metaKey',\n    shiftKey: 16,\n    ctrlKey: 17,\n    altKey: 18,\n    metaKey: 91\n  };\n  var _mods = {\n    16: false,\n    18: false,\n    17: false,\n    91: false\n  };\n  var _handlers = {}; // F1~F12 special key\n\n  for (var k = 1; k < 20; k++) {\n    _keyMap[\"f\".concat(k)] = 111 + k;\n  }\n\n  var _downKeys = []; // 记录摁下的绑定键\n\n  var _scope = 'all'; // 默认热键范围\n\n  var elementHasBindEvent = []; // 已绑定事件的节点记录\n  // 返回键码\n\n  var code = function code(x) {\n    return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);\n  }; // 设置获取当前范围（默认为'所有'）\n\n\n  function setScope(scope) {\n    _scope = scope || 'all';\n  } // 获取当前范围\n\n\n  function getScope() {\n    return _scope || 'all';\n  } // 获取摁下绑定键的键值\n\n\n  function getPressedKeyCodes() {\n    return _downKeys.slice(0);\n  } // 表单控件控件判断 返回 Boolean\n  // hotkey is effective only when filter return true\n\n\n  function filter(event) {\n    var target = event.target || event.srcElement;\n    var tagName = target.tagName;\n    var flag = true; // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>\n\n    if (target.isContentEditable || (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) {\n      flag = false;\n    }\n\n    return flag;\n  } // 判断摁下的键是否为某个键，返回true或者false\n\n\n  function isPressed(keyCode) {\n    if (typeof keyCode === 'string') {\n      keyCode = code(keyCode); // 转换成键码\n    }\n\n    return _downKeys.indexOf(keyCode) !== -1;\n  } // 循环删除handlers中的所有 scope(范围)\n\n\n  function deleteScope(scope, newScope) {\n    var handlers;\n    var i; // 没有指定scope，获取scope\n\n    if (!scope) scope = getScope();\n\n    for (var key in _handlers) {\n      if (Object.prototype.hasOwnProperty.call(_handlers, key)) {\n        handlers = _handlers[key];\n\n        for (i = 0; i < handlers.length;) {\n          if (handlers[i].scope === scope) handlers.splice(i, 1);else i++;\n        }\n      }\n    } // 如果scope被删除，将scope重置为all\n\n\n    if (getScope() === scope) setScope(newScope || 'all');\n  } // 清除修饰键\n\n\n  function clearModifier(event) {\n    var key = event.keyCode || event.which || event.charCode;\n\n    var i = _downKeys.indexOf(key); // 从列表中清除按压过的键\n\n\n    if (i >= 0) {\n      _downKeys.splice(i, 1);\n    } // 特殊处理 cmmand 键，在 cmmand 组合快捷键 keyup 只执行一次的问题\n\n\n    if (event.key && event.key.toLowerCase() === 'meta') {\n      _downKeys.splice(0, _downKeys.length);\n    } // 修饰键 shiftKey altKey ctrlKey (command||metaKey) 清除\n\n\n    if (key === 93 || key === 224) key = 91;\n\n    if (key in _mods) {\n      _mods[key] = false; // 将修饰键重置为false\n\n      for (var k in _modifier) {\n        if (_modifier[k] === key) hotkeys[k] = false;\n      }\n    }\n  }\n\n  function unbind(keysInfo) {\n    // unbind(), unbind all keys\n    if (!keysInfo) {\n      Object.keys(_handlers).forEach(function (key) {\n        return delete _handlers[key];\n      });\n    } else if (Array.isArray(keysInfo)) {\n      // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])\n      keysInfo.forEach(function (info) {\n        if (info.key) eachUnbind(info);\n      });\n    } else if (typeof keysInfo === 'object') {\n      // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})\n      if (keysInfo.key) eachUnbind(keysInfo);\n    } else if (typeof keysInfo === 'string') {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      // support old method\n      // eslint-disable-line\n      var scope = args[0],\n          method = args[1];\n\n      if (typeof scope === 'function') {\n        method = scope;\n        scope = '';\n      }\n\n      eachUnbind({\n        key: keysInfo,\n        scope: scope,\n        method: method,\n        splitKey: '+'\n      });\n    }\n  } // 解除绑定某个范围的快捷键\n\n\n  var eachUnbind = function eachUnbind(_ref) {\n    var key = _ref.key,\n        scope = _ref.scope,\n        method = _ref.method,\n        _ref$splitKey = _ref.splitKey,\n        splitKey = _ref$splitKey === void 0 ? '+' : _ref$splitKey;\n    var multipleKeys = getKeys(key);\n    multipleKeys.forEach(function (originKey) {\n      var unbindKeys = originKey.split(splitKey);\n      var len = unbindKeys.length;\n      var lastKey = unbindKeys[len - 1];\n      var keyCode = lastKey === '*' ? '*' : code(lastKey);\n      if (!_handlers[keyCode]) return; // 判断是否传入范围，没有就获取范围\n\n      if (!scope) scope = getScope();\n      var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];\n      _handlers[keyCode] = _handlers[keyCode].map(function (record) {\n        // 通过函数判断，是否解除绑定，函数相等直接返回\n        var isMatchingMethod = method ? record.method === method : true;\n\n        if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {\n          return {};\n        }\n\n        return record;\n      });\n    });\n  }; // 对监听对应快捷键的回调函数进行处理\n\n\n  function eventHandler(event, handler, scope) {\n    var modifiersMatch; // 看它是否在当前范围\n\n    if (handler.scope === scope || handler.scope === 'all') {\n      // 检查是否匹配修饰符（如果有返回true）\n      modifiersMatch = handler.mods.length > 0;\n\n      for (var y in _mods) {\n        if (Object.prototype.hasOwnProperty.call(_mods, y)) {\n          if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {\n            modifiersMatch = false;\n          }\n        }\n      } // 调用处理程序，如果是修饰键不做处理\n\n\n      if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {\n        if (handler.method(event, handler) === false) {\n          if (event.preventDefault) event.preventDefault();else event.returnValue = false;\n          if (event.stopPropagation) event.stopPropagation();\n          if (event.cancelBubble) event.cancelBubble = true;\n        }\n      }\n    }\n  } // 处理keydown事件\n\n\n  function dispatch(event) {\n    var asterisk = _handlers['*'];\n    var key = event.keyCode || event.which || event.charCode; // 表单控件过滤 默认表单控件不触发快捷键\n\n    if (!hotkeys.filter.call(this, event)) return; // Gecko(Firefox)的command键值224，在Webkit(Chrome)中保持一致\n    // Webkit左右 command 键值不一样\n\n    if (key === 93 || key === 224) key = 91;\n    /**\n     * Collect bound keys\n     * If an Input Method Editor is processing key input and the event is keydown, return 229.\n     * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229\n     * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n     */\n\n    if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);\n    /**\n     * Jest test cases are required.\n     * ===============================\n     */\n\n    ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {\n      var keyNum = modifierMap[keyName];\n\n      if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {\n        _downKeys.push(keyNum);\n      } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {\n        _downKeys.splice(_downKeys.indexOf(keyNum), 1);\n      } else if (keyName === 'metaKey' && event[keyName] && _downKeys.length === 3) {\n        /**\n         * Fix if Command is pressed:\n         * ===============================\n         */\n        if (!(event.ctrlKey || event.shiftKey || event.altKey)) {\n          _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));\n        }\n      }\n    });\n    /**\n     * -------------------------------\n     */\n\n    if (key in _mods) {\n      _mods[key] = true; // 将特殊字符的key注册到 hotkeys 上\n\n      for (var k in _modifier) {\n        if (_modifier[k] === key) hotkeys[k] = true;\n      }\n\n      if (!asterisk) return;\n    } // 将 modifierMap 里面的修饰键绑定到 event 中\n\n\n    for (var e in _mods) {\n      if (Object.prototype.hasOwnProperty.call(_mods, e)) {\n        _mods[e] = event[modifierMap[e]];\n      }\n    }\n    /**\n     * https://github.com/jaywcjlove/hotkeys/pull/129\n     * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.\n     * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type μ.\n     * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate\n     */\n\n\n    if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {\n      if (_downKeys.indexOf(17) === -1) {\n        _downKeys.push(17);\n      }\n\n      if (_downKeys.indexOf(18) === -1) {\n        _downKeys.push(18);\n      }\n\n      _mods[17] = true;\n      _mods[18] = true;\n    } // 获取范围 默认为 `all`\n\n\n    var scope = getScope(); // 对任何快捷键都需要做的处理\n\n    if (asterisk) {\n      for (var i = 0; i < asterisk.length; i++) {\n        if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {\n          eventHandler(event, asterisk[i], scope);\n        }\n      }\n    } // key 不在 _handlers 中返回\n\n\n    if (!(key in _handlers)) return;\n\n    for (var _i = 0; _i < _handlers[key].length; _i++) {\n      if (event.type === 'keydown' && _handlers[key][_i].keydown || event.type === 'keyup' && _handlers[key][_i].keyup) {\n        if (_handlers[key][_i].key) {\n          var record = _handlers[key][_i];\n          var splitKey = record.splitKey;\n          var keyShortcut = record.key.split(splitKey);\n          var _downKeysCurrent = []; // 记录当前按键键值\n\n          for (var a = 0; a < keyShortcut.length; a++) {\n            _downKeysCurrent.push(code(keyShortcut[a]));\n          }\n\n          if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {\n            // 找到处理内容\n            eventHandler(event, record, scope);\n          }\n        }\n      }\n    }\n  } // 判断 element 是否已经绑定事件\n\n\n  function isElementBind(element) {\n    return elementHasBindEvent.indexOf(element) > -1;\n  }\n\n  function hotkeys(key, option, method) {\n    _downKeys = [];\n    var keys = getKeys(key); // 需要处理的快捷键列表\n\n    var mods = [];\n    var scope = 'all'; // scope默认为all，所有范围都有效\n\n    var element = document; // 快捷键事件绑定节点\n\n    var i = 0;\n    var keyup = false;\n    var keydown = true;\n    var splitKey = '+'; // 对为设定范围的判断\n\n    if (method === undefined && typeof option === 'function') {\n      method = option;\n    }\n\n    if (Object.prototype.toString.call(option) === '[object Object]') {\n      if (option.scope) scope = option.scope; // eslint-disable-line\n\n      if (option.element) element = option.element; // eslint-disable-line\n\n      if (option.keyup) keyup = option.keyup; // eslint-disable-line\n\n      if (option.keydown !== undefined) keydown = option.keydown; // eslint-disable-line\n\n      if (typeof option.splitKey === 'string') splitKey = option.splitKey; // eslint-disable-line\n    }\n\n    if (typeof option === 'string') scope = option; // 对于每个快捷键进行处理\n\n    for (; i < keys.length; i++) {\n      key = keys[i].split(splitKey); // 按键列表\n\n      mods = []; // 如果是组合快捷键取得组合快捷键\n\n      if (key.length > 1) mods = getMods(_modifier, key); // 将非修饰键转化为键码\n\n      key = key[key.length - 1];\n      key = key === '*' ? '*' : code(key); // *表示匹配所有快捷键\n      // 判断key是否在_handlers中，不在就赋一个空数组\n\n      if (!(key in _handlers)) _handlers[key] = [];\n\n      _handlers[key].push({\n        keyup: keyup,\n        keydown: keydown,\n        scope: scope,\n        mods: mods,\n        shortcut: keys[i],\n        method: method,\n        key: keys[i],\n        splitKey: splitKey\n      });\n    } // 在全局document上设置快捷键\n\n\n    if (typeof element !== 'undefined' && !isElementBind(element) && window) {\n      elementHasBindEvent.push(element);\n      addEvent(element, 'keydown', function (e) {\n        dispatch(e);\n      });\n      addEvent(window, 'focus', function () {\n        _downKeys = [];\n      });\n      addEvent(element, 'keyup', function (e) {\n        dispatch(e);\n        clearModifier(e);\n      });\n    }\n  }\n\n  var _api = {\n    setScope: setScope,\n    getScope: getScope,\n    deleteScope: deleteScope,\n    getPressedKeyCodes: getPressedKeyCodes,\n    isPressed: isPressed,\n    filter: filter,\n    unbind: unbind\n  };\n\n  for (var a in _api) {\n    if (Object.prototype.hasOwnProperty.call(_api, a)) {\n      hotkeys[a] = _api[a];\n    }\n  }\n\n  if (typeof window !== 'undefined') {\n    var _hotkeys = window.hotkeys;\n\n    hotkeys.noConflict = function (deep) {\n      if (deep && window.hotkeys === hotkeys) {\n        window.hotkeys = _hotkeys;\n      }\n\n      return hotkeys;\n    };\n\n    window.hotkeys = hotkeys;\n  }\n\n  return hotkeys;\n\n})));\n\n\n//# sourceURL=webpack://sat/./node_modules/hotkeys-js/dist/hotkeys.js?")},"./node_modules/mark.js/dist/mark.js":function(module){eval("/*!***************************************************\n* mark.js v8.11.1\n* https://markjs.io/\n* Copyright (c) 2014–2018, Julian Kühnel\n* Released under the MIT license https://git.io/vwTVl\n*****************************************************/\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n}(this, (function () { 'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar DOMIterator = function () {\n  function DOMIterator(ctx) {\n    var iframes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var iframesTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5000;\n    classCallCheck(this, DOMIterator);\n\n    this.ctx = ctx;\n    this.iframes = iframes;\n    this.exclude = exclude;\n    this.iframesTimeout = iframesTimeout;\n  }\n\n  createClass(DOMIterator, [{\n    key: 'getContexts',\n    value: function getContexts() {\n      var ctx = void 0,\n          filteredCtx = [];\n      if (typeof this.ctx === 'undefined' || !this.ctx) {\n        ctx = [];\n      } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {\n        ctx = Array.prototype.slice.call(this.ctx);\n      } else if (Array.isArray(this.ctx)) {\n        ctx = this.ctx;\n      } else if (typeof this.ctx === 'string') {\n        ctx = Array.prototype.slice.call(document.querySelectorAll(this.ctx));\n      } else {\n        ctx = [this.ctx];\n      }\n      ctx.forEach(function (ctx) {\n        var isDescendant = filteredCtx.filter(function (contexts) {\n          return contexts.contains(ctx);\n        }).length > 0;\n        if (filteredCtx.indexOf(ctx) === -1 && !isDescendant) {\n          filteredCtx.push(ctx);\n        }\n      });\n      return filteredCtx;\n    }\n  }, {\n    key: 'getIframeContents',\n    value: function getIframeContents(ifr, successFn) {\n      var errorFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\n      var doc = void 0;\n      try {\n        var ifrWin = ifr.contentWindow;\n        doc = ifrWin.document;\n        if (!ifrWin || !doc) {\n          throw new Error('iframe inaccessible');\n        }\n      } catch (e) {\n        errorFn();\n      }\n      if (doc) {\n        successFn(doc);\n      }\n    }\n  }, {\n    key: 'isIframeBlank',\n    value: function isIframeBlank(ifr) {\n      var bl = 'about:blank',\n          src = ifr.getAttribute('src').trim(),\n          href = ifr.contentWindow.location.href;\n      return href === bl && src !== bl && src;\n    }\n  }, {\n    key: 'observeIframeLoad',\n    value: function observeIframeLoad(ifr, successFn, errorFn) {\n      var _this = this;\n\n      var called = false,\n          tout = null;\n      var listener = function listener() {\n        if (called) {\n          return;\n        }\n        called = true;\n        clearTimeout(tout);\n        try {\n          if (!_this.isIframeBlank(ifr)) {\n            ifr.removeEventListener('load', listener);\n            _this.getIframeContents(ifr, successFn, errorFn);\n          }\n        } catch (e) {\n          errorFn();\n        }\n      };\n      ifr.addEventListener('load', listener);\n      tout = setTimeout(listener, this.iframesTimeout);\n    }\n  }, {\n    key: 'onIframeReady',\n    value: function onIframeReady(ifr, successFn, errorFn) {\n      try {\n        if (ifr.contentWindow.document.readyState === 'complete') {\n          if (this.isIframeBlank(ifr)) {\n            this.observeIframeLoad(ifr, successFn, errorFn);\n          } else {\n            this.getIframeContents(ifr, successFn, errorFn);\n          }\n        } else {\n          this.observeIframeLoad(ifr, successFn, errorFn);\n        }\n      } catch (e) {\n        errorFn();\n      }\n    }\n  }, {\n    key: 'waitForIframes',\n    value: function waitForIframes(ctx, done) {\n      var _this2 = this;\n\n      var eachCalled = 0;\n      this.forEachIframe(ctx, function () {\n        return true;\n      }, function (ifr) {\n        eachCalled++;\n        _this2.waitForIframes(ifr.querySelector('html'), function () {\n          if (! --eachCalled) {\n            done();\n          }\n        });\n      }, function (handled) {\n        if (!handled) {\n          done();\n        }\n      });\n    }\n  }, {\n    key: 'forEachIframe',\n    value: function forEachIframe(ctx, filter, each) {\n      var _this3 = this;\n\n      var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n\n      var ifr = ctx.querySelectorAll('iframe'),\n          open = ifr.length,\n          handled = 0;\n      ifr = Array.prototype.slice.call(ifr);\n      var checkEnd = function checkEnd() {\n        if (--open <= 0) {\n          end(handled);\n        }\n      };\n      if (!open) {\n        checkEnd();\n      }\n      ifr.forEach(function (ifr) {\n        if (DOMIterator.matches(ifr, _this3.exclude)) {\n          checkEnd();\n        } else {\n          _this3.onIframeReady(ifr, function (con) {\n            if (filter(ifr)) {\n              handled++;\n              each(con);\n            }\n            checkEnd();\n          }, checkEnd);\n        }\n      });\n    }\n  }, {\n    key: 'createIterator',\n    value: function createIterator(ctx, whatToShow, filter) {\n      return document.createNodeIterator(ctx, whatToShow, filter, false);\n    }\n  }, {\n    key: 'createInstanceOnIframe',\n    value: function createInstanceOnIframe(contents) {\n      return new DOMIterator(contents.querySelector('html'), this.iframes);\n    }\n  }, {\n    key: 'compareNodeIframe',\n    value: function compareNodeIframe(node, prevNode, ifr) {\n      var compCurr = node.compareDocumentPosition(ifr),\n          prev = Node.DOCUMENT_POSITION_PRECEDING;\n      if (compCurr & prev) {\n        if (prevNode !== null) {\n          var compPrev = prevNode.compareDocumentPosition(ifr),\n              after = Node.DOCUMENT_POSITION_FOLLOWING;\n          if (compPrev & after) {\n            return true;\n          }\n        } else {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'getIteratorNode',\n    value: function getIteratorNode(itr) {\n      var prevNode = itr.previousNode();\n      var node = void 0;\n      if (prevNode === null) {\n        node = itr.nextNode();\n      } else {\n        node = itr.nextNode() && itr.nextNode();\n      }\n      return {\n        prevNode: prevNode,\n        node: node\n      };\n    }\n  }, {\n    key: 'checkIframeFilter',\n    value: function checkIframeFilter(node, prevNode, currIfr, ifr) {\n      var key = false,\n          handled = false;\n      ifr.forEach(function (ifrDict, i) {\n        if (ifrDict.val === currIfr) {\n          key = i;\n          handled = ifrDict.handled;\n        }\n      });\n      if (this.compareNodeIframe(node, prevNode, currIfr)) {\n        if (key === false && !handled) {\n          ifr.push({\n            val: currIfr,\n            handled: true\n          });\n        } else if (key !== false && !handled) {\n          ifr[key].handled = true;\n        }\n        return true;\n      }\n      if (key === false) {\n        ifr.push({\n          val: currIfr,\n          handled: false\n        });\n      }\n      return false;\n    }\n  }, {\n    key: 'handleOpenIframes',\n    value: function handleOpenIframes(ifr, whatToShow, eCb, fCb) {\n      var _this4 = this;\n\n      ifr.forEach(function (ifrDict) {\n        if (!ifrDict.handled) {\n          _this4.getIframeContents(ifrDict.val, function (con) {\n            _this4.createInstanceOnIframe(con).forEachNode(whatToShow, eCb, fCb);\n          });\n        }\n      });\n    }\n  }, {\n    key: 'iterateThroughNodes',\n    value: function iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {\n      var _this5 = this;\n\n      var itr = this.createIterator(ctx, whatToShow, filterCb);\n      var ifr = [],\n          elements = [],\n          node = void 0,\n          prevNode = void 0,\n          retrieveNodes = function retrieveNodes() {\n        var _getIteratorNode = _this5.getIteratorNode(itr);\n\n        prevNode = _getIteratorNode.prevNode;\n        node = _getIteratorNode.node;\n\n        return node;\n      };\n      while (retrieveNodes()) {\n        if (this.iframes) {\n          this.forEachIframe(ctx, function (currIfr) {\n            return _this5.checkIframeFilter(node, prevNode, currIfr, ifr);\n          }, function (con) {\n            _this5.createInstanceOnIframe(con).forEachNode(whatToShow, function (ifrNode) {\n              return elements.push(ifrNode);\n            }, filterCb);\n          });\n        }\n        elements.push(node);\n      }\n      elements.forEach(function (node) {\n        eachCb(node);\n      });\n      if (this.iframes) {\n        this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);\n      }\n      doneCb();\n    }\n  }, {\n    key: 'forEachNode',\n    value: function forEachNode(whatToShow, each, filter) {\n      var _this6 = this;\n\n      var done = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n\n      var contexts = this.getContexts();\n      var open = contexts.length;\n      if (!open) {\n        done();\n      }\n      contexts.forEach(function (ctx) {\n        var ready = function ready() {\n          _this6.iterateThroughNodes(whatToShow, ctx, each, filter, function () {\n            if (--open <= 0) {\n              done();\n            }\n          });\n        };\n        if (_this6.iframes) {\n          _this6.waitForIframes(ctx, ready);\n        } else {\n          ready();\n        }\n      });\n    }\n  }], [{\n    key: 'matches',\n    value: function matches(element, selector) {\n      var selectors = typeof selector === 'string' ? [selector] : selector,\n          fn = element.matches || element.matchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector;\n      if (fn) {\n        var match = false;\n        selectors.every(function (sel) {\n          if (fn.call(element, sel)) {\n            match = true;\n            return false;\n          }\n          return true;\n        });\n        return match;\n      } else {\n        return false;\n      }\n    }\n  }]);\n  return DOMIterator;\n}();\n\nvar Mark$1 = function () {\n  function Mark(ctx) {\n    classCallCheck(this, Mark);\n\n    this.ctx = ctx;\n    this.ie = false;\n    var ua = window.navigator.userAgent;\n    if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) {\n      this.ie = true;\n    }\n  }\n\n  createClass(Mark, [{\n    key: 'log',\n    value: function log(msg) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'debug';\n\n      var log = this.opt.log;\n      if (!this.opt.debug) {\n        return;\n      }\n      if ((typeof log === 'undefined' ? 'undefined' : _typeof(log)) === 'object' && typeof log[level] === 'function') {\n        log[level]('mark.js: ' + msg);\n      }\n    }\n  }, {\n    key: 'escapeStr',\n    value: function escapeStr(str) {\n      return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n    }\n  }, {\n    key: 'createRegExp',\n    value: function createRegExp(str) {\n      if (this.opt.wildcards !== 'disabled') {\n        str = this.setupWildcardsRegExp(str);\n      }\n      str = this.escapeStr(str);\n      if (Object.keys(this.opt.synonyms).length) {\n        str = this.createSynonymsRegExp(str);\n      }\n      if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n        str = this.setupIgnoreJoinersRegExp(str);\n      }\n      if (this.opt.diacritics) {\n        str = this.createDiacriticsRegExp(str);\n      }\n      str = this.createMergedBlanksRegExp(str);\n      if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n        str = this.createJoinersRegExp(str);\n      }\n      if (this.opt.wildcards !== 'disabled') {\n        str = this.createWildcardsRegExp(str);\n      }\n      str = this.createAccuracyRegExp(str);\n      return str;\n    }\n  }, {\n    key: 'createSynonymsRegExp',\n    value: function createSynonymsRegExp(str) {\n      var syn = this.opt.synonyms,\n          sens = this.opt.caseSensitive ? '' : 'i',\n          joinerPlaceholder = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? '\\0' : '';\n      for (var index in syn) {\n        if (syn.hasOwnProperty(index)) {\n          var value = syn[index],\n              k1 = this.opt.wildcards !== 'disabled' ? this.setupWildcardsRegExp(index) : this.escapeStr(index),\n              k2 = this.opt.wildcards !== 'disabled' ? this.setupWildcardsRegExp(value) : this.escapeStr(value);\n          if (k1 !== '' && k2 !== '') {\n            str = str.replace(new RegExp('(' + this.escapeStr(k1) + '|' + this.escapeStr(k2) + ')', 'gm' + sens), joinerPlaceholder + ('(' + this.processSynomyms(k1) + '|') + (this.processSynomyms(k2) + ')') + joinerPlaceholder);\n          }\n        }\n      }\n      return str;\n    }\n  }, {\n    key: 'processSynomyms',\n    value: function processSynomyms(str) {\n      if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n        str = this.setupIgnoreJoinersRegExp(str);\n      }\n      return str;\n    }\n  }, {\n    key: 'setupWildcardsRegExp',\n    value: function setupWildcardsRegExp(str) {\n      str = str.replace(/(?:\\\\)*\\?/g, function (val) {\n        return val.charAt(0) === '\\\\' ? '?' : '\\x01';\n      });\n      return str.replace(/(?:\\\\)*\\*/g, function (val) {\n        return val.charAt(0) === '\\\\' ? '*' : '\\x02';\n      });\n    }\n  }, {\n    key: 'createWildcardsRegExp',\n    value: function createWildcardsRegExp(str) {\n      var spaces = this.opt.wildcards === 'withSpaces';\n      return str.replace(/\\u0001/g, spaces ? '[\\\\S\\\\s]?' : '\\\\S?').replace(/\\u0002/g, spaces ? '[\\\\S\\\\s]*?' : '\\\\S*');\n    }\n  }, {\n    key: 'setupIgnoreJoinersRegExp',\n    value: function setupIgnoreJoinersRegExp(str) {\n      return str.replace(/[^(|)\\\\]/g, function (val, indx, original) {\n        var nextChar = original.charAt(indx + 1);\n        if (/[(|)\\\\]/.test(nextChar) || nextChar === '') {\n          return val;\n        } else {\n          return val + '\\0';\n        }\n      });\n    }\n  }, {\n    key: 'createJoinersRegExp',\n    value: function createJoinersRegExp(str) {\n      var joiner = [];\n      var ignorePunctuation = this.opt.ignorePunctuation;\n      if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {\n        joiner.push(this.escapeStr(ignorePunctuation.join('')));\n      }\n      if (this.opt.ignoreJoiners) {\n        joiner.push('\\\\u00ad\\\\u200b\\\\u200c\\\\u200d');\n      }\n      return joiner.length ? str.split(/\\u0000+/).join('[' + joiner.join('') + ']*') : str;\n    }\n  }, {\n    key: 'createDiacriticsRegExp',\n    value: function createDiacriticsRegExp(str) {\n      var sens = this.opt.caseSensitive ? '' : 'i',\n          dct = this.opt.caseSensitive ? ['aàáảãạăằắẳẵặâầấẩẫậäåāą', 'AÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ', 'cçćč', 'CÇĆČ', 'dđď', 'DĐĎ', 'eèéẻẽẹêềếểễệëěēę', 'EÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ', 'iìíỉĩịîïī', 'IÌÍỈĨỊÎÏĪ', 'lł', 'LŁ', 'nñňń', 'NÑŇŃ', 'oòóỏõọôồốổỗộơởỡớờợöøō', 'OÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ', 'rř', 'RŘ', 'sšśșş', 'SŠŚȘŞ', 'tťțţ', 'TŤȚŢ', 'uùúủũụưừứửữựûüůū', 'UÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ', 'yýỳỷỹỵÿ', 'YÝỲỶỸỴŸ', 'zžżź', 'ZŽŻŹ'] : ['aàáảãạăằắẳẵặâầấẩẫậäåāąAÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ', 'cçćčCÇĆČ', 'dđďDĐĎ', 'eèéẻẽẹêềếểễệëěēęEÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ', 'iìíỉĩịîïīIÌÍỈĨỊÎÏĪ', 'lłLŁ', 'nñňńNÑŇŃ', 'oòóỏõọôồốổỗộơởỡớờợöøōOÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ', 'rřRŘ', 'sšśșşSŠŚȘŞ', 'tťțţTŤȚŢ', 'uùúủũụưừứửữựûüůūUÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ', 'yýỳỷỹỵÿYÝỲỶỸỴŸ', 'zžżźZŽŻŹ'];\n      var handled = [];\n      str.split('').forEach(function (ch) {\n        dct.every(function (dct) {\n          if (dct.indexOf(ch) !== -1) {\n            if (handled.indexOf(dct) > -1) {\n              return false;\n            }\n            str = str.replace(new RegExp('[' + dct + ']', 'gm' + sens), '[' + dct + ']');\n            handled.push(dct);\n          }\n          return true;\n        });\n      });\n      return str;\n    }\n  }, {\n    key: 'createMergedBlanksRegExp',\n    value: function createMergedBlanksRegExp(str) {\n      return str.replace(/[\\s]+/gmi, '[\\\\s]+');\n    }\n  }, {\n    key: 'createAccuracyRegExp',\n    value: function createAccuracyRegExp(str) {\n      var _this = this;\n\n      var chars = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~¡¿';\n      var acc = this.opt.accuracy,\n          val = typeof acc === 'string' ? acc : acc.value,\n          ls = typeof acc === 'string' ? [] : acc.limiters,\n          lsJoin = '';\n      ls.forEach(function (limiter) {\n        lsJoin += '|' + _this.escapeStr(limiter);\n      });\n      switch (val) {\n        case 'partially':\n        default:\n          return '()(' + str + ')';\n        case 'complementary':\n          lsJoin = '\\\\s' + (lsJoin ? lsJoin : this.escapeStr(chars));\n          return '()([^' + lsJoin + ']*' + str + '[^' + lsJoin + ']*)';\n        case 'exactly':\n          return '(^|\\\\s' + lsJoin + ')(' + str + ')(?=$|\\\\s' + lsJoin + ')';\n      }\n    }\n  }, {\n    key: 'getSeparatedKeywords',\n    value: function getSeparatedKeywords(sv) {\n      var _this2 = this;\n\n      var stack = [];\n      sv.forEach(function (kw) {\n        if (!_this2.opt.separateWordSearch) {\n          if (kw.trim() && stack.indexOf(kw) === -1) {\n            stack.push(kw);\n          }\n        } else {\n          kw.split(' ').forEach(function (kwSplitted) {\n            if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {\n              stack.push(kwSplitted);\n            }\n          });\n        }\n      });\n      return {\n        'keywords': stack.sort(function (a, b) {\n          return b.length - a.length;\n        }),\n        'length': stack.length\n      };\n    }\n  }, {\n    key: 'isNumeric',\n    value: function isNumeric(value) {\n      return Number(parseFloat(value)) == value;\n    }\n  }, {\n    key: 'checkRanges',\n    value: function checkRanges(array) {\n      var _this3 = this;\n\n      if (!Array.isArray(array) || Object.prototype.toString.call(array[0]) !== '[object Object]') {\n        this.log('markRanges() will only accept an array of objects');\n        this.opt.noMatch(array);\n        return [];\n      }\n      var stack = [];\n      var last = 0;\n      array.sort(function (a, b) {\n        return a.start - b.start;\n      }).forEach(function (item) {\n        var _callNoMatchOnInvalid = _this3.callNoMatchOnInvalidRanges(item, last),\n            start = _callNoMatchOnInvalid.start,\n            end = _callNoMatchOnInvalid.end,\n            valid = _callNoMatchOnInvalid.valid;\n\n        if (valid) {\n          item.start = start;\n          item.length = end - start;\n          stack.push(item);\n          last = end;\n        }\n      });\n      return stack;\n    }\n  }, {\n    key: 'callNoMatchOnInvalidRanges',\n    value: function callNoMatchOnInvalidRanges(range, last) {\n      var start = void 0,\n          end = void 0,\n          valid = false;\n      if (range && typeof range.start !== 'undefined') {\n        start = parseInt(range.start, 10);\n        end = start + parseInt(range.length, 10);\n        if (this.isNumeric(range.start) && this.isNumeric(range.length) && end - last > 0 && end - start > 0) {\n          valid = true;\n        } else {\n          this.log('Ignoring invalid or overlapping range: ' + ('' + JSON.stringify(range)));\n          this.opt.noMatch(range);\n        }\n      } else {\n        this.log('Ignoring invalid range: ' + JSON.stringify(range));\n        this.opt.noMatch(range);\n      }\n      return {\n        start: start,\n        end: end,\n        valid: valid\n      };\n    }\n  }, {\n    key: 'checkWhitespaceRanges',\n    value: function checkWhitespaceRanges(range, originalLength, string) {\n      var end = void 0,\n          valid = true,\n          max = string.length,\n          offset = originalLength - max,\n          start = parseInt(range.start, 10) - offset;\n      start = start > max ? max : start;\n      end = start + parseInt(range.length, 10);\n      if (end > max) {\n        end = max;\n        this.log('End range automatically set to the max value of ' + max);\n      }\n      if (start < 0 || end - start < 0 || start > max || end > max) {\n        valid = false;\n        this.log('Invalid range: ' + JSON.stringify(range));\n        this.opt.noMatch(range);\n      } else if (string.substring(start, end).replace(/\\s+/g, '') === '') {\n        valid = false;\n        this.log('Skipping whitespace only range: ' + JSON.stringify(range));\n        this.opt.noMatch(range);\n      }\n      return {\n        start: start,\n        end: end,\n        valid: valid\n      };\n    }\n  }, {\n    key: 'getTextNodes',\n    value: function getTextNodes(cb) {\n      var _this4 = this;\n\n      var val = '',\n          nodes = [];\n      this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function (node) {\n        nodes.push({\n          start: val.length,\n          end: (val += node.textContent).length,\n          node: node\n        });\n      }, function (node) {\n        if (_this4.matchesExclude(node.parentNode)) {\n          return NodeFilter.FILTER_REJECT;\n        } else {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n      }, function () {\n        cb({\n          value: val,\n          nodes: nodes\n        });\n      });\n    }\n  }, {\n    key: 'matchesExclude',\n    value: function matchesExclude(el) {\n      return DOMIterator.matches(el, this.opt.exclude.concat(['script', 'style', 'title', 'head', 'html']));\n    }\n  }, {\n    key: 'wrapRangeInTextNode',\n    value: function wrapRangeInTextNode(node, start, end) {\n      var hEl = !this.opt.element ? 'mark' : this.opt.element,\n          startNode = node.splitText(start),\n          ret = startNode.splitText(end - start);\n      var repl = document.createElement(hEl);\n      repl.setAttribute('data-markjs', 'true');\n      if (this.opt.className) {\n        repl.setAttribute('class', this.opt.className);\n      }\n      repl.textContent = startNode.textContent;\n      startNode.parentNode.replaceChild(repl, startNode);\n      return ret;\n    }\n  }, {\n    key: 'wrapRangeInMappedTextNode',\n    value: function wrapRangeInMappedTextNode(dict, start, end, filterCb, eachCb) {\n      var _this5 = this;\n\n      dict.nodes.every(function (n, i) {\n        var sibl = dict.nodes[i + 1];\n        if (typeof sibl === 'undefined' || sibl.start > start) {\n          if (!filterCb(n.node)) {\n            return false;\n          }\n          var s = start - n.start,\n              e = (end > n.end ? n.end : end) - n.start,\n              startStr = dict.value.substr(0, n.start),\n              endStr = dict.value.substr(e + n.start);\n          n.node = _this5.wrapRangeInTextNode(n.node, s, e);\n          dict.value = startStr + endStr;\n          dict.nodes.forEach(function (k, j) {\n            if (j >= i) {\n              if (dict.nodes[j].start > 0 && j !== i) {\n                dict.nodes[j].start -= e;\n              }\n              dict.nodes[j].end -= e;\n            }\n          });\n          end -= e;\n          eachCb(n.node.previousSibling, n.start);\n          if (end > n.end) {\n            start = n.end;\n          } else {\n            return false;\n          }\n        }\n        return true;\n      });\n    }\n  }, {\n    key: 'wrapMatches',\n    value: function wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {\n      var _this6 = this;\n\n      var matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n      this.getTextNodes(function (dict) {\n        dict.nodes.forEach(function (node) {\n          node = node.node;\n          var match = void 0;\n          while ((match = regex.exec(node.textContent)) !== null && match[matchIdx] !== '') {\n            if (!filterCb(match[matchIdx], node)) {\n              continue;\n            }\n            var pos = match.index;\n            if (matchIdx !== 0) {\n              for (var i = 1; i < matchIdx; i++) {\n                pos += match[i].length;\n              }\n            }\n            node = _this6.wrapRangeInTextNode(node, pos, pos + match[matchIdx].length);\n            eachCb(node.previousSibling);\n            regex.lastIndex = 0;\n          }\n        });\n        endCb();\n      });\n    }\n  }, {\n    key: 'wrapMatchesAcrossElements',\n    value: function wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {\n      var _this7 = this;\n\n      var matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n      this.getTextNodes(function (dict) {\n        var match = void 0;\n        while ((match = regex.exec(dict.value)) !== null && match[matchIdx] !== '') {\n          var start = match.index;\n          if (matchIdx !== 0) {\n            for (var i = 1; i < matchIdx; i++) {\n              start += match[i].length;\n            }\n          }\n          var end = start + match[matchIdx].length;\n          _this7.wrapRangeInMappedTextNode(dict, start, end, function (node) {\n            return filterCb(match[matchIdx], node);\n          }, function (node, lastIndex) {\n            regex.lastIndex = lastIndex;\n            eachCb(node);\n          });\n        }\n        endCb();\n      });\n    }\n  }, {\n    key: 'wrapRangeFromIndex',\n    value: function wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {\n      var _this8 = this;\n\n      this.getTextNodes(function (dict) {\n        var originalLength = dict.value.length;\n        ranges.forEach(function (range, counter) {\n          var _checkWhitespaceRange = _this8.checkWhitespaceRanges(range, originalLength, dict.value),\n              start = _checkWhitespaceRange.start,\n              end = _checkWhitespaceRange.end,\n              valid = _checkWhitespaceRange.valid;\n\n          if (valid) {\n            _this8.wrapRangeInMappedTextNode(dict, start, end, function (node) {\n              return filterCb(node, range, dict.value.substring(start, end), counter);\n            }, function (node) {\n              eachCb(node, range);\n            });\n          }\n        });\n        endCb();\n      });\n    }\n  }, {\n    key: 'unwrapMatches',\n    value: function unwrapMatches(node) {\n      var parent = node.parentNode;\n      var docFrag = document.createDocumentFragment();\n      while (node.firstChild) {\n        docFrag.appendChild(node.removeChild(node.firstChild));\n      }\n      parent.replaceChild(docFrag, node);\n      if (!this.ie) {\n        parent.normalize();\n      } else {\n        this.normalizeTextNode(parent);\n      }\n    }\n  }, {\n    key: 'normalizeTextNode',\n    value: function normalizeTextNode(node) {\n      if (!node) {\n        return;\n      }\n      if (node.nodeType === 3) {\n        while (node.nextSibling && node.nextSibling.nodeType === 3) {\n          node.nodeValue += node.nextSibling.nodeValue;\n          node.parentNode.removeChild(node.nextSibling);\n        }\n      } else {\n        this.normalizeTextNode(node.firstChild);\n      }\n      this.normalizeTextNode(node.nextSibling);\n    }\n  }, {\n    key: 'markRegExp',\n    value: function markRegExp(regexp, opt) {\n      var _this9 = this;\n\n      this.opt = opt;\n      this.log('Searching with expression \"' + regexp + '\"');\n      var totalMatches = 0,\n          fn = 'wrapMatches';\n      var eachCb = function eachCb(element) {\n        totalMatches++;\n        _this9.opt.each(element);\n      };\n      if (this.opt.acrossElements) {\n        fn = 'wrapMatchesAcrossElements';\n      }\n      this[fn](regexp, this.opt.ignoreGroups, function (match, node) {\n        return _this9.opt.filter(node, match, totalMatches);\n      }, eachCb, function () {\n        if (totalMatches === 0) {\n          _this9.opt.noMatch(regexp);\n        }\n        _this9.opt.done(totalMatches);\n      });\n    }\n  }, {\n    key: 'mark',\n    value: function mark(sv, opt) {\n      var _this10 = this;\n\n      this.opt = opt;\n      var totalMatches = 0,\n          fn = 'wrapMatches';\n\n      var _getSeparatedKeywords = this.getSeparatedKeywords(typeof sv === 'string' ? [sv] : sv),\n          kwArr = _getSeparatedKeywords.keywords,\n          kwArrLen = _getSeparatedKeywords.length,\n          sens = this.opt.caseSensitive ? '' : 'i',\n          handler = function handler(kw) {\n        var regex = new RegExp(_this10.createRegExp(kw), 'gm' + sens),\n            matches = 0;\n        _this10.log('Searching with expression \"' + regex + '\"');\n        _this10[fn](regex, 1, function (term, node) {\n          return _this10.opt.filter(node, kw, totalMatches, matches);\n        }, function (element) {\n          matches++;\n          totalMatches++;\n          _this10.opt.each(element);\n        }, function () {\n          if (matches === 0) {\n            _this10.opt.noMatch(kw);\n          }\n          if (kwArr[kwArrLen - 1] === kw) {\n            _this10.opt.done(totalMatches);\n          } else {\n            handler(kwArr[kwArr.indexOf(kw) + 1]);\n          }\n        });\n      };\n\n      if (this.opt.acrossElements) {\n        fn = 'wrapMatchesAcrossElements';\n      }\n      if (kwArrLen === 0) {\n        this.opt.done(totalMatches);\n      } else {\n        handler(kwArr[0]);\n      }\n    }\n  }, {\n    key: 'markRanges',\n    value: function markRanges(rawRanges, opt) {\n      var _this11 = this;\n\n      this.opt = opt;\n      var totalMatches = 0,\n          ranges = this.checkRanges(rawRanges);\n      if (ranges && ranges.length) {\n        this.log('Starting to mark with the following ranges: ' + JSON.stringify(ranges));\n        this.wrapRangeFromIndex(ranges, function (node, range, match, counter) {\n          return _this11.opt.filter(node, range, match, counter);\n        }, function (element, range) {\n          totalMatches++;\n          _this11.opt.each(element, range);\n        }, function () {\n          _this11.opt.done(totalMatches);\n        });\n      } else {\n        this.opt.done(totalMatches);\n      }\n    }\n  }, {\n    key: 'unmark',\n    value: function unmark(opt) {\n      var _this12 = this;\n\n      this.opt = opt;\n      var sel = this.opt.element ? this.opt.element : '*';\n      sel += '[data-markjs]';\n      if (this.opt.className) {\n        sel += '.' + this.opt.className;\n      }\n      this.log('Removal selector \"' + sel + '\"');\n      this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function (node) {\n        _this12.unwrapMatches(node);\n      }, function (node) {\n        var matchesSel = DOMIterator.matches(node, sel),\n            matchesExclude = _this12.matchesExclude(node);\n        if (!matchesSel || matchesExclude) {\n          return NodeFilter.FILTER_REJECT;\n        } else {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n      }, this.opt.done);\n    }\n  }, {\n    key: 'opt',\n    set: function set$$1(val) {\n      this._opt = _extends({}, {\n        'element': '',\n        'className': '',\n        'exclude': [],\n        'iframes': false,\n        'iframesTimeout': 5000,\n        'separateWordSearch': true,\n        'diacritics': true,\n        'synonyms': {},\n        'accuracy': 'partially',\n        'acrossElements': false,\n        'caseSensitive': false,\n        'ignoreJoiners': false,\n        'ignoreGroups': 0,\n        'ignorePunctuation': [],\n        'wildcards': 'disabled',\n        'each': function each() {},\n        'noMatch': function noMatch() {},\n        'filter': function filter() {\n          return true;\n        },\n        'done': function done() {},\n        'debug': false,\n        'log': window.console\n      }, val);\n    },\n    get: function get$$1() {\n      return this._opt;\n    }\n  }, {\n    key: 'iterator',\n    get: function get$$1() {\n      return new DOMIterator(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);\n    }\n  }]);\n  return Mark;\n}();\n\nfunction Mark(ctx) {\n  var _this = this;\n\n  var instance = new Mark$1(ctx);\n  this.mark = function (sv, opt) {\n    instance.mark(sv, opt);\n    return _this;\n  };\n  this.markRegExp = function (sv, opt) {\n    instance.markRegExp(sv, opt);\n    return _this;\n  };\n  this.markRanges = function (sv, opt) {\n    instance.markRanges(sv, opt);\n    return _this;\n  };\n  this.unmark = function (opt) {\n    instance.unmark(opt);\n    return _this;\n  };\n  return this;\n}\n\nreturn Mark;\n\n})));\n\n\n//# sourceURL=webpack://sat/./node_modules/mark.js/dist/mark.js?")},"./node_modules/rangy-classapplier/bundles/index.umd.js":function(__unused_webpack_module,exports,__webpack_require__){eval('(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! rangy2 */ "./node_modules/rangy2/esm5/index.js")) :\n    0;\n}(this, function (exports, api) { \'use strict\';\n\n    /**\n     * Class Applier module for Rangy.\n     * Adds, removes and toggles classes on Ranges and Selections\n     *\n     * Part of Rangy, a cross-browser JavaScript range and selection library\n     * https://github.com/timdown/rangy\n     *\n     * Depends on Rangy core.\n     *\n     * Copyright 2019, Tim Down\n     * Licensed under the MIT license.\n     * Version: 2.1.0\n     * Build date: 19 April 2019\n     */\n    var DomPosition = api.dom.DomPosition, isHostMethod = api.util.isHostMethod;\n\n    var module = new api.Module("ClassApplier", ["WrappedSelection"]);\n\n    var defaultTagName = "span";\n    var createElementNSSupported = isHostMethod(document, "createElementNS");\n    function each(obj, func) {\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {\n                if (func(i, obj[i]) === false) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    function trim(str) {\n        return str.replace(/^\\s\\s*/, "").replace(/\\s\\s*$/, "");\n    }\n    function classNameContainsClass(fullClassName, className) {\n        return !!fullClassName && new RegExp("(?:^|\\\\s)" + className + "(?:\\\\s|$)").test(fullClassName);\n    }\n    // Inefficient, inelegant nonsense for IE\'s svg element, which has no classList and non-HTML className implementation\n    function hasClass(el, className) {\n        if (typeof el.classList == "object") {\n            return el.classList.contains(className);\n        }\n        else {\n            var classNameSupported = (typeof el.className == "string");\n            var elClass = classNameSupported ? el.className : el.getAttribute("class");\n            return classNameContainsClass(elClass, className);\n        }\n    }\n    function addClass(el, className) {\n        if (typeof el.classList == "object") {\n            el.classList.add(className);\n        }\n        else {\n            var classNameSupported = (typeof el.className == "string");\n            var elClass = classNameSupported ? el.className : el.getAttribute("class");\n            if (elClass) {\n                if (!classNameContainsClass(elClass, className)) {\n                    elClass += " " + className;\n                }\n            }\n            else {\n                elClass = className;\n            }\n            if (classNameSupported) {\n                el.className = elClass;\n            }\n            else {\n                el.setAttribute("class", elClass);\n            }\n        }\n    }\n    var removeClass = (function () {\n        function replacer(matched, whiteSpaceBefore, whiteSpaceAfter) {\n            return (whiteSpaceBefore && whiteSpaceAfter) ? " " : "";\n        }\n        return function (el, className) {\n            if (typeof el.classList == "object") {\n                el.classList.remove(className);\n            }\n            else {\n                var classNameSupported = (typeof el.className == "string");\n                var elClass = classNameSupported ? el.className : el.getAttribute("class");\n                elClass = elClass.replace(new RegExp("(^|\\\\s)" + className + "(\\\\s|$)"), replacer);\n                if (classNameSupported) {\n                    el.className = elClass;\n                }\n                else {\n                    el.setAttribute("class", elClass);\n                }\n            }\n        };\n    })();\n    function getClass(el) {\n        var classNameSupported = (typeof el.className == "string");\n        return classNameSupported ? el.className : el.getAttribute("class");\n    }\n    function sortClassName(className) {\n        return className && className.split(/\\s+/).sort().join(" ");\n    }\n    function getSortedClassName(el) {\n        return sortClassName(getClass(el));\n    }\n    function haveSameClasses(el1, el2) {\n        return getSortedClassName(el1) == getSortedClassName(el2);\n    }\n    function hasAllClasses(el, className) {\n        var classes = className.split(/\\s+/);\n        for (var i = 0, len = classes.length; i < len; ++i) {\n            if (!hasClass(el, trim(classes[i]))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function canTextBeStyled(textNode) {\n        var parent = textNode.parentNode;\n        return (parent && parent.nodeType == 1 && !/^(textarea|style|script|select|iframe)$/i.test(parent.nodeName));\n    }\n    function movePosition(position, oldParent, oldIndex, newParent, newIndex) {\n        var posNode = position.node, posOffset = position.offset;\n        var newNode = posNode, newOffset = posOffset;\n        if (posNode == newParent && posOffset > newIndex) {\n            ++newOffset;\n        }\n        if (posNode == oldParent && (posOffset == oldIndex || posOffset == oldIndex + 1)) {\n            newNode = newParent;\n            newOffset += newIndex - oldIndex;\n        }\n        if (posNode == oldParent && posOffset > oldIndex + 1) {\n            --newOffset;\n        }\n        position.node = newNode;\n        position.offset = newOffset;\n    }\n    function movePositionWhenRemovingNode(position, parentNode, index) {\n        if (position.node == parentNode && position.offset > index) {\n            --position.offset;\n        }\n    }\n    function movePreservingPositions(node, newParent, newIndex, positionsToPreserve) {\n        // For convenience, allow newIndex to be -1 to mean "insert at the end".\n        if (newIndex == -1) {\n            newIndex = newParent.childNodes.length;\n        }\n        var oldParent = node.parentNode;\n        var oldIndex = api.dom.getNodeIndex(node);\n        positionsToPreserve.forEach(function (position) {\n            movePosition(position, oldParent, oldIndex, newParent, newIndex);\n        });\n        // Now actually move the node.\n        if (newParent.childNodes.length == newIndex) {\n            newParent.appendChild(node);\n        }\n        else {\n            newParent.insertBefore(node, newParent.childNodes[newIndex]);\n        }\n    }\n    function removePreservingPositions(node, positionsToPreserve) {\n        var oldParent = node.parentNode;\n        var oldIndex = api.dom.getNodeIndex(node);\n        positionsToPreserve.forEach(function (position) {\n            movePositionWhenRemovingNode(position, oldParent, oldIndex);\n        });\n        api.dom.removeNode(node);\n    }\n    function moveChildrenPreservingPositions(node, newParent, newIndex, removeNode, positionsToPreserve) {\n        var child, children = [];\n        while ((child = node.firstChild)) {\n            movePreservingPositions(child, newParent, newIndex++, positionsToPreserve);\n            children.push(child);\n        }\n        if (removeNode) {\n            removePreservingPositions(node, positionsToPreserve);\n        }\n        return children;\n    }\n    function replaceWithOwnChildrenPreservingPositions(element, positionsToPreserve) {\n        return moveChildrenPreservingPositions(element, element.parentNode, api.dom.getNodeIndex(element), true, positionsToPreserve);\n    }\n    function rangeSelectsAnyText(range, textNode) {\n        var textNodeRange = range.cloneRange();\n        textNodeRange.selectNodeContents(textNode);\n        var intersectionRange = textNodeRange.intersection(range);\n        var text = intersectionRange ? intersectionRange.toString() : "";\n        return text != "";\n    }\n    function getEffectiveTextNodes(range) {\n        var nodes = range.getNodes([3]);\n        // Optimization as per issue 145\n        // Remove non-intersecting text nodes from the start of the range\n        var start = 0, node;\n        while ((node = nodes[start]) && !rangeSelectsAnyText(range, node)) {\n            ++start;\n        }\n        // Remove non-intersecting text nodes from the start of the range\n        var end = nodes.length - 1;\n        while ((node = nodes[end]) && !rangeSelectsAnyText(range, node)) {\n            --end;\n        }\n        return nodes.slice(start, end + 1);\n    }\n    function elementsHaveSameNonClassAttributes(el1, el2) {\n        if (el1.attributes.length != el2.attributes.length)\n            return false;\n        for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {\n            attr1 = el1.attributes[i];\n            name = attr1.name;\n            if (name != "class") {\n                attr2 = el2.attributes.getNamedItem(name);\n                if ((attr1 === null) != (attr2 === null))\n                    return false;\n                if (attr1.specified != attr2.specified)\n                    return false;\n                if (attr1.specified && attr1.nodeValue !== attr2.nodeValue)\n                    return false;\n            }\n        }\n        return true;\n    }\n    function elementHasNonClassAttributes(el, exceptions) {\n        for (var i = 0, len = el.attributes.length, attrName; i < len; ++i) {\n            attrName = el.attributes[i].name;\n            if (!(exceptions && exceptions.includes(attrName)) && el.attributes[i].specified && attrName != "class") {\n                return true;\n            }\n        }\n        return false;\n    }\n    var getComputedStyleProperty = api.dom.getComputedStyleProperty;\n    var isEditableElement = (function () {\n        var testEl = document.createElement("div");\n        return typeof testEl.isContentEditable == "boolean" ?\n            function (node) {\n                return node && node.nodeType == 1 && node.isContentEditable;\n            } :\n            function (node) {\n                if (!node || node.nodeType != 1 || node.contentEditable == "false") {\n                    return false;\n                }\n                return node.contentEditable == "true" || isEditableElement(node.parentNode);\n            };\n    })();\n    function isEditingHost(node) {\n        var parent;\n        return node && node.nodeType == 1 &&\n            (((parent = node.parentNode) && parent.nodeType == 9 && parent.designMode == "on") ||\n                (isEditableElement(node) && !isEditableElement(node.parentNode)));\n    }\n    function isEditable(node) {\n        return (isEditableElement(node) || (node.nodeType != 1 && isEditableElement(node.parentNode))) && !isEditingHost(node);\n    }\n    var inlineDisplayRegex = /^inline(-block|-table)?$/i;\n    function isNonInlineElement(node) {\n        return node && node.nodeType == 1 && !inlineDisplayRegex.test(getComputedStyleProperty(node, "display"));\n    }\n    // White space characters as defined by HTML 4 (http://www.w3.org/TR/html401/struct/text.html)\n    var htmlNonWhiteSpaceRegex = /[^\\r\\n\\t\\f \\u200B]/;\n    function isUnrenderedWhiteSpaceNode(node) {\n        if (node.data.length == 0) {\n            return true;\n        }\n        if (htmlNonWhiteSpaceRegex.test(node.data)) {\n            return false;\n        }\n        var cssWhiteSpace = getComputedStyleProperty(node.parentNode, "whiteSpace");\n        switch (cssWhiteSpace) {\n            case "pre":\n            case "pre-wrap":\n            case "-moz-pre-wrap":\n                return false;\n            case "pre-line":\n                if (/[\\r\\n]/.test(node.data)) {\n                    return false;\n                }\n        }\n        // We now have a whitespace-only text node that may be rendered depending on its context. If it is adjacent to a\n        // non-inline element, it will not be rendered. This seems to be a good enough definition.\n        return isNonInlineElement(node.previousSibling) || isNonInlineElement(node.nextSibling);\n    }\n    function getRangeBoundaries(ranges) {\n        var positions = [], i, range;\n        for (i = 0; range = ranges[i++];) {\n            positions.push(new DomPosition(range.startContainer, range.startOffset), new DomPosition(range.endContainer, range.endOffset));\n        }\n        return positions;\n    }\n    function updateRangesFromBoundaries(ranges, positions) {\n        for (var i = 0, range, start, end, len = ranges.length; i < len; ++i) {\n            range = ranges[i];\n            start = positions[i * 2];\n            end = positions[i * 2 + 1];\n            range.setStartAndEnd(start.node, start.offset, end.node, end.offset);\n        }\n    }\n    function isSplitPoint(node, offset) {\n        if (api.dom.isCharacterDataNode(node)) {\n            if (offset == 0) {\n                return !!node.previousSibling;\n            }\n            else if (offset == node.length) {\n                return !!node.nextSibling;\n            }\n            else {\n                return true;\n            }\n        }\n        return offset > 0 && offset < node.childNodes.length;\n    }\n    function splitNodeAt(node, descendantNode, descendantOffset, positionsToPreserve) {\n        var newNode, parentNode;\n        var splitAtStart = (descendantOffset == 0);\n        if (api.dom.isAncestorOf(descendantNode, node)) {\n            return node;\n        }\n        if (api.dom.isCharacterDataNode(descendantNode)) {\n            var descendantIndex = api.dom.getNodeIndex(descendantNode);\n            if (descendantOffset == 0) {\n                descendantOffset = descendantIndex;\n            }\n            else if (descendantOffset == descendantNode.length) {\n                descendantOffset = descendantIndex + 1;\n            }\n            else {\n                throw module.createError("splitNodeAt() should not be called with offset in the middle of a data node (" +\n                    descendantOffset + " in " + descendantNode.data);\n            }\n            descendantNode = descendantNode.parentNode;\n        }\n        if (isSplitPoint(descendantNode, descendantOffset)) {\n            // descendantNode is now guaranteed not to be a text or other character node\n            newNode = descendantNode.cloneNode(false);\n            parentNode = descendantNode.parentNode;\n            if (newNode.id) {\n                newNode.removeAttribute("id");\n            }\n            var child, newChildIndex = 0;\n            while ((child = descendantNode.childNodes[descendantOffset])) {\n                movePreservingPositions(child, newNode, newChildIndex++, positionsToPreserve);\n            }\n            movePreservingPositions(newNode, parentNode, api.dom.getNodeIndex(descendantNode) + 1, positionsToPreserve);\n            return (descendantNode == node) ? newNode : splitNodeAt(node, parentNode, api.dom.getNodeIndex(newNode), positionsToPreserve);\n        }\n        else if (node != descendantNode) {\n            newNode = descendantNode.parentNode;\n            // Work out a new split point in the parent node\n            var newNodeIndex = api.dom.getNodeIndex(descendantNode);\n            if (!splitAtStart) {\n                newNodeIndex++;\n            }\n            return splitNodeAt(node, newNode, newNodeIndex, positionsToPreserve);\n        }\n        return node;\n    }\n    function areElementsMergeable(el1, el2) {\n        return el1.namespaceURI == el2.namespaceURI &&\n            el1.tagName.toLowerCase() == el2.tagName.toLowerCase() &&\n            haveSameClasses(el1, el2) &&\n            elementsHaveSameNonClassAttributes(el1, el2) &&\n            getComputedStyleProperty(el1, "display") == "inline" &&\n            getComputedStyleProperty(el2, "display") == "inline";\n    }\n    function createAdjacentMergeableTextNodeGetter(forward) {\n        var siblingPropName = forward ? "nextSibling" : "previousSibling";\n        return function (textNode, checkParentElement) {\n            var el = textNode.parentNode;\n            var adjacentNode = textNode[siblingPropName];\n            if (adjacentNode) {\n                // Can merge if the node\'s previous/next sibling is a text node\n                if (adjacentNode && adjacentNode.nodeType == 3) {\n                    return adjacentNode;\n                }\n            }\n            else if (checkParentElement) {\n                // Compare text node parent element with its sibling\n                adjacentNode = el[siblingPropName];\n                if (adjacentNode && adjacentNode.nodeType == 1 && areElementsMergeable(el, adjacentNode)) {\n                    var adjacentNodeChild = adjacentNode[forward ? "firstChild" : "lastChild"];\n                    if (adjacentNodeChild && adjacentNodeChild.nodeType == 3) {\n                        return adjacentNodeChild;\n                    }\n                }\n            }\n            return null;\n        };\n    }\n    var getPreviousMergeableTextNode = createAdjacentMergeableTextNodeGetter(false), getNextMergeableTextNode = createAdjacentMergeableTextNodeGetter(true);\n    var Merge = /** @class */ (function () {\n        function Merge(firstNode) {\n            this.isElementMerge = (firstNode.nodeType == 1);\n            this.textNodes = [];\n            var firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;\n            if (firstTextNode) {\n                this.textNodes.push(firstTextNode);\n            }\n        }\n        Merge.prototype.doMerge = function (positionsToPreserve) {\n            var textNodes = this.textNodes;\n            var firstTextNode = textNodes[0];\n            if (textNodes.length > 1) {\n                var firstTextNodeIndex = api.dom.getNodeIndex(firstTextNode);\n                var textParts = [], combinedTextLength = 0, parent;\n                var len_1 = textNodes.length;\n                textNodes.forEach(function (textNode, i) {\n                    parent = textNode.parentNode;\n                    if (i > 0) {\n                        parent.removeChild(textNode);\n                        if (!parent.hasChildNodes()) {\n                            api.dom.removeNode(parent);\n                        }\n                        if (positionsToPreserve) {\n                            positionsToPreserve.forEach(function (position) {\n                                // Handle case where position is inside the text node being merged into a preceding node\n                                if (position.node == textNode) {\n                                    position.node = firstTextNode;\n                                    position.offset += combinedTextLength;\n                                }\n                                // Handle case where both text nodes precede the position within the same parent node\n                                if (position.node == parent && position.offset > firstTextNodeIndex) {\n                                    --position.offset;\n                                    if (position.offset == firstTextNodeIndex + 1 && i < len_1 - 1) {\n                                        position.node = firstTextNode;\n                                        position.offset = combinedTextLength;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    textParts[i] = textNode.data;\n                    combinedTextLength += textNode.data.length;\n                });\n                firstTextNode.data = textParts.join("");\n            }\n            return firstTextNode.data;\n        };\n        Merge.prototype.getLength = function () {\n            var i = this.textNodes.length, len = 0;\n            while (i--) {\n                len += this.textNodes[i].length;\n            }\n            return len;\n        };\n        Merge.prototype.toString = function () {\n            var textParts = [];\n            this.textNodes.forEach(function (textNode, i) {\n                textParts[i] = "\'" + textNode.data + "\'";\n            });\n            return "[Merge(" + textParts.join(",") + ")]";\n        };\n        return Merge;\n    }());\n    var optionProperties = ["elementTagName", "ignoreWhiteSpace", "applyToEditableOnly", "useExistingElements",\n        "removeEmptyElements", "onElementCreate"];\n    // TODO: Populate this with every attribute name that corresponds to a property with a different name. Really??\n    var attrNamesForProperties = {};\n    var util = {\n        hasClass: hasClass,\n        addClass: addClass,\n        removeClass: removeClass,\n        getClass: getClass,\n        hasSameClasses: haveSameClasses,\n        hasAllClasses: hasAllClasses,\n        replaceWithOwnChildren: replaceWithOwnChildrenPreservingPositions,\n        elementsHaveSameNonClassAttributes: elementsHaveSameNonClassAttributes,\n        elementHasNonClassAttributes: elementHasNonClassAttributes,\n        splitNodeAt: splitNodeAt,\n        isEditableElement: isEditableElement,\n        isEditingHost: isEditingHost,\n        isEditable: isEditable\n    };\n    var ClassApplier = /** @class */ (function () {\n        function ClassApplier(className, options, tagNames) {\n            this.className = className;\n            this.elementTagName = defaultTagName;\n            this.ignoreWhiteSpace = true;\n            this.applyToEditableOnly = false;\n            this.useExistingElements = true;\n            this.removeEmptyElements = true;\n            var normalize, i, len, propName, applier = this;\n            applier.cssClass = className; // cssClass property is for backward compatibility\n            var elementPropertiesFromOptions = null, elementAttributes = {};\n            // Initialize from options object\n            if (typeof options == "object" && options !== null) {\n                if (typeof options.elementTagName !== "undefined") {\n                    options.elementTagName = options.elementTagName.toLowerCase();\n                }\n                tagNames = options.tagNames;\n                elementPropertiesFromOptions = options.elementProperties;\n                elementAttributes = options.elementAttributes;\n                for (i = 0; propName = optionProperties[i++];) {\n                    if (options.hasOwnProperty(propName)) {\n                        applier[propName] = options[propName];\n                    }\n                }\n                normalize = options.normalize;\n            }\n            else {\n                normalize = options;\n            }\n            // Backward compatibility: the second parameter can also be a Boolean indicating to normalize after unapplying\n            applier.normalize = (typeof normalize == "undefined") ? true : normalize;\n            // Initialize element properties and attribute exceptions\n            applier.attrExceptions = [];\n            var el = document.createElement(applier.elementTagName);\n            applier.elementProperties = applier.copyPropertiesToElement(elementPropertiesFromOptions, el, true);\n            each(elementAttributes, function (attrName, attrValue) {\n                applier.attrExceptions.push(attrName);\n                // Ensure each attribute value is a string\n                elementAttributes[attrName] = "" + attrValue;\n            });\n            applier.elementAttributes = elementAttributes;\n            applier.elementSortedClassName = applier.elementProperties.hasOwnProperty("className") ?\n                sortClassName(applier.elementProperties.className + " " + className) : className;\n            // Initialize tag names\n            applier.applyToAnyTagName = false;\n            if (typeof tagNames === "string") {\n                if (tagNames == "*") {\n                    applier.applyToAnyTagName = true;\n                }\n                else {\n                    applier.tagNames = trim(tagNames.toLowerCase()).split(/\\s*,\\s*/);\n                }\n            }\n            else if (typeof tagNames == "object" && typeof tagNames.length == "number") {\n                applier.tagNames = [];\n                for (i = 0, len = tagNames.length; i < len; ++i) {\n                    if (tagNames[i] == "*") {\n                        applier.applyToAnyTagName = true;\n                    }\n                    else {\n                        applier.tagNames.push(tagNames[i].toLowerCase());\n                    }\n                }\n            }\n            else {\n                applier.tagNames = [applier.elementTagName];\n            }\n        }\n        ClassApplier.prototype.copyPropertiesToElement = function (props, el, createCopy) {\n            var s, elStyle, elProps = {}, elPropsStyle, propValue, elPropValue, attrName;\n            for (var p in props) {\n                if (props.hasOwnProperty(p)) {\n                    propValue = props[p];\n                    elPropValue = el[p];\n                    // Special case for class. The copied properties object has the applier\'s class as well as its own\n                    // to simplify checks when removing styling elements\n                    if (p == "className") {\n                        addClass(el, propValue);\n                        addClass(el, this.className);\n                        el[p] = sortClassName(el[p]);\n                        if (createCopy) {\n                            elProps[p] = propValue;\n                        }\n                    }\n                    // Special case for style\n                    else if (p == "style") {\n                        elStyle = elPropValue;\n                        if (createCopy) {\n                            elProps[p] = elPropsStyle = {};\n                        }\n                        for (s in props[p]) {\n                            if (props[p].hasOwnProperty(s)) {\n                                elStyle[s] = propValue[s];\n                                if (createCopy) {\n                                    elPropsStyle[s] = elStyle[s];\n                                }\n                            }\n                        }\n                        this.attrExceptions.push(p);\n                    }\n                    else {\n                        el[p] = propValue;\n                        // Copy the property back from the dummy element so that later comparisons to check whether\n                        // elements may be removed are checking against the right value. For example, the href property\n                        // of an element returns a fully qualified URL even if it was previously assigned a relative\n                        // URL.\n                        if (createCopy) {\n                            elProps[p] = el[p];\n                            // Not all properties map to identically-named attributes\n                            attrName = attrNamesForProperties.hasOwnProperty(p) ? attrNamesForProperties[p] : p;\n                            this.attrExceptions.push(attrName);\n                        }\n                    }\n                }\n            }\n            return createCopy ? elProps : "";\n        };\n        ClassApplier.prototype.copyAttributesToElement = function (attrs, el) {\n            for (var attrName in attrs) {\n                if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {\n                    el.setAttribute(attrName, attrs[attrName]);\n                }\n            }\n        };\n        ClassApplier.prototype.appliesToElement = function (el) {\n            return this.tagNames.includes(el.tagName.toLowerCase());\n        };\n        ClassApplier.prototype.getEmptyElements = function (range) {\n            var applier = this;\n            return range.getNodes([1], function (el) {\n                return applier.appliesToElement(el) && !el.hasChildNodes();\n            });\n        };\n        ClassApplier.prototype.hasClass = function (node) {\n            return node.nodeType == 1 &&\n                (this.applyToAnyTagName || this.appliesToElement(node)) &&\n                hasClass(node, this.className);\n        };\n        ClassApplier.prototype.getSelfOrAncestorWithClass = function (node) {\n            while (node) {\n                if (this.hasClass(node)) {\n                    return node;\n                }\n                node = node.parentNode;\n            }\n            return null;\n        };\n        ClassApplier.prototype.isModifiable = function (node) {\n            return !this.applyToEditableOnly || isEditable(node);\n        };\n        // White space adjacent to an unwrappable node can be ignored for wrapping\n        ClassApplier.prototype.isIgnorableWhiteSpaceNode = function (node) {\n            return this.ignoreWhiteSpace && node && node.nodeType == 3 && isUnrenderedWhiteSpaceNode(node);\n        };\n        // Normalizes nodes after applying a class to a Range.\n        ClassApplier.prototype.postApply = function (textNodes, range, positionsToPreserve, isUndo) {\n            var firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];\n            var merges = [], currentMerge;\n            var rangeStartNode = firstNode, rangeEndNode = lastNode;\n            var rangeStartOffset = 0, rangeEndOffset = lastNode.length;\n            var precedingTextNode;\n            // Check for every required merge and create a Merge object for each\n            textNodes.forEach(function (textNode) {\n                precedingTextNode = getPreviousMergeableTextNode(textNode, !isUndo);\n                if (precedingTextNode) {\n                    if (!currentMerge) {\n                        currentMerge = new Merge(precedingTextNode);\n                        merges.push(currentMerge);\n                    }\n                    currentMerge.textNodes.push(textNode);\n                    if (textNode === firstNode) {\n                        rangeStartNode = currentMerge.textNodes[0];\n                        rangeStartOffset = rangeStartNode.length;\n                    }\n                    if (textNode === lastNode) {\n                        rangeEndNode = currentMerge.textNodes[0];\n                        rangeEndOffset = currentMerge.getLength();\n                    }\n                }\n                else {\n                    currentMerge = null;\n                }\n            });\n            // Test whether the first node after the range needs merging\n            var nextTextNode = getNextMergeableTextNode(lastNode, !isUndo);\n            if (nextTextNode) {\n                if (!currentMerge) {\n                    currentMerge = new Merge(lastNode);\n                    merges.push(currentMerge);\n                }\n                currentMerge.textNodes.push(nextTextNode);\n            }\n            // Apply the merges\n            if (merges.length) {\n                for (var i = 0, len = merges.length; i < len; ++i) {\n                    merges[i].doMerge(positionsToPreserve);\n                }\n                // Set the range boundaries\n                range.setStartAndEnd(rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);\n            }\n        };\n        ClassApplier.prototype.createContainer = function (parentNode) {\n            var doc = api.dom.getDocument(parentNode);\n            var namespace;\n            var el = createElementNSSupported && !api.dom.isHtmlNamespace(parentNode) && (namespace = parentNode.namespaceURI) ?\n                doc.createElementNS(parentNode.namespaceURI, this.elementTagName) :\n                doc.createElement(this.elementTagName);\n            this.copyPropertiesToElement(this.elementProperties, el, false);\n            this.copyAttributesToElement(this.elementAttributes, el);\n            addClass(el, this.className);\n            if (this.onElementCreate) {\n                this.onElementCreate(el, this);\n            }\n            return el;\n        };\n        ClassApplier.prototype.elementHasProperties = function (el, props) {\n            var applier = this;\n            return each(props, function (p, propValue) {\n                if (p == "className") {\n                    // For checking whether we should reuse an existing element, we just want to check that the element\n                    // has all the classes specified in the className property. When deciding whether the element is\n                    // removable when unapplying a class, there is separate special handling to check whether the\n                    // element has extra classes so the same simple check will do.\n                    return hasAllClasses(el, propValue);\n                }\n                else if (typeof propValue == "object") {\n                    if (!applier.elementHasProperties(el[p], propValue)) {\n                        return false;\n                    }\n                }\n                else if (el[p] !== propValue) {\n                    return false;\n                }\n            });\n        };\n        ClassApplier.prototype.elementHasAttributes = function (el, attrs) {\n            return each(attrs, function (name, value) {\n                if (el.getAttribute(name) !== value) {\n                    return false;\n                }\n            });\n        };\n        ClassApplier.prototype.applyToTextNode = function (textNode, positionsToPreserve) {\n            // Check whether the text node can be styled. Text within a <style> or <script> element, for example,\n            // should not be styled. See issue 283.\n            if (canTextBeStyled(textNode)) {\n                var parent = textNode.parentNode;\n                if (parent.childNodes.length == 1 &&\n                    this.useExistingElements &&\n                    this.appliesToElement(parent) &&\n                    this.elementHasProperties(parent, this.elementProperties) &&\n                    this.elementHasAttributes(parent, this.elementAttributes)) {\n                    addClass(parent, this.className);\n                }\n                else {\n                    var textNodeParent = textNode.parentNode;\n                    var el = this.createContainer(textNodeParent);\n                    textNodeParent.insertBefore(el, textNode);\n                    el.appendChild(textNode);\n                }\n            }\n        };\n        ClassApplier.prototype.isRemovable = function (el) {\n            return el.tagName.toLowerCase() == this.elementTagName &&\n                getSortedClassName(el) == this.elementSortedClassName &&\n                this.elementHasProperties(el, this.elementProperties) &&\n                !elementHasNonClassAttributes(el, this.attrExceptions) &&\n                this.elementHasAttributes(el, this.elementAttributes) &&\n                this.isModifiable(el);\n        };\n        ClassApplier.prototype.isEmptyContainer = function (el) {\n            var childNodeCount = el.childNodes.length;\n            return el.nodeType == 1 &&\n                this.isRemovable(el) &&\n                (childNodeCount == 0 || (childNodeCount == 1 && this.isEmptyContainer(el.firstChild)));\n        };\n        ClassApplier.prototype.removeEmptyContainers = function (range) {\n            var applier = this;\n            var nodesToRemove = range.getNodes([1], function (el) {\n                return applier.isEmptyContainer(el);\n            });\n            var rangesToPreserve = [range];\n            var positionsToPreserve = getRangeBoundaries(rangesToPreserve);\n            nodesToRemove.forEach(function (node) {\n                removePreservingPositions(node, positionsToPreserve);\n            });\n            // Update the range from the preserved boundary positions\n            updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);\n        };\n        ClassApplier.prototype.undoToTextNode = function (textNode, range, ancestorWithClass, positionsToPreserve) {\n            if (!range.containsNode(ancestorWithClass)) {\n                // Split out the portion of the ancestor from which we can remove the class\n                //var parent = ancestorWithClass.parentNode, index = dom.getNodeIndex(ancestorWithClass);\n                var ancestorRange = range.cloneRange();\n                ancestorRange.selectNode(ancestorWithClass);\n                if (ancestorRange.isPointInRange(range.endContainer, range.endOffset)) {\n                    splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset, positionsToPreserve);\n                    range.setEndAfter(ancestorWithClass);\n                }\n                if (ancestorRange.isPointInRange(range.startContainer, range.startOffset)) {\n                    ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset, positionsToPreserve);\n                }\n            }\n            if (this.isRemovable(ancestorWithClass)) {\n                replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);\n            }\n            else {\n                removeClass(ancestorWithClass, this.className);\n            }\n        };\n        ClassApplier.prototype.splitAncestorWithClass = function (container, offset, positionsToPreserve) {\n            var ancestorWithClass = this.getSelfOrAncestorWithClass(container);\n            if (ancestorWithClass) {\n                splitNodeAt(ancestorWithClass, container, offset, positionsToPreserve);\n            }\n        };\n        ClassApplier.prototype.undoToAncestor = function (ancestorWithClass, positionsToPreserve) {\n            if (this.isRemovable(ancestorWithClass)) {\n                replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);\n            }\n            else {\n                removeClass(ancestorWithClass, this.className);\n            }\n        };\n        ClassApplier.prototype.applyToRange = function (range, rangesToPreserve) {\n            var applier = this;\n            rangesToPreserve = rangesToPreserve || [];\n            // Create an array of range boundaries to preserve\n            var positionsToPreserve = getRangeBoundaries(rangesToPreserve || []);\n            range.splitBoundariesPreservingPositions(positionsToPreserve);\n            // Tidy up the DOM by removing empty containers\n            if (applier.removeEmptyElements) {\n                applier.removeEmptyContainers(range);\n            }\n            var textNodes = getEffectiveTextNodes(range);\n            if (textNodes.length) {\n                textNodes.forEach(function (textNode) {\n                    if (!applier.isIgnorableWhiteSpaceNode(textNode) && !applier.getSelfOrAncestorWithClass(textNode) &&\n                        applier.isModifiable(textNode)) {\n                        applier.applyToTextNode(textNode, positionsToPreserve);\n                    }\n                });\n                var lastTextNode = textNodes[textNodes.length - 1];\n                range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);\n                if (applier.normalize) {\n                    applier.postApply(textNodes, range, positionsToPreserve, false);\n                }\n                // Update the ranges from the preserved boundary positions\n                updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);\n            }\n            // Apply classes to any appropriate empty elements\n            var emptyElements = applier.getEmptyElements(range);\n            emptyElements.forEach(function (el) {\n                addClass(el, applier.className);\n            });\n        };\n        ClassApplier.prototype.applyToRanges = function (ranges) {\n            var i = ranges.length;\n            while (i--) {\n                this.applyToRange(ranges[i], ranges);\n            }\n            return ranges;\n        };\n        ClassApplier.prototype.applyToSelection = function (win) {\n            var sel = api.getSelection(win);\n            sel.setRanges(this.applyToRanges(sel.getAllRanges()));\n        };\n        ClassApplier.prototype.undoToRange = function (range, rangesToPreserve) {\n            var applier = this;\n            // Create an array of range boundaries to preserve\n            rangesToPreserve = rangesToPreserve || [];\n            var positionsToPreserve = getRangeBoundaries(rangesToPreserve);\n            range.splitBoundariesPreservingPositions(positionsToPreserve);\n            // Tidy up the DOM by removing empty containers\n            if (applier.removeEmptyElements) {\n                applier.removeEmptyContainers(range); //, positionsToPreserve);\n            }\n            var textNodes = getEffectiveTextNodes(range);\n            var textNode, ancestorWithClass;\n            var lastTextNode = textNodes[textNodes.length - 1];\n            if (textNodes.length) {\n                applier.splitAncestorWithClass(range.endContainer, range.endOffset, positionsToPreserve);\n                applier.splitAncestorWithClass(range.startContainer, range.startOffset, positionsToPreserve);\n                for (var i = 0, len = textNodes.length; i < len; ++i) {\n                    textNode = textNodes[i];\n                    ancestorWithClass = applier.getSelfOrAncestorWithClass(textNode);\n                    if (ancestorWithClass && applier.isModifiable(textNode)) {\n                        applier.undoToAncestor(ancestorWithClass, positionsToPreserve);\n                    }\n                }\n                // Ensure the range is still valid\n                range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);\n                if (applier.normalize) {\n                    applier.postApply(textNodes, range, positionsToPreserve, true);\n                }\n                // Update the ranges from the preserved boundary positions\n                updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);\n            }\n            // Remove class from any appropriate empty elements\n            var emptyElements = applier.getEmptyElements(range);\n            emptyElements.forEach(function (el) {\n                removeClass(el, applier.className);\n            });\n        };\n        ClassApplier.prototype.undoToRanges = function (ranges) {\n            // Get ranges returned in document order\n            var i = ranges.length;\n            while (i--) {\n                this.undoToRange(ranges[i], ranges);\n            }\n            return ranges;\n        };\n        ClassApplier.prototype.undoToSelection = function (win) {\n            var sel = api.getSelection(win);\n            var ranges = api.getSelection(win).getAllRanges();\n            this.undoToRanges(ranges);\n            sel.setRanges(ranges);\n        };\n        ClassApplier.prototype.isAppliedToRange = function (range) {\n            if (range.collapsed || range.toString() == "") {\n                return !!this.getSelfOrAncestorWithClass(range.commonAncestorContainer);\n            }\n            else {\n                var textNodes = range.getNodes([3]);\n                if (textNodes.length)\n                    for (var i = 0, textNode; textNode = textNodes[i++];) {\n                        if (!this.isIgnorableWhiteSpaceNode(textNode) && rangeSelectsAnyText(range, textNode) &&\n                            this.isModifiable(textNode) && !this.getSelfOrAncestorWithClass(textNode)) {\n                            return false;\n                        }\n                    }\n                return true;\n            }\n        };\n        ClassApplier.prototype.isAppliedToRanges = function (ranges) {\n            var i = ranges.length;\n            if (i == 0) {\n                return false;\n            }\n            while (i--) {\n                if (!this.isAppliedToRange(ranges[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        ClassApplier.prototype.isAppliedToSelection = function (win) {\n            var sel = api.getSelection(win);\n            return this.isAppliedToRanges(sel.getAllRanges());\n        };\n        ClassApplier.prototype.toggleRange = function (range) {\n            if (this.isAppliedToRange(range)) {\n                this.undoToRange(range);\n            }\n            else {\n                this.applyToRange(range);\n            }\n        };\n        ClassApplier.prototype.toggleSelection = function (win) {\n            if (this.isAppliedToSelection(win)) {\n                this.undoToSelection(win);\n            }\n            else {\n                this.applyToSelection(win);\n            }\n        };\n        ClassApplier.prototype.getElementsWithClassIntersectingRange = function (range) {\n            var elements = [];\n            var applier = this;\n            range.getNodes([3], function (textNode) {\n                var el = applier.getSelfOrAncestorWithClass(textNode);\n                if (el && !elements.includes(el)) {\n                    elements.push(el);\n                }\n            });\n            return elements;\n        };\n        ClassApplier.prototype.detach = function () { };\n        ClassApplier.util = util;\n        return ClassApplier;\n    }());\n    function createClassApplier(className, options, tagNames) {\n        return new ClassApplier(className, options, tagNames);\n    }\n\n    exports.ClassApplier = ClassApplier;\n    exports.CssClassApplier = ClassApplier;\n    exports.createClassApplier = createClassApplier;\n\n    Object.defineProperty(exports, \'__esModule\', { value: true });\n\n}));\n//# sourceMappingURL=index.umd.js.map\n\n\n//# sourceURL=webpack://sat/./node_modules/rangy-classapplier/bundles/index.umd.js?')},"./node_modules/rangy2/bundles/index.umd.js":function(__unused_webpack_module,exports){eval('(function (global, factory) {\n   true ? factory(exports) :\n  0;\n}(this, function (exports) { \'use strict\';\n\n  var fails = function (exec) {\n    try {\n      return !!exec();\n    } catch (error) {\n      return true;\n    }\n  };\n\n  var toString = {}.toString;\n\n  var classofRaw = function (it) {\n    return toString.call(it).slice(8, -1);\n  };\n\n  // fallback for non-array-like ES3 and non-enumerable old V8 strings\n\n\n  var split = \'\'.split;\n\n  var indexedObject = fails(function () {\n    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n    // eslint-disable-next-line no-prototype-builtins\n    return !Object(\'z\').propertyIsEnumerable(0);\n  }) ? function (it) {\n    return classofRaw(it) == \'String\' ? split.call(it, \'\') : Object(it);\n  } : Object;\n\n  // `RequireObjectCoercible` abstract operation\n  // https://tc39.github.io/ecma262/#sec-requireobjectcoercible\n  var requireObjectCoercible = function (it) {\n    if (it == undefined) throw TypeError("Can\'t call method on " + it);\n    return it;\n  };\n\n  // toObject with fallback for non-array-like ES3 strings\n\n\n\n  var toIndexedObject = function (it) {\n    return indexedObject(requireObjectCoercible(it));\n  };\n\n  var ceil = Math.ceil;\n  var floor = Math.floor;\n\n  // `ToInteger` abstract operation\n  // https://tc39.github.io/ecma262/#sec-tointeger\n  var toInteger = function (argument) {\n    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n  };\n\n  var min = Math.min;\n\n  // `ToLength` abstract operation\n  // https://tc39.github.io/ecma262/#sec-tolength\n  var toLength = function (argument) {\n    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n  };\n\n  var max = Math.max;\n  var min$1 = Math.min;\n\n  // Helper for a popular repeating case of the spec:\n  // Let integer be ? ToInteger(index).\n  // If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).\n  var toAbsoluteIndex = function (index, length) {\n    var integer = toInteger(index);\n    return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n  };\n\n  // `Array.prototype.{ indexOf, includes }` methods implementation\n  // false -> Array#indexOf\n  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n  // true  -> Array#includes\n  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n  var arrayIncludes = function (IS_INCLUDES) {\n    return function ($this, el, fromIndex) {\n      var O = toIndexedObject($this);\n      var length = toLength(O.length);\n      var index = toAbsoluteIndex(fromIndex, length);\n      var value;\n      // Array#includes uses SameValueZero equality algorithm\n      // eslint-disable-next-line no-self-compare\n      if (IS_INCLUDES && el != el) while (length > index) {\n        value = O[index++];\n        // eslint-disable-next-line no-self-compare\n        if (value != value) return true;\n      // Array#indexOf ignores holes, Array#includes - not\n      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n        if (O[index] === el) return IS_INCLUDES || index || 0;\n      } return !IS_INCLUDES && -1;\n    };\n  };\n\n  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n  var global = typeof window == \'object\' && window && window.Math == Math ? window\n    : typeof self == \'object\' && self && self.Math == Math ? self\n    // eslint-disable-next-line no-new-func\n    : Function(\'return this\')();\n\n  // Thank\'s IE8 for his funny defineProperty\n  var descriptors = !fails(function () {\n    return Object.defineProperty({}, \'a\', { get: function () { return 7; } }).a != 7;\n  });\n\n  var nativePropertyIsEnumerable = {}.propertyIsEnumerable;\n  var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n  // Nashorn ~ JDK8 bug\n  var NASHORN_BUG = nativeGetOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n  var f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n    var descriptor = nativeGetOwnPropertyDescriptor(this, V);\n    return !!descriptor && descriptor.enumerable;\n  } : nativePropertyIsEnumerable;\n\n  var objectPropertyIsEnumerable = {\n  \tf: f\n  };\n\n  var createPropertyDescriptor = function (bitmap, value) {\n    return {\n      enumerable: !(bitmap & 1),\n      configurable: !(bitmap & 2),\n      writable: !(bitmap & 4),\n      value: value\n    };\n  };\n\n  var isObject = function (it) {\n    return typeof it === \'object\' ? it !== null : typeof it === \'function\';\n  };\n\n  // 7.1.1 ToPrimitive(input [, PreferredType])\n\n  // instead of the ES6 spec version, we didn\'t implement @@toPrimitive case\n  // and the second argument - flag - preferred type is a string\n  var toPrimitive = function (it, S) {\n    if (!isObject(it)) return it;\n    var fn, val;\n    if (S && typeof (fn = it.toString) == \'function\' && !isObject(val = fn.call(it))) return val;\n    if (typeof (fn = it.valueOf) == \'function\' && !isObject(val = fn.call(it))) return val;\n    if (!S && typeof (fn = it.toString) == \'function\' && !isObject(val = fn.call(it))) return val;\n    throw TypeError("Can\'t convert object to primitive value");\n  };\n\n  var hasOwnProperty = {}.hasOwnProperty;\n\n  var has = function (it, key) {\n    return hasOwnProperty.call(it, key);\n  };\n\n  var document$1 = global.document;\n  // typeof document.createElement is \'object\' in old IE\n  var exist = isObject(document$1) && isObject(document$1.createElement);\n\n  var documentCreateElement = function (it) {\n    return exist ? document$1.createElement(it) : {};\n  };\n\n  // Thank\'s IE8 for his funny defineProperty\n  var ie8DomDefine = !descriptors && !fails(function () {\n    return Object.defineProperty(documentCreateElement(\'div\'), \'a\', {\n      get: function () { return 7; }\n    }).a != 7;\n  });\n\n  var nativeGetOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n  var f$1 = descriptors ? nativeGetOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n    O = toIndexedObject(O);\n    P = toPrimitive(P, true);\n    if (ie8DomDefine) try {\n      return nativeGetOwnPropertyDescriptor$1(O, P);\n    } catch (error) { /* empty */ }\n    if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);\n  };\n\n  var objectGetOwnPropertyDescriptor = {\n  \tf: f$1\n  };\n\n  var anObject = function (it) {\n    if (!isObject(it)) {\n      throw TypeError(String(it) + \' is not an object\');\n    } return it;\n  };\n\n  var nativeDefineProperty = Object.defineProperty;\n\n  var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n    anObject(O);\n    P = toPrimitive(P, true);\n    anObject(Attributes);\n    if (ie8DomDefine) try {\n      return nativeDefineProperty(O, P, Attributes);\n    } catch (error) { /* empty */ }\n    if (\'get\' in Attributes || \'set\' in Attributes) throw TypeError(\'Accessors not supported\');\n    if (\'value\' in Attributes) O[P] = Attributes.value;\n    return O;\n  };\n\n  var objectDefineProperty = {\n  \tf: f$2\n  };\n\n  var hide = descriptors ? function (object, key, value) {\n    return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n  } : function (object, key, value) {\n    object[key] = value;\n    return object;\n  };\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var setGlobal = function (key, value) {\n    try {\n      hide(global, key, value);\n    } catch (error) {\n      global[key] = value;\n    } return value;\n  };\n\n  var shared = createCommonjsModule(function (module) {\n  var SHARED = \'__core-js_shared__\';\n  var store = global[SHARED] || setGlobal(SHARED, {});\n\n  (module.exports = function (key, value) {\n    return store[key] || (store[key] = value !== undefined ? value : {});\n  })(\'versions\', []).push({\n    version: \'3.0.1\',\n    mode: \'global\',\n    copyright: \'© 2019 Denis Pushkarev (zloirock.ru)\'\n  });\n  });\n\n  var functionToString = shared(\'native-function-to-string\', Function.toString);\n\n  var WeakMap = global.WeakMap;\n\n  var nativeWeakMap = typeof WeakMap === \'function\' && /native code/.test(functionToString.call(WeakMap));\n\n  var id = 0;\n  var postfix = Math.random();\n\n  var uid = function (key) {\n    return \'Symbol(\'.concat(key === undefined ? \'\' : key, \')_\', (++id + postfix).toString(36));\n  };\n\n  var shared$1 = shared(\'keys\');\n\n\n  var sharedKey = function (key) {\n    return shared$1[key] || (shared$1[key] = uid(key));\n  };\n\n  var hiddenKeys = {};\n\n  var WeakMap$1 = global.WeakMap;\n  var set, get, has$1;\n\n  var enforce = function (it) {\n    return has$1(it) ? get(it) : set(it, {});\n  };\n\n  var getterFor = function (TYPE) {\n    return function (it) {\n      var state;\n      if (!isObject(it) || (state = get(it)).type !== TYPE) {\n        throw TypeError(\'Incompatible receiver, \' + TYPE + \' required\');\n      } return state;\n    };\n  };\n\n  if (nativeWeakMap) {\n    var store = new WeakMap$1();\n    var wmget = store.get;\n    var wmhas = store.has;\n    var wmset = store.set;\n    set = function (it, metadata) {\n      wmset.call(store, it, metadata);\n      return metadata;\n    };\n    get = function (it) {\n      return wmget.call(store, it) || {};\n    };\n    has$1 = function (it) {\n      return wmhas.call(store, it);\n    };\n  } else {\n    var STATE = sharedKey(\'state\');\n    hiddenKeys[STATE] = true;\n    set = function (it, metadata) {\n      hide(it, STATE, metadata);\n      return metadata;\n    };\n    get = function (it) {\n      return has(it, STATE) ? it[STATE] : {};\n    };\n    has$1 = function (it) {\n      return has(it, STATE);\n    };\n  }\n\n  var internalState = {\n    set: set,\n    get: get,\n    has: has$1,\n    enforce: enforce,\n    getterFor: getterFor\n  };\n\n  var redefine = createCommonjsModule(function (module) {\n  var getInternalState = internalState.get;\n  var enforceInternalState = internalState.enforce;\n  var TEMPLATE = String(functionToString).split(\'toString\');\n\n  shared(\'inspectSource\', function (it) {\n    return functionToString.call(it);\n  });\n\n  (module.exports = function (O, key, value, options) {\n    var unsafe = options ? !!options.unsafe : false;\n    var simple = options ? !!options.enumerable : false;\n    var noTargetGet = options ? !!options.noTargetGet : false;\n    if (typeof value == \'function\') {\n      if (typeof key == \'string\' && !has(value, \'name\')) hide(value, \'name\', key);\n      enforceInternalState(value).source = TEMPLATE.join(typeof key == \'string\' ? key : \'\');\n    }\n    if (O === global) {\n      if (simple) O[key] = value;\n      else setGlobal(key, value);\n      return;\n    } else if (!unsafe) {\n      delete O[key];\n    } else if (!noTargetGet && O[key]) {\n      simple = true;\n    }\n    if (simple) O[key] = value;\n    else hide(O, key, value);\n  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n  })(Function.prototype, \'toString\', function toString() {\n    return typeof this == \'function\' && getInternalState(this).source || functionToString.call(this);\n  });\n  });\n\n  var arrayIndexOf = arrayIncludes(false);\n\n\n  var objectKeysInternal = function (object, names) {\n    var O = toIndexedObject(object);\n    var i = 0;\n    var result = [];\n    var key;\n    for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n    // Don\'t enum bug & hidden keys\n    while (names.length > i) if (has(O, key = names[i++])) {\n      ~arrayIndexOf(result, key) || result.push(key);\n    }\n    return result;\n  };\n\n  // IE8- don\'t enum bug keys\n  var enumBugKeys = [\n    \'constructor\',\n    \'hasOwnProperty\',\n    \'isPrototypeOf\',\n    \'propertyIsEnumerable\',\n    \'toLocaleString\',\n    \'toString\',\n    \'valueOf\'\n  ];\n\n  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n\n  var hiddenKeys$1 = enumBugKeys.concat(\'length\', \'prototype\');\n\n  var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n    return objectKeysInternal(O, hiddenKeys$1);\n  };\n\n  var objectGetOwnPropertyNames = {\n  \tf: f$3\n  };\n\n  var f$4 = Object.getOwnPropertySymbols;\n\n  var objectGetOwnPropertySymbols = {\n  \tf: f$4\n  };\n\n  var Reflect = global.Reflect;\n\n  // all object keys, includes non-enumerable and symbols\n  var ownKeys = Reflect && Reflect.ownKeys || function ownKeys(it) {\n    var keys = objectGetOwnPropertyNames.f(anObject(it));\n    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n  };\n\n  var copyConstructorProperties = function (target, source) {\n    var keys = ownKeys(source);\n    var defineProperty = objectDefineProperty.f;\n    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  };\n\n  var replacement = /#|\\.prototype\\./;\n\n  var isForced = function (feature, detection) {\n    var value = data[normalize(feature)];\n    return value == POLYFILL ? true\n      : value == NATIVE ? false\n      : typeof detection == \'function\' ? fails(detection)\n      : !!detection;\n  };\n\n  var normalize = isForced.normalize = function (string) {\n    return String(string).replace(replacement, \'.\').toLowerCase();\n  };\n\n  var data = isForced.data = {};\n  var NATIVE = isForced.NATIVE = \'N\';\n  var POLYFILL = isForced.POLYFILL = \'P\';\n\n  var isForced_1 = isForced;\n\n  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n  /*\n    options.target      - name of the target object\n    options.global      - target is the global object\n    options.stat        - export as static methods of target\n    options.proto       - export as prototype methods of target\n    options.real        - real prototype method for the `pure` version\n    options.forced      - export even if the native feature is available\n    options.bind        - bind methods to the target, required for the `pure` version\n    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n    options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n    options.sham        - add a flag to not completely full polyfills\n    options.enumerable  - export as enumerable property\n    options.noTargetGet - prevent calling a getter on target\n  */\n  var _export = function (options, source) {\n    var TARGET = options.target;\n    var GLOBAL = options.global;\n    var STATIC = options.stat;\n    var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n    if (GLOBAL) {\n      target = global;\n    } else if (STATIC) {\n      target = global[TARGET] || setGlobal(TARGET, {});\n    } else {\n      target = (global[TARGET] || {}).prototype;\n    }\n    if (target) for (key in source) {\n      sourceProperty = source[key];\n      if (options.noTargetGet) {\n        descriptor = getOwnPropertyDescriptor(target, key);\n        targetProperty = descriptor && descriptor.value;\n      } else targetProperty = target[key];\n      FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? \'.\' : \'#\') + key, options.forced);\n      // contained in target\n      if (!FORCED && targetProperty !== undefined) {\n        if (typeof sourceProperty === typeof targetProperty) continue;\n        copyConstructorProperties(sourceProperty, targetProperty);\n      }\n      // add a flag to not completely full polyfills\n      if (options.sham || (targetProperty && targetProperty.sham)) {\n        hide(sourceProperty, \'sham\', true);\n      }\n      // extend global\n      redefine(target, key, sourceProperty, options);\n    }\n  };\n\n  // Chrome 38 Symbol has incorrect toString conversion\n  var nativeSymbol = !fails(function () {\n    // eslint-disable-next-line no-undef\n    return !String(Symbol());\n  });\n\n  var store$1 = shared(\'wks\');\n\n  var Symbol$1 = global.Symbol;\n\n\n  var wellKnownSymbol = function (name) {\n    return store$1[name] || (store$1[name] = nativeSymbol && Symbol$1[name]\n      || (nativeSymbol ? Symbol$1 : uid)(\'Symbol.\' + name));\n  };\n\n  // 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\n\n\n  var objectKeys = Object.keys || function keys(O) {\n    return objectKeysInternal(O, enumBugKeys);\n  };\n\n  var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n    anObject(O);\n    var keys = objectKeys(Properties);\n    var length = keys.length;\n    var i = 0;\n    var key;\n    while (length > i) objectDefineProperty.f(O, key = keys[i++], Properties[key]);\n    return O;\n  };\n\n  var document$2 = global.document;\n\n  var html = document$2 && document$2.documentElement;\n\n  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\n\n\n\n\n  var IE_PROTO = sharedKey(\'IE_PROTO\');\n  var PROTOTYPE = \'prototype\';\n  var Empty = function () { /* empty */ };\n\n  // Create object with fake `null` prototype: use iframe Object with cleared prototype\n  var createDict = function () {\n    // Thrash, waste and sodomy: IE GC bug\n    var iframe = documentCreateElement(\'iframe\');\n    var length = enumBugKeys.length;\n    var lt = \'<\';\n    var script = \'script\';\n    var gt = \'>\';\n    var js = \'java\' + script + \':\';\n    var iframeDocument;\n    iframe.style.display = \'none\';\n    html.appendChild(iframe);\n    iframe.src = String(js);\n    iframeDocument = iframe.contentWindow.document;\n    iframeDocument.open();\n    iframeDocument.write(lt + script + gt + \'document.F=Object\' + lt + \'/\' + script + gt);\n    iframeDocument.close();\n    createDict = iframeDocument.F;\n    while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];\n    return createDict();\n  };\n\n  var objectCreate = Object.create || function create(O, Properties) {\n    var result;\n    if (O !== null) {\n      Empty[PROTOTYPE] = anObject(O);\n      result = new Empty();\n      Empty[PROTOTYPE] = null;\n      // add "__proto__" for Object.getPrototypeOf polyfill\n      result[IE_PROTO] = O;\n    } else result = createDict();\n    return Properties === undefined ? result : objectDefineProperties(result, Properties);\n  };\n\n  hiddenKeys[IE_PROTO] = true;\n\n  var UNSCOPABLES = wellKnownSymbol(\'unscopables\');\n\n\n  var ArrayPrototype = Array.prototype;\n\n  // Array.prototype[@@unscopables]\n  // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n  if (ArrayPrototype[UNSCOPABLES] == undefined) {\n    hide(ArrayPrototype, UNSCOPABLES, objectCreate(null));\n  }\n\n  // add a key to Array.prototype[@@unscopables]\n  var addToUnscopables = function (key) {\n    ArrayPrototype[UNSCOPABLES][key] = true;\n  };\n\n  var internalIncludes = arrayIncludes(true);\n\n  // `Array.prototype.includes` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n  _export({ target: \'Array\', proto: true }, {\n    includes: function includes(el /* , fromIndex = 0 */) {\n      return internalIncludes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n    }\n  });\n\n  // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n  addToUnscopables(\'includes\');\n\n  var aFunction = function (it) {\n    if (typeof it != \'function\') {\n      throw TypeError(String(it) + \' is not a function\');\n    } return it;\n  };\n\n  // optional / simple context binding\n  var bindContext = function (fn, that, length) {\n    aFunction(fn);\n    if (that === undefined) return fn;\n    switch (length) {\n      case 0: return function () {\n        return fn.call(that);\n      };\n      case 1: return function (a) {\n        return fn.call(that, a);\n      };\n      case 2: return function (a, b) {\n        return fn.call(that, a, b);\n      };\n      case 3: return function (a, b, c) {\n        return fn.call(that, a, b, c);\n      };\n    }\n    return function (/* ...args */) {\n      return fn.apply(that, arguments);\n    };\n  };\n\n  var call = Function.call;\n\n  var entryUnbind = function (CONSTRUCTOR, METHOD, length) {\n    return bindContext(call, global[CONSTRUCTOR].prototype[METHOD], length);\n  };\n\n  var includes = entryUnbind(\'Array\', \'includes\');\n\n  // `ToObject` abstract operation\n  // https://tc39.github.io/ecma262/#sec-toobject\n  var toObject = function (argument) {\n    return Object(requireObjectCoercible(argument));\n  };\n\n  // 19.1.2.1 Object.assign(target, source, ...)\n\n\n\n\n\n  var nativeAssign = Object.assign;\n\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var objectAssign = !nativeAssign || fails(function () {\n    var A = {};\n    var B = {};\n    // eslint-disable-next-line no-undef\n    var symbol = Symbol();\n    var alphabet = \'abcdefghijklmnopqrst\';\n    A[symbol] = 7;\n    alphabet.split(\'\').forEach(function (chr) { B[chr] = chr; });\n    return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join(\'\') != alphabet;\n  }) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n    var T = toObject(target);\n    var argumentsLength = arguments.length;\n    var index = 1;\n    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n    var propertyIsEnumerable = objectPropertyIsEnumerable.f;\n    while (argumentsLength > index) {\n      var S = indexedObject(arguments[index++]);\n      var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n      var length = keys.length;\n      var j = 0;\n      var key;\n      while (length > j) if (propertyIsEnumerable.call(S, key = keys[j++])) T[key] = S[key];\n    } return T;\n  } : nativeAssign;\n\n  // `Object.assign` method\n  // https://tc39.github.io/ecma262/#sec-object.assign\n  _export({ target: \'Object\', stat: true, forced: Object.assign !== objectAssign }, { assign: objectAssign });\n\n  var path = global;\n\n  var assign = path.Object.assign;\n\n  var UNDEF = "undefined";\n  var version = "2.1.0";\n  var isBrowser = typeof window != UNDEF && typeof document != UNDEF;\n  if (!isBrowser) {\n      console.log("Rangy can only run in a browser");\n  }\n  var features = {\n      implementsDomRange: true,\n      implementsTextRange: false,\n      htmlParsingConforms: true,\n      crashyTextNodes: false,\n      implementsWinGetSelection: true,\n      implementsDocSelection: false,\n      selectionSupportsMultipleRanges: false,\n      implementsControlRange: false,\n  };\n  /** @deprecated all configs is const! */\n  var config = {\n      preferTextRange: false,\n      checkSelectionRanges: true,\n  };\n  // RangePrototype,\n  // rangePrototype: new RangePrototype(),\n  // selectionPrototype: new SelectionPrototype(),\n  function onDocReady(listener) {\n      if (!isBrowser)\n          return;\n      if (document.readyState == "complete") {\n          listener();\n      }\n      else {\n          var onLoaded_1 = function () {\n              document.removeEventListener("DOMContentLoaded", onLoaded_1, false);\n              listener();\n          };\n          document.addEventListener("DOMContentLoaded", onLoaded_1, false);\n      }\n  }\n\n  // Trio of functions taken from Peter Michaux\'s article:\n  // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n  function isHostMethod(o, p) {\n      var t = typeof o[p];\n      return t == "function" || (!!(t == "object" && o[p])) || t == "unknown";\n  }\n  function isHostObject(o, p) {\n      return !!(typeof o[p] == "object" && o[p]);\n  }\n  function isHostProperty(o, p) {\n      return typeof o[p] != "undefined";\n  }\n  // Creates a convenience function to save verbose repeated calls to tests functions\n  function createMultiplePropertyTest(testFunc) {\n      return function (o, props) {\n          var i = props.length;\n          while (i--) {\n              if (!testFunc(o, props[i])) {\n                  return false;\n              }\n          }\n          return true;\n      };\n  }\n  // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n  var areHostMethods = createMultiplePropertyTest(isHostMethod);\n  var areHostObjects = createMultiplePropertyTest(isHostObject);\n  var areHostProperties = createMultiplePropertyTest(isHostProperty);\n  function getBody(doc) {\n      return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];\n  }\n\n  var util = /*#__PURE__*/Object.freeze({\n    isHostMethod: isHostMethod,\n    isHostObject: isHostObject,\n    isHostProperty: isHostProperty,\n    areHostMethods: areHostMethods,\n    areHostObjects: areHostObjects,\n    areHostProperties: areHostProperties,\n    getBody: getBody\n  });\n\n  var Module = /** @class */ (function () {\n      function Module(name, dependencies) {\n          this.name = name;\n          this.dependencies = dependencies;\n      }\n      Module.prototype.fail = function (reason) {\n          console.log("Module \'" + this.name + "\' failed to load: " + reason);\n          throw new Error(reason);\n      };\n      Module.prototype.warn = function (msg) {\n          console.log("Module " + this.name + ": " + msg);\n      };\n      Module.prototype.createError = function (msg) {\n          return new Error("Error in Rangy " + this.name + " module: " + msg);\n      };\n      return Module;\n  }());\n\n  function DOMException(codeName) {\n      this.code = this[codeName];\n      this.codeName = codeName;\n      this.message = "DOMException: " + this.codeName;\n  }\n  DOMException.prototype = {\n      INDEX_SIZE_ERR: 1,\n      HIERARCHY_REQUEST_ERR: 3,\n      WRONG_DOCUMENT_ERR: 4,\n      NO_MODIFICATION_ALLOWED_ERR: 7,\n      NOT_FOUND_ERR: 8,\n      NOT_SUPPORTED_ERR: 9,\n      INVALID_STATE_ERR: 11,\n      INVALID_NODE_TYPE_ERR: 24,\n  };\n  //Object.assign(DOMException, DOMException.prototype);\n  DOMException.prototype.toString = function () {\n      return this.message;\n  };\n\n  var module = new Module("DomUtil", []);\n  // DOM utility methods used by Rangy\n  // /* build:replaceWith(api) */rangy/* build:replaceEnd */.createCoreModule("DomUtil", [], function(api, module) {\n\n  var UNDEF$1 = "undefined";\n  // Perform feature tests\n  if (!areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {\n      module.fail("document missing a Node creation method");\n  }\n  if (!isHostMethod(document, "getElementsByTagName")) {\n      module.fail("document missing getElementsByTagName method");\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n  function isHtmlNamespace(node) {\n      var ns;\n      return typeof node.namespaceURI == UNDEF$1 || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");\n  }\n  function parentElement(node) {\n      var parent = node.parentNode;\n      return (parent.nodeType == 1) ? parent : null;\n  }\n  function getNodeIndex(node) {\n      var i = 0;\n      while ((node = node.previousSibling)) {\n          ++i;\n      }\n      return i;\n  }\n  function getNodeLength(node) {\n      switch (node.nodeType) {\n          case 7:\n          case 10:\n              return 0;\n          case 3:\n          case 8:\n              return node.length;\n          default:\n              return node.childNodes.length;\n      }\n  }\n  function getCommonAncestor(node1, node2) {\n      var ancestors = [], n;\n      for (n = node1; n; n = n.parentNode) {\n          ancestors.push(n);\n      }\n      for (n = node2; n; n = n.parentNode) {\n          if (ancestors.includes(n)) {\n              return n;\n          }\n      }\n      return null;\n  }\n  function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n      var n = selfIsAncestor ? descendant : descendant.parentNode;\n      while (n) {\n          if (n === ancestor) {\n              return true;\n          }\n          else {\n              n = n.parentNode;\n          }\n      }\n      return false;\n  }\n  function isOrIsAncestorOf(ancestor, descendant) {\n      return isAncestorOf(ancestor, descendant, true);\n  }\n  function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n      var p, n = selfIsAncestor ? node : node.parentNode;\n      while (n) {\n          p = n.parentNode;\n          if (p === ancestor) {\n              return n;\n          }\n          n = p;\n      }\n      return null;\n  }\n  // https://basarat.gitbooks.io/typescript/docs/types/typeGuard.html#user-defined-type-guards\n  function isCharacterDataNode(node) {\n      var t = node.nodeType;\n      return t == 3 || t == 4 || t == 8; // Text, CDataSection or Comment\n  }\n  function isTextOrCommentNode(node) {\n      if (!node) {\n          return false;\n      }\n      var t = node.nodeType;\n      return t == 3 || t == 8; // Text or Comment\n  }\n  function insertAfter(node, precedingNode) {\n      var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;\n      if (nextNode) {\n          parent.insertBefore(node, nextNode);\n      }\n      else {\n          parent.appendChild(node);\n      }\n      return node;\n  }\n  // Note that we cannot use splitText() because it is bugridden in IE 9.\n  function splitDataNode(node, index, positionsToPreserve) {\n      var newNode = node.cloneNode(false);\n      newNode.deleteData(0, index);\n      node.deleteData(index, node.length - index);\n      insertAfter(newNode, node);\n      // Preserve positions\n      if (positionsToPreserve) {\n          for (var i = 0, position; position = positionsToPreserve[i++];) {\n              // Handle case where position was inside the portion of node after the split point\n              if (position.node == node && position.offset > index) {\n                  position.node = newNode;\n                  position.offset -= index;\n              }\n              // Handle the case where the position is a node offset within node\'s parent\n              else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {\n                  ++position.offset;\n              }\n          }\n      }\n      return newNode;\n  }\n  function getDocument(node) {\n      if (node.nodeType == 9) {\n          return node;\n      }\n      else if (typeof node.ownerDocument != UNDEF$1) {\n          return node.ownerDocument;\n      }\n      else if (typeof node.document != UNDEF$1) {\n          return node.document;\n      }\n      else if (node.parentNode) {\n          return getDocument(node.parentNode);\n      }\n      else {\n          throw module.createError("getDocument: no document found for node");\n      }\n  }\n  function getWindow(node) {\n      var doc = getDocument(node);\n      if (typeof doc.defaultView != UNDEF$1) {\n          return doc.defaultView;\n      }\n      else if (typeof doc.parentWindow != UNDEF$1) {\n          return doc.parentWindow;\n      }\n      else {\n          throw module.createError("Cannot get a window object for node");\n      }\n  }\n  function getIframeDocument(iframeEl) {\n      if (typeof iframeEl.contentDocument != UNDEF$1) {\n          return iframeEl.contentDocument;\n      }\n      else if (typeof iframeEl.contentWindow != UNDEF$1) {\n          return iframeEl.contentWindow.document;\n      }\n      else {\n          throw module.createError("getIframeDocument: No Document object found for iframe element");\n      }\n  }\n  function getIframeWindow(iframeEl) {\n      if (typeof iframeEl.contentWindow != UNDEF$1) {\n          return iframeEl.contentWindow;\n      }\n      else if (typeof iframeEl.contentDocument != UNDEF$1) {\n          return iframeEl.contentDocument.defaultView;\n      }\n      else {\n          throw module.createError("getIframeWindow: No Window object found for iframe element");\n      }\n  }\n  // This looks bad. Is it worth it?\n  function isWindow(obj) {\n      return obj && isHostMethod(obj, "setTimeout") && isHostObject(obj, "document");\n  }\n  function isIframe(o) {\n      return o.nodeType == 1 && o.tagName.toLowerCase() == "iframe";\n  }\n  function getContentDocument(obj, module, methodName) {\n      var doc;\n      if (!obj) {\n          doc = document;\n      }\n      // Test if a DOM node has been passed and obtain a document object for it if so\n      else if (isHostProperty(obj, "nodeType")) {\n          doc = isIframe(obj) ? getIframeDocument(obj) : getDocument(obj);\n      }\n      // Test if the doc parameter appears to be a Window object\n      else if (isWindow(obj)) {\n          doc = obj.document;\n      }\n      if (!doc) {\n          throw module.createError(methodName + "(): Parameter must be a Window object or DOM node");\n      }\n      return doc;\n  }\n  function getRootContainer(node) {\n      var parent;\n      while ((parent = node.parentNode)) {\n          node = parent;\n      }\n      return node;\n  }\n  function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n      // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n      var nodeC, root, childA, childB, n;\n      if (nodeA == nodeB) {\n          // Case 1: nodes are the same\n          return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;\n      }\n      else if ((nodeC = getClosestAncestorIn(nodeB, nodeA, true))) {\n          // Case 2: node C (container B or an ancestor) is a child node of A\n          return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n      }\n      else if ((nodeC = getClosestAncestorIn(nodeA, nodeB, true))) {\n          // Case 3: node C (container A or an ancestor) is a child node of B\n          return getNodeIndex(nodeC) < offsetB ? -1 : 1;\n      }\n      else {\n          root = getCommonAncestor(nodeA, nodeB);\n          if (!root) {\n              throw new Error("comparePoints error: nodes have no common ancestor");\n          }\n          // Case 4: containers are siblings or descendants of siblings\n          childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);\n          childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);\n          if (childA === childB) {\n              // This shouldn\'t be possible\n              throw module.createError("comparePoints got to case 4 and childA and childB are the same!");\n          }\n          else {\n              n = root.firstChild;\n              while (n) {\n                  if (n === childA) {\n                      return -1;\n                  }\n                  else if (n === childB) {\n                      return 1;\n                  }\n                  n = n.nextSibling;\n              }\n          }\n      }\n  }\n  function inspectNode(node) {\n      if (!node) {\n          return "[No node]";\n      }\n      if (isCharacterDataNode(node)) {\n          return \'"\' + node.data + \'"\';\n      }\n      if (node.nodeType == 1) {\n          var idAttr = node.id ? \' id="\' + node.id + \'"\' : "";\n          return "<" + node.nodeName + idAttr +\n              ">[index:" + getNodeIndex(node) +\n              ",length:" + node.childNodes.length + "][" +\n              (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";\n      }\n      return node.nodeName;\n  }\n  function fragmentFromNodeChildren(node) {\n      var fragment = getDocument(node).createDocumentFragment(), child;\n      while ((child = node.firstChild)) {\n          fragment.appendChild(child);\n      }\n      return fragment;\n  }\n  var _getComputedStyleProperty;\n  if (typeof window.getComputedStyle != UNDEF$1) {\n      _getComputedStyleProperty = function (el, propName) {\n          return getWindow(el).getComputedStyle(el, null)[propName];\n      };\n  }\n  else if (typeof document.documentElement.currentStyle != UNDEF$1) {\n      _getComputedStyleProperty = function (el, propName) {\n          return el.currentStyle ? el.currentStyle[propName] : "";\n      };\n  }\n  else {\n      module.fail("No means of obtaining computed style properties found");\n  }\n  var getComputedStyleProperty = _getComputedStyleProperty;\n  function createTestElement(doc, html, contentEditable) {\n      var body = getBody(doc);\n      var el = doc.createElement("div");\n      el.contentEditable = "" + !!contentEditable;\n      if (html) {\n          el.innerHTML = html;\n      }\n      // Insert the test element at the start of the body to prevent scrolling to the bottom in iOS (issue #292)\n      var bodyFirstChild = body.firstChild;\n      if (bodyFirstChild) {\n          body.insertBefore(el, bodyFirstChild);\n      }\n      else {\n          body.appendChild(el);\n      }\n      return el;\n  }\n  function removeNode(node) {\n      return node.parentNode.removeChild(node);\n  }\n  var NodeIterator = /** @class */ (function () {\n      function NodeIterator(root) {\n          this.root = root;\n          this._next = root;\n      }\n      NodeIterator.prototype.hasNext = function () {\n          return !!this._next;\n      };\n      NodeIterator.prototype.next = function () {\n          var n = NodeIterator._current = this._next;\n          var child, next;\n          if (NodeIterator._current) {\n              child = n.firstChild;\n              if (child) {\n                  this._next = child;\n              }\n              else {\n                  next = null;\n                  while ((n !== this.root) && !(next = n.nextSibling)) {\n                      n = n.parentNode;\n                  }\n                  this._next = next;\n              }\n          }\n          return NodeIterator._current;\n      };\n      NodeIterator.prototype.detach = function () {\n          NodeIterator._current = this._next = this.root = null;\n      };\n      NodeIterator._current = null;\n      return NodeIterator;\n  }());\n  function createIterator(root) {\n      return new NodeIterator(root);\n  }\n  var DomPosition = /** @class */ (function () {\n      function DomPosition(node, offset) {\n          this.node = node;\n          this.offset = offset;\n      }\n      DomPosition.prototype.equals = function (pos) {\n          return !!pos && this.node === pos.node && this.offset == pos.offset;\n      };\n      DomPosition.prototype.inspect = function () {\n          return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";\n      };\n      DomPosition.prototype.toString = function () {\n          return this.inspect();\n      };\n      return DomPosition;\n  }());\n\n  var dom = /*#__PURE__*/Object.freeze({\n    getBody: getBody,\n    isHtmlNamespace: isHtmlNamespace,\n    parentElement: parentElement,\n    getNodeIndex: getNodeIndex,\n    getNodeLength: getNodeLength,\n    getCommonAncestor: getCommonAncestor,\n    isAncestorOf: isAncestorOf,\n    isOrIsAncestorOf: isOrIsAncestorOf,\n    getClosestAncestorIn: getClosestAncestorIn,\n    isCharacterDataNode: isCharacterDataNode,\n    isTextOrCommentNode: isTextOrCommentNode,\n    insertAfter: insertAfter,\n    splitDataNode: splitDataNode,\n    getDocument: getDocument,\n    getWindow: getWindow,\n    getIframeDocument: getIframeDocument,\n    getIframeWindow: getIframeWindow,\n    isWindow: isWindow,\n    getContentDocument: getContentDocument,\n    getRootContainer: getRootContainer,\n    comparePoints: comparePoints,\n    inspectNode: inspectNode,\n    fragmentFromNodeChildren: fragmentFromNodeChildren,\n    getComputedStyleProperty: getComputedStyleProperty,\n    createTestElement: createTestElement,\n    removeNode: removeNode,\n    NodeIterator: NodeIterator,\n    createIterator: createIterator,\n    DomPosition: DomPosition\n  });\n\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the "License"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n  See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\r\n  /* global Reflect, Promise */\r\n\r\n  var extendStatics = function(d, b) {\r\n      extendStatics = Object.setPrototypeOf ||\r\n          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n          function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n      return extendStatics(d, b);\r\n  };\r\n\r\n  function __extends(d, b) {\r\n      extendStatics(d, b);\r\n      function __() { this.constructor = d; }\r\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n  }\n\n  function isNonTextPartiallySelected(node, range) {\n      return (node.nodeType != 3) &&\n          (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n  var rootContainerNodeTypes = [2, 9, 11];\n  var readonlyNodeTypes = [5, 6, 10, 12];\n  var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n  var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n  function createAncestorFinder(nodeTypes) {\n      return function (node, selfIsAncestor) {\n          var t, n = selfIsAncestor ? node : node.parentNode;\n          while (n) {\n              t = n.nodeType;\n              if (nodeTypes.includes(t)) {\n                  return n;\n              }\n              n = n.parentNode;\n          }\n          return null;\n      };\n  }\n  var getDocumentOrFragmentContainer = createAncestorFinder([9, 11]);\n  var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n  var getDocTypeNotationEntityAncestor = createAncestorFinder([6, 10, 12]);\n  var getElementAncestor = createAncestorFinder([1]);\n  function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n      if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n          throw new DOMException("INVALID_NODE_TYPE_ERR");\n      }\n  }\n  function assertValidNodeType(node, invalidTypes) {\n      if (!invalidTypes.includes(node.nodeType)) {\n          throw new DOMException("INVALID_NODE_TYPE_ERR");\n      }\n  }\n  function assertValidOffset(node, offset) {\n      if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n          throw new DOMException("INDEX_SIZE_ERR");\n      }\n  }\n  function assertSameDocumentOrFragment(node1, node2) {\n      if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n          throw new DOMException("WRONG_DOCUMENT_ERR");\n      }\n  }\n  function assertNodeNotReadOnly(node) {\n      if (getReadonlyAncestor(node, true)) {\n          throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");\n      }\n  }\n  function assertNode(node, codeName) {\n      if (!node) {\n          throw new DOMException(codeName);\n      }\n  }\n  function isValidOffset(node, offset) {\n      return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);\n  }\n  function isRangeValid(range) {\n      return (!!range.startContainer && !!range.endContainer &&\n          getRootContainer(range.startContainer) == getRootContainer(range.endContainer) &&\n          isValidOffset(range.startContainer, range.startOffset) &&\n          isValidOffset(range.endContainer, range.endOffset));\n  }\n  function assertRangeValid(range) {\n      if (!isRangeValid(range)) {\n          throw new Error("Range error: Range is not valid. This usually happens after DOM mutation. Range: (" + range.inspect() + ")");\n      }\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  function getRangeDocument(range) {\n      return range.document || getDocument(range.startContainer);\n  }\n  // Updates commonAncestorContainer and collapsed after boundary change\n  function updateCollapsedAndCommonAncestor(range) {\n      range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n      range.commonAncestorContainer = range.collapsed ?\n          range.startContainer : getCommonAncestor(range.startContainer, range.endContainer);\n  }\n  function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n      range.startContainer = startContainer;\n      range.startOffset = startOffset;\n      range.endContainer = endContainer;\n      range.endOffset = endOffset;\n      range.document = getDocument(startContainer);\n      updateCollapsedAndCommonAncestor(range);\n  }\n  var rangeProperties = [\n      "startContainer",\n      "startOffset",\n      "endContainer",\n      "endOffset",\n      "collapsed",\n      "commonAncestorContainer"\n  ];\n  // note RangeBase\'s method list == const rangeProperties above\n  var RangeBase = /** @class */ (function () {\n      function RangeBase() {\n      }\n      return RangeBase;\n  }());\n  var DomRangeBase = /** @class */ (function (_super) {\n      __extends(DomRangeBase, _super);\n      function DomRangeBase(doc) {\n          var _this = _super.call(this) || this;\n          updateBoundaries(_this, doc, 0, doc, 0);\n          return _this;\n      }\n      return DomRangeBase;\n  }(RangeBase));\n\n  // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n\n  var RangeIterator = /** @class */ (function () {\n      function RangeIterator(range, clonePartiallySelectedTextNodes) {\n          this.range = range;\n          this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n          // TODO the following properties are migrated from RangeIterator.prototype\n          // now, those are in RangeIterator\'s instance\n          // so we can remove `detach` method\n          this._current = null;\n          this._next = null;\n          this._first = null;\n          this._last = null;\n          this.isSingleCharacterDataNode = false;\n          if (!range.collapsed) {\n              this.sc = range.startContainer;\n              this.so = range.startOffset;\n              this.ec = range.endContainer;\n              this.eo = range.endOffset;\n              var root = range.commonAncestorContainer;\n              if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n                  this.isSingleCharacterDataNode = true;\n                  this._first = this._last = this._next = this.sc;\n              }\n              else {\n                  this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?\n                      this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);\n                  this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?\n                      this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);\n              }\n          }\n      }\n      RangeIterator.prototype.reset = function () {\n          this._current = null;\n          this._next = this._first;\n      };\n      RangeIterator.prototype.hasNext = function () {\n          return !!this._next;\n      };\n      RangeIterator.prototype.detach = function () {\n          this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n      };\n      RangeIterator.prototype.next = function () {\n          // Move to next node\n          var current = this._current = this._next;\n          if (current) {\n              this._next = (current !== this._last) ? current.nextSibling : null;\n              // Check for partially selected text nodes\n              if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n                  if (current === this.ec) {\n                      current = current.cloneNode(true);\n                      current.deleteData(this.eo, current.length - this.eo);\n                  }\n                  if (this._current === this.sc) {\n                      current = current.cloneNode(true);\n                      current.deleteData(0, this.so);\n                  }\n              }\n          }\n          return current;\n      };\n      RangeIterator.prototype.remove = function () {\n          var current = this._current, start, end;\n          if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n              start = (current === this.sc) ? this.so : 0;\n              end = (current === this.ec) ? this.eo : current.length;\n              if (start != end) {\n                  current.deleteData(start, end - start);\n              }\n          }\n          else {\n              if (current.parentNode) {\n                  removeNode(current);\n              }\n          }\n      };\n      // Checks if the current node is partially selected\n      RangeIterator.prototype.isPartiallySelectedSubtree = function () {\n          var current = this._current;\n          return isNonTextPartiallySelected(current, this.range);\n      };\n      RangeIterator.prototype.getSubtreeIterator = function () {\n          var subRange;\n          if (this.isSingleCharacterDataNode) {\n              subRange = this.range.cloneRange();\n              subRange.collapse(false);\n          }\n          else {\n              subRange = new DomRange(getRangeDocument(this.range));\n              var current = this._current;\n              var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n              if (isOrIsAncestorOf(current, this.sc)) {\n                  startContainer = this.sc;\n                  startOffset = this.so;\n              }\n              if (isOrIsAncestorOf(current, this.ec)) {\n                  endContainer = this.ec;\n                  endOffset = this.eo;\n              }\n              updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n          }\n          return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n      };\n      return RangeIterator;\n  }()); // RangeIterator\n  function cloneSubtree(iterator) {\n      var partiallySelected;\n      for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n          partiallySelected = iterator.isPartiallySelectedSubtree();\n          node = node.cloneNode(!partiallySelected);\n          if (partiallySelected) {\n              subIterator = iterator.getSubtreeIterator();\n              node.appendChild(cloneSubtree(subIterator));\n              subIterator.detach();\n          }\n          if (node.nodeType == 10) { // DocumentType\n              throw new DOMException("HIERARCHY_REQUEST_ERR");\n          }\n          frag.appendChild(node);\n      }\n      return frag;\n  }\n  function iterateSubtree(iterator, func, iteratorState) {\n      if (iteratorState === void 0) { iteratorState = { stop: false }; }\n      var it, n;\n      for (var node, subIterator; node = iterator.next();) {\n          if (iterator.isPartiallySelectedSubtree()) {\n              if (func(node) === false) {\n                  iteratorState.stop = true;\n                  return;\n              }\n              else {\n                  // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of\n                  // the node selected by the Range.\n                  subIterator = iterator.getSubtreeIterator();\n                  iterateSubtree(subIterator, func, iteratorState);\n                  subIterator.detach();\n                  if (iteratorState.stop) {\n                      return;\n                  }\n              }\n          }\n          else {\n              // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n              // descendants\n              it = createIterator(node);\n              while ((n = it.next())) {\n                  if (func(n) === false) {\n                      iteratorState.stop = true;\n                      return;\n                  }\n              }\n          }\n      }\n  }\n  function deleteSubtree(iterator) {\n      var subIterator;\n      while (iterator.next()) {\n          if (iterator.isPartiallySelectedSubtree()) {\n              subIterator = iterator.getSubtreeIterator();\n              deleteSubtree(subIterator);\n              subIterator.detach();\n          }\n          else {\n              iterator.remove();\n          }\n      }\n  }\n  function extractSubtree(iterator) {\n      for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n          if (iterator.isPartiallySelectedSubtree()) {\n              node = node.cloneNode(false);\n              subIterator = iterator.getSubtreeIterator();\n              node.appendChild(extractSubtree(subIterator));\n              subIterator.detach();\n          }\n          else {\n              iterator.remove();\n          }\n          if (node.nodeType == 10) { // DocumentType\n              throw new DOMException("HIERARCHY_REQUEST_ERR");\n          }\n          frag.appendChild(node);\n      }\n      return frag;\n  }\n\n  function getRangeRoot(range) {\n      return getRootContainer(range.startContainer);\n  }\n  function insertNodeAtPosition(node, n, o) {\n      var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n      if (isCharacterDataNode(n)) {\n          if (o == n.length) {\n              insertAfter(node, n);\n          }\n          else {\n              n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));\n          }\n      }\n      else if (o >= n.childNodes.length) {\n          n.appendChild(node);\n      }\n      else {\n          n.insertBefore(node, n.childNodes[o]);\n      }\n      return firstNodeInserted;\n  }\n  function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {\n      assertRangeValid(rangeA);\n      assertRangeValid(rangeB);\n      if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {\n          throw new DOMException("WRONG_DOCUMENT_ERR");\n      }\n      var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset), endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n  }\n  function getNodesInRange(range, nodeTypes, filter) {\n      var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;\n      var filterExists = !!filter;\n      if (filterNodeTypes) {\n          regex = new RegExp("^(" + nodeTypes.join("|") + ")$");\n      }\n      var nodes = [];\n      iterateSubtree(new RangeIterator(range, false), function (node) {\n          if (filterNodeTypes && !regex.test(node.nodeType.toString())) {\n              return;\n          }\n          if (filterExists && !filter(node)) {\n              return;\n          }\n          // Don\'t include a boundary container if it is a character data node and the range does not contain any\n          // of its character data. See issue 190.\n          var sc = range.startContainer;\n          if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {\n              return;\n          }\n          var ec = range.endContainer;\n          if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {\n              return;\n          }\n          nodes.push(node);\n      });\n      return nodes;\n  }\n  function rangeInspect(range) {\n      var name = (typeof range.getName == "undefined") ? "Range" : range.getName();\n      return "[" + name + "(" + inspectNode(range.startContainer) + ":" + range.startOffset + ", " +\n          inspectNode(range.endContainer) + ":" + range.endOffset + ")]";\n  }\n  function rangeToHtml(range) {\n      assertRangeValid(range);\n      var container = range.commonAncestorContainer.parentNode.cloneNode(false);\n      container.appendChild(range.cloneContents());\n      return container.innerHTML;\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  var s2s = 0, s2e = 1, e2e = 2, e2s = 3;\n  var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;\n  var comparisonConstants = {\n      START_TO_START: s2s,\n      START_TO_END: s2e,\n      END_TO_END: e2e,\n      END_TO_START: e2s,\n      NODE_BEFORE: n_b,\n      NODE_AFTER: n_a,\n      NODE_BEFORE_AND_AFTER: n_b_a,\n      NODE_INSIDE: n_i,\n  };\n  /**\n   * @deprecated please replace by: `class C extends createPrototypeRange(..){..} Object.assign(C, comparisonConstants)`\n   * @param C constructor (a class)\n   */\n  function copyComparisonConstants(C) {\n      Object.assign(C, comparisonConstants);\n      Object.assign(C.prototype, comparisonConstants);\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  function createDomRangeP1(Base) {\n      return /** @class */ (function (_super) {\n          __extends(class_1, _super);\n          function class_1() {\n              return _super !== null && _super.apply(this, arguments) || this;\n          }\n          class_1.prototype.compareBoundaryPoints = function (how, range) {\n              assertRangeValid(this);\n              assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n              var nodeA, offsetA, nodeB, offsetB;\n              var prefixA = (how == e2s || how == s2s) ? "start" : "end";\n              var prefixB = (how == s2e || how == s2s) ? "start" : "end";\n              nodeA = this[prefixA + "Container"];\n              offsetA = this[prefixA + "Offset"];\n              nodeB = range[prefixB + "Container"];\n              offsetB = range[prefixB + "Offset"];\n              return comparePoints(nodeA, offsetA, nodeB, offsetB);\n          };\n          class_1.prototype.insertNode = function (node) {\n              assertRangeValid(this);\n              assertValidNodeType(node, insertableNodeTypes);\n              assertNodeNotReadOnly(this.startContainer);\n              if (isOrIsAncestorOf(node, this.startContainer)) {\n                  throw new DOMException("HIERARCHY_REQUEST_ERR");\n              }\n              // No check for whether the container of the start of the Range is of a type that does not allow\n              // children of the type of node: the browser\'s DOM implementation should do this for us when we attempt\n              // to add the node\n              var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n              this.setStartBefore(firstNodeInserted);\n          };\n          class_1.prototype.cloneContents = function () {\n              assertRangeValid(this);\n              var clone, frag;\n              if (this.collapsed) {\n                  return getRangeDocument(this).createDocumentFragment();\n              }\n              else {\n                  if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {\n                      clone = this.startContainer.cloneNode(true);\n                      clone.data = clone.data.slice(this.startOffset, this.endOffset);\n                      frag = getRangeDocument(this).createDocumentFragment();\n                      frag.appendChild(clone);\n                      return frag;\n                  }\n                  else {\n                      var iterator = new RangeIterator(this, true);\n                      clone = cloneSubtree(iterator);\n                      iterator.detach();\n                  }\n                  return clone;\n              }\n          };\n          class_1.prototype.canSurroundContents = function () {\n              assertRangeValid(this);\n              assertNodeNotReadOnly(this.startContainer);\n              assertNodeNotReadOnly(this.endContainer);\n              // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n              // no non-text nodes.\n              // see https://developer.mozilla.org/en-US/docs/Web/API/Range/surroundContents\n              var iterator = new RangeIterator(this, true);\n              var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||\n                  (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n              iterator.detach();\n              return !boundariesInvalid;\n          };\n          class_1.prototype.surroundContents = function (newParent) {\n              assertValidNodeType(newParent, surroundNodeTypes);\n              if (!this.canSurroundContents()) {\n                  throw new DOMException("INVALID_STATE_ERR");\n              }\n              // Extract the contents\n              var content = this.extractContents();\n              // Clear the children of the node\n              if (newParent.hasChildNodes()) {\n                  while (newParent.lastChild) {\n                      newParent.removeChild(newParent.lastChild);\n                  }\n              }\n              // Insert the new node and add the extracted contents\n              insertNodeAtPosition(newParent, this.startContainer, this.startOffset);\n              newParent.appendChild(content);\n              this.selectNode(newParent);\n          };\n          class_1.prototype.cloneRange = function () {\n              assertRangeValid(this);\n              var range = new DomRange(getRangeDocument(this));\n              for (var _i = 0, rangeProperties_1 = rangeProperties; _i < rangeProperties_1.length; _i++) {\n                  var prop = rangeProperties_1[_i];\n                  range[prop] = this[prop];\n              }\n              return range;\n          };\n          class_1.prototype.toString = function () {\n              assertRangeValid(this);\n              var sc = this.startContainer;\n              if (sc === this.endContainer && isCharacterDataNode(sc)) {\n                  return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";\n              }\n              else {\n                  var textParts = [], iterator = new RangeIterator(this, true);\n                  iterateSubtree(iterator, function (node) {\n                      // Accept only text or CDATA nodes, not comments\n                      if (node.nodeType == 3 || node.nodeType == 4) {\n                          textParts.push(node.data);\n                      }\n                  });\n                  iterator.detach();\n                  return textParts.join("");\n              }\n          };\n          // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n          // been removed from Mozilla.\n          class_1.prototype.compareNode = function (node) {\n              assertRangeValid(this);\n              var parent = node.parentNode;\n              var nodeIndex = getNodeIndex(node);\n              if (!parent) {\n                  throw new DOMException("NOT_FOUND_ERR");\n              }\n              var startComparison = this.comparePoint(parent, nodeIndex), endComparison = this.comparePoint(parent, nodeIndex + 1);\n              if (startComparison < 0) { // Node starts before\n                  return (endComparison > 0) ? n_b_a : n_b;\n              }\n              else {\n                  return (endComparison > 0) ? n_a : n_i;\n              }\n          };\n          /**\n           * Returns −1 if the point is before the range, 0 if the point is\n           * in the range, and 1 if the point is after the range.\n           */\n          class_1.prototype.comparePoint = function (node, offset) {\n              assertRangeValid(this);\n              assertNode(node, "HIERARCHY_REQUEST_ERR");\n              assertSameDocumentOrFragment(node, this.startContainer);\n              if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n                  return -1;\n              }\n              else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n                  return 1;\n              }\n              return 0;\n          };\n          // Implementation as per HTML parsing spec, trusting in the browser\'s implementation of innerHTML. See\n          // discussion and base code for this implementation at issue 67.\n          // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n          // Thanks to Aleks Williams.\n          class_1.prototype.createContextualFragment = function (fragment) {\n              // "Let node the context object\'s start\'s node."\n              var node = this.startContainer;\n              var doc = getDocument(node);\n              // "If the context object\'s start\'s node is null, raise an INVALID_STATE_ERR\n              // exception and abort these steps."\n              if (!node) {\n                  throw new DOMException("INVALID_STATE_ERR");\n              }\n              // "Let element be as follows, depending on node\'s interface:"\n              // Document, Document Fragment: null\n              var el = null;\n              // "Element: node"\n              if (node.nodeType == 1) {\n                  el = node;\n                  // "Text, Comment: node\'s parentElement"\n              }\n              else if (isCharacterDataNode(node)) {\n                  el = parentElement(node);\n              }\n              // "If either element is null or element\'s ownerDocument is an HTML document\n              // and element\'s local name is "html" and element\'s namespace is the HTML\n              // namespace"\n              if (el === null || (el.nodeName == "HTML" &&\n                  isHtmlNamespace(getDocument(el).documentElement) &&\n                  isHtmlNamespace(el))) {\n                  // "let element be a new Element with "body" as its local name and the HTML\n                  // namespace as its namespace.""\n                  el = doc.createElement("body");\n              }\n              else {\n                  el = el.cloneNode(false);\n              }\n              // "If the node\'s document is an HTML document: Invoke the HTML fragment parsing algorithm."\n              // "If the node\'s document is an XML document: Invoke the XML fragment parsing algorithm."\n              // "In either case, the algorithm must be invoked with fragment as the input\n              // and element as the context element."\n              el.innerHTML = fragment;\n              // "If this raises an exception, then abort these steps. Otherwise, let new\n              // children be the nodes returned."\n              // "Let fragment be a new DocumentFragment."\n              // "Append all new children to fragment."\n              // "Return fragment."\n              return fragmentFromNodeChildren(el);\n          };\n          class_1.prototype.toHtml = function () {\n              return rangeToHtml(this);\n          };\n          // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n          // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n          class_1.prototype.intersectsNode = function (node, touchingIsIntersecting) {\n              assertRangeValid(this);\n              if (getRootContainer(node) != getRangeRoot(this)) {\n                  return false;\n              }\n              var parent = node.parentNode, offset = getNodeIndex(node);\n              if (!parent) {\n                  return true;\n              }\n              var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset), endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n              return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n          };\n          class_1.prototype.isPointInRange = function (node, offset) {\n              assertRangeValid(this);\n              assertNode(node, "HIERARCHY_REQUEST_ERR");\n              assertSameDocumentOrFragment(node, this.startContainer);\n              return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&\n                  (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);\n          };\n          // The methods below are non-standard and invented by me.\n          class_1.prototype.intersectsRange = function (range) {\n              return rangesIntersect(this, range, false);\n          };\n          class_1.prototype.intersectsOrTouchesRange = function (range) {\n              return rangesIntersect(this, range, true);\n          };\n          class_1.prototype.intersection = function (range) {\n              if (this.intersectsRange(range)) {\n                  var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset), endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n                  var intersectionRange = this.cloneRange();\n                  if (startComparison == -1) {\n                      intersectionRange.setStart(range.startContainer, range.startOffset);\n                  }\n                  if (endComparison == 1) {\n                      intersectionRange.setEnd(range.endContainer, range.endOffset);\n                  }\n                  return intersectionRange;\n              }\n              return null;\n          };\n          class_1.prototype.union = function (range) {\n              if (this.intersectsOrTouchesRange(range)) {\n                  var unionRange = this.cloneRange();\n                  if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n                      unionRange.setStart(range.startContainer, range.startOffset);\n                  }\n                  if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n                      unionRange.setEnd(range.endContainer, range.endOffset);\n                  }\n                  return unionRange;\n              }\n              else {\n                  throw new DOMException("Ranges do not intersect");\n              }\n          };\n          class_1.prototype.containsNode = function (node, allowPartial) {\n              if (allowPartial) {\n                  return this.intersectsNode(node, false);\n              }\n              else {\n                  return this.compareNode(node) == n_i;\n              }\n          };\n          class_1.prototype.containsNodeContents = function (node) {\n              return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;\n          };\n          class_1.prototype.containsRange = function (range) {\n              var intersection = this.intersection(range);\n              return intersection !== null && range.equals(intersection);\n          };\n          class_1.prototype.containsNodeText = function (node) {\n              var nodeRange = this.cloneRange();\n              nodeRange.selectNode(node);\n              var textNodes = nodeRange.getNodes([3]);\n              if (textNodes.length > 0) {\n                  nodeRange.setStart(textNodes[0], 0);\n                  var lastTextNode = textNodes.pop();\n                  nodeRange.setEnd(lastTextNode, lastTextNode.length);\n                  return this.containsRange(nodeRange);\n              }\n              else {\n                  return this.containsNodeContents(node);\n              }\n          };\n          class_1.prototype.getNodes = function (nodeTypes, filter) {\n              assertRangeValid(this);\n              return getNodesInRange(this, nodeTypes, filter);\n          };\n          class_1.prototype.getDocument = function () {\n              return getRangeDocument(this);\n          };\n          class_1.prototype.collapseBefore = function (node) {\n              this.setEndBefore(node);\n              this.collapse(false);\n          };\n          class_1.prototype.collapseAfter = function (node) {\n              this.setStartAfter(node);\n              this.collapse(true);\n          };\n          class_1.prototype.getBookmark = function (containerNode) {\n              var doc = getRangeDocument(this);\n              var preSelectionRange = createRange(doc);\n              containerNode = containerNode || getBody(doc);\n              preSelectionRange.selectNodeContents(containerNode);\n              var range = this.intersection(preSelectionRange);\n              var start = 0, end = 0;\n              if (range) {\n                  preSelectionRange.setEnd(range.startContainer, range.startOffset);\n                  start = preSelectionRange.toString().length;\n                  end = start + range.toString().length;\n              }\n              return {\n                  start: start,\n                  end: end,\n                  containerNode: containerNode\n              };\n          };\n          class_1.prototype.moveToBookmark = function (bookmark) {\n              var containerNode = bookmark.containerNode;\n              var charIndex = 0;\n              this.setStart(containerNode, 0);\n              this.collapse(true);\n              var nodeStack = [containerNode], node, foundStart = false, stop = false;\n              var nextCharIndex, i, childNodes;\n              while (!stop && (node = nodeStack.pop())) {\n                  if (node.nodeType == 3) {\n                      nextCharIndex = charIndex + node.length;\n                      if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {\n                          this.setStart(node, bookmark.start - charIndex);\n                          foundStart = true;\n                      }\n                      if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {\n                          this.setEnd(node, bookmark.end - charIndex);\n                          stop = true;\n                      }\n                      charIndex = nextCharIndex;\n                  }\n                  else {\n                      childNodes = node.childNodes;\n                      i = childNodes.length;\n                      while (i--) {\n                          nodeStack.push(childNodes[i]);\n                      }\n                  }\n              }\n          };\n          class_1.prototype.getName = function () {\n              return "DomRange";\n          };\n          class_1.prototype.equals = function (range) {\n              return rangesEqual(this, range);\n          };\n          class_1.prototype.isValid = function () {\n              return isRangeValid(this);\n          };\n          class_1.prototype.inspect = function () {\n              return rangeInspect(this);\n          };\n          class_1.prototype.detach = function () {\n              // In DOM4, detach() is now a no-op.\n          };\n          // in rangy1, this method is implement in wrappedselection.js\n          // TODO declare in RangeP1Ex\n          class_1.prototype.select = function (direction) {\n              getSelection(this.getDocument()).setSingleRange(this, direction);\n          };\n          return class_1;\n      }(Base));\n  } // createDomRangeP1\n  function rangesEqual(r1, r2) {\n      return r1.startContainer === r2.startContainer &&\n          r1.startOffset === r2.startOffset &&\n          r1.endContainer === r2.endContainer &&\n          r1.endOffset === r2.endOffset;\n  }\n\n  // Pure JavaScript implementation of DOM Range\n  var module$1 = new Module("DomRange", ["DomUtil"]);\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // Utility functions\n  function getBoundaryBeforeNode(node) {\n      return new DomPosition(node.parentNode, getNodeIndex(node));\n  }\n  function getBoundaryAfterNode(node) {\n      return new DomPosition(node.parentNode, getNodeIndex(node) + 1);\n  }\n  function splitRangeBoundaries(range, positionsToPreserve) {\n      assertRangeValid(range);\n      var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;\n      var startEndSame = (sc === ec);\n      if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n          splitDataNode(ec, eo, positionsToPreserve);\n      }\n      if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n          sc = splitDataNode(sc, so, positionsToPreserve);\n          if (startEndSame) {\n              eo -= so;\n              ec = sc;\n          }\n          else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {\n              eo++;\n          }\n          so = 0;\n      }\n      range.setStartAndEnd(sc, so, ec, eo);\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  function createRangeContentRemover(remover, boundaryUpdater) {\n      return function () {\n          assertRangeValid(this);\n          var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;\n          var iterator = new RangeIterator(this, true);\n          // Work out where to position the range after content removal\n          var node, boundary;\n          if (sc !== root) {\n              node = getClosestAncestorIn(sc, root, true);\n              boundary = getBoundaryAfterNode(node);\n              sc = boundary.node;\n              so = boundary.offset;\n          }\n          // Check none of the range is read-only\n          iterateSubtree(iterator, assertNodeNotReadOnly);\n          iterator.reset();\n          // Remove the content\n          var returnValue = remover(iterator);\n          iterator.detach();\n          // Move to the new position\n          boundaryUpdater(this, sc, so, sc, so);\n          return returnValue;\n      };\n  }\n  // https://mariusschulz.com/blog/typescript-2-2-mixin-classes\n  function createDomRangeP2(Base, boundaryUpdater) {\n      function createBeforeAfterNodeSetter(isBefore, isStart) {\n          return function (node) {\n              assertValidNodeType(node, beforeAfterNodeTypes);\n              assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n              var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n              (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n          };\n      }\n      function setRangeStart(range, node, offset) {\n          var ec = range.endContainer, eo = range.endOffset;\n          if (node !== range.startContainer || offset !== range.startOffset) {\n              // Check the root containers of the range and the new boundary, and also check whether the new boundary\n              // is after the current end. In either case, collapse the range to the new position\n              if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {\n                  ec = node;\n                  eo = offset;\n              }\n              boundaryUpdater(range, node, offset, ec, eo);\n          }\n      }\n      function setRangeEnd(range, node, offset) {\n          var sc = range.startContainer, so = range.startOffset;\n          if (node !== range.endContainer || offset !== range.endOffset) {\n              // Check the root containers of the range and the new boundary, and also check whether the new boundary\n              // is after the current end. In either case, collapse the range to the new position\n              if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {\n                  sc = node;\n                  so = offset;\n              }\n              boundaryUpdater(range, sc, so, node, offset);\n          }\n      }\n      /*\n              // Set up inheritance\n              var F = function() {};\n              F.prototype = api.rangePrototype;\n              Base.prototype = new F();\n      \n              util.extend(Base.prototype, {\n                 ...\n              });\n      */\n      return /** @class */ (function (_super) {\n          __extends(class_1, _super);\n          function class_1() {\n              var _this = _super !== null && _super.apply(this, arguments) || this;\n              _this.setStartBefore = createBeforeAfterNodeSetter(true, true);\n              _this.setStartAfter = createBeforeAfterNodeSetter(false, true);\n              _this.setEndBefore = createBeforeAfterNodeSetter(true, false);\n              _this.setEndAfter = createBeforeAfterNodeSetter(false, false);\n              _this.extractContents = createRangeContentRemover(extractSubtree, boundaryUpdater);\n              _this.deleteContents = createRangeContentRemover(deleteSubtree, boundaryUpdater);\n              return _this;\n          }\n          class_1.prototype.setStart = function (node, offset) {\n              assertNoDocTypeNotationEntityAncestor(node, true);\n              assertValidOffset(node, offset);\n              setRangeStart(this, node, offset);\n          };\n          class_1.prototype.setEnd = function (node, offset) {\n              assertNoDocTypeNotationEntityAncestor(node, true);\n              assertValidOffset(node, offset);\n              setRangeEnd(this, node, offset);\n          };\n          class_1.prototype.setStartAndEnd = function () {\n              var args = [];\n              for (var _i = 0; _i < arguments.length; _i++) {\n                  args[_i] = arguments[_i];\n              }\n              var sc = args[0], so = args[1], ec = sc, eo = so;\n              switch (args.length) {\n                  case 3:\n                      eo = args[2];\n                      break;\n                  case 4:\n                      ec = args[2];\n                      eo = args[3];\n                      break;\n              }\n              assertNoDocTypeNotationEntityAncestor(sc, true);\n              assertValidOffset(sc, so);\n              assertNoDocTypeNotationEntityAncestor(ec, true);\n              assertValidOffset(ec, eo);\n              boundaryUpdater(this, sc, so, ec, eo);\n          };\n          class_1.prototype.setBoundary = function (node, offset, isStart) {\n              this["set" + (isStart ? "Start" : "End")](node, offset);\n          };\n          class_1.prototype.collapse = function (toStart) {\n              assertRangeValid(this);\n              if (toStart) {\n                  boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n              }\n              else {\n                  boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n              }\n          };\n          class_1.prototype.selectNodeContents = function (node) {\n              assertNoDocTypeNotationEntityAncestor(node, true);\n              boundaryUpdater(this, node, 0, node, getNodeLength(node));\n          };\n          class_1.prototype.selectNode = function (node) {\n              assertNoDocTypeNotationEntityAncestor(node, false);\n              assertValidNodeType(node, beforeAfterNodeTypes);\n              var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);\n              boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n          };\n          class_1.prototype.splitBoundaries = function () {\n              splitRangeBoundaries(this);\n          };\n          class_1.prototype.splitBoundariesPreservingPositions = function (positionsToPreserve) {\n              splitRangeBoundaries(this, positionsToPreserve);\n          };\n          class_1.prototype.normalizeBoundaries = function () {\n              assertRangeValid(this);\n              var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;\n              var mergeForward = function (node) {\n                  var sibling = node.nextSibling;\n                  if (sibling && sibling.nodeType == node.nodeType) {\n                      ec = node;\n                      eo = node.length;\n                      node.appendData(sibling.data);\n                      removeNode(sibling);\n                  }\n              };\n              var mergeBackward = function (node) {\n                  var sibling = node.previousSibling;\n                  if (sibling && sibling.nodeType == node.nodeType) {\n                      sc = node;\n                      var nodeLength = node.length;\n                      so = sibling.length;\n                      node.insertData(0, sibling.data);\n                      removeNode(sibling);\n                      if (sc == ec) {\n                          eo += so;\n                          ec = sc;\n                      }\n                      else if (ec == node.parentNode) {\n                          var nodeIndex = getNodeIndex(node);\n                          if (eo == nodeIndex) {\n                              ec = node;\n                              eo = nodeLength;\n                          }\n                          else if (eo > nodeIndex) {\n                              eo--;\n                          }\n                      }\n                  }\n              };\n              var normalizeStart = true;\n              var sibling;\n              if (isCharacterDataNode(ec)) {\n                  if (eo == ec.length) {\n                      mergeForward(ec);\n                  }\n                  else if (eo == 0) {\n                      sibling = ec.previousSibling;\n                      if (sibling && sibling.nodeType == ec.nodeType) {\n                          eo = sibling.length;\n                          if (sc == ec) {\n                              normalizeStart = false;\n                          }\n                          sibling.appendData(ec.data);\n                          removeNode(ec);\n                          ec = sibling;\n                      }\n                  }\n              }\n              else {\n                  if (eo > 0) {\n                      var endNode = ec.childNodes[eo - 1];\n                      if (endNode && isCharacterDataNode(endNode)) {\n                          mergeForward(endNode);\n                      }\n                  }\n                  normalizeStart = !this.collapsed;\n              }\n              if (normalizeStart) {\n                  if (isCharacterDataNode(sc)) {\n                      if (so == 0) {\n                          mergeBackward(sc);\n                      }\n                      else if (so == sc.length) {\n                          sibling = sc.nextSibling;\n                          if (sibling && sibling.nodeType == sc.nodeType) {\n                              if (ec == sibling) {\n                                  ec = sc;\n                                  eo += sc.length;\n                              }\n                              sc.appendData(sibling.data);\n                              removeNode(sibling);\n                          }\n                      }\n                  }\n                  else {\n                      if (so < sc.childNodes.length) {\n                          var startNode = sc.childNodes[so];\n                          if (startNode && isCharacterDataNode(startNode)) {\n                              mergeBackward(startNode);\n                          }\n                      }\n                  }\n              }\n              else {\n                  sc = ec;\n                  so = eo;\n              }\n              boundaryUpdater(this, sc, so, ec, eo);\n          };\n          class_1.prototype.collapseToPoint = function (node, offset) {\n              assertNoDocTypeNotationEntityAncestor(node, true);\n              assertValidOffset(node, offset);\n              this.setStartAndEnd(node, offset);\n          };\n          class_1.prototype.parentElement = function () {\n              assertRangeValid(this);\n              return getElementAncestor(this.commonAncestorContainer, true);\n          };\n          return class_1;\n      }(Base));\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  /** TODO remove comment\n   * @requires call `Object.assign(R, comparisonConstants)` after call this function:\n   *      `class R extends createPrototypeRange(..`\n   * or\n   *      `const R = createPrototypeRange(..`\n   */\n  function createPrototypeRange(Base, boundaryUpdater) {\n      // R1 is a not completed class because createDomRangeP1 only implement RangeP1\n      // the missing members in RangeP2 will be provided at createDomRangeP2\n      // and the missing members in ComparisonConstants will be provided here in `createPrototypeRange`\n      // so result `R12` will be a completed class that implement `Range`\n      var MixinBase = Base;\n      var R1 = createDomRangeP1(MixinBase);\n      //after this, instances of R1 will have consts like: START_TO_START,..\n      Object.assign(R1.prototype, comparisonConstants);\n      var R12 = createDomRangeP2(R1, boundaryUpdater);\n      // this is similar to add `static START_TO_START = ..` into R12\n      // note that, we can ass static members in subclasses: class A{static s = ..} class B extends A{} B.s\n      return Object.assign(R12, comparisonConstants);\n  }\n  // TODO remove comment\n  // we need this const to bypass TS2506: \'DomRange\' is referenced directly or indirectly in it own base expression\n  // export const _DomRange = createPrototypeRange(RangeBase, updateBoundaries);\n  // export type DomRange = InstanceType<typeof DomRange>;\n  var DomRange = /** @class */ (function (_super) {\n      __extends(DomRange, _super);\n      function DomRange() {\n          return _super !== null && _super.apply(this, arguments) || this;\n      }\n      DomRange.inspect = rangeInspect;\n      DomRange.toHtml = rangeToHtml;\n      DomRange.getRangeDocument = getRangeDocument;\n      DomRange.rangesEqual = rangesEqual;\n      return DomRange;\n  }(createPrototypeRange(DomRangeBase, updateBoundaries)));\n  // @deprecated pls directly import & use the exported member of this module\n  Object.assign(DomRange, {\n      rangeProperties: rangeProperties,\n      RangeIterator: RangeIterator,\n      copyComparisonConstants: copyComparisonConstants,\n      createPrototypeRange: createPrototypeRange,\n  });\n  function createRangyRange(doc) {\n      doc = getContentDocument(doc, module$1, "createRangyRange");\n      return new DomRange(doc);\n  }\n\n  // https://medium.com/visual-development/how-to-fix-nasty-circular-dependency-issues-once-and-for-all-in-javascript-typescript-a04c987cf0de\n\n  var module$2 = new Module("WrappedRange", ["DomRange"]);\n  // Wrappers for the browser\'s native DOM Range implementation\n  // /* build:replaceWith(api) */rangy/* build:replaceEnd */.createCoreModule("WrappedRange", ["DomRange"], function(api, module) {\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // if (api.features.implementsDomRange) {\n  // This is a wrapper around the browser\'s native DOM Range. It has two aims:\n  // - Provide workarounds for specific browser bugs\n  // - provide convenient extensions, which are inherited from Rangy\'s DomRange\n  function updateRangeProperties(range) {\n      for (var _i = 0, rangeProperties_1 = rangeProperties; _i < rangeProperties_1.length; _i++) {\n          var prop = rangeProperties_1[_i];\n          range[prop] = range.nativeRange[prop];\n      }\n      // Fix for broken collapsed property in IE 9.\n      range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n  }\n  function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n      var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);\n      var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);\n      var nativeRangeDifferent = !range.equals(range.nativeRange);\n      // Always set both boundaries for the benefit of IE9 (see issue 35)\n      if (startMoved || endMoved || nativeRangeDifferent) {\n          range.setEnd(endContainer, endOffset);\n          range.setStart(startContainer, startOffset);\n      }\n  }\n  var WrappedRange = /** @class */ (function (_super) {\n      __extends(WrappedRange, _super); /*implements WrappedRangeBase*/\n      function WrappedRange(nativeRange) {\n          var _this = _super.call(this) || this;\n          _this.nativeRange = nativeRange;\n          _this.setStartBefore = WrappedRange.createBeforeAfterNodeSetter("setStartBefore");\n          _this.setStartAfter = WrappedRange.createBeforeAfterNodeSetter("setStartAfter");\n          _this.setEndBefore = WrappedRange.createBeforeAfterNodeSetter("setEndBefore");\n          _this.setEndAfter = WrappedRange.createBeforeAfterNodeSetter("setEndAfter");\n          if (!nativeRange) {\n              throw module$2.createError("WrappedRange: Range must be specified");\n          }\n          updateRangeProperties(_this);\n          return _this;\n      }\n      // nativeRange: Range; //declare here\n      WrappedRange.prototype.selectNode = function (node) {\n          this.nativeRange.selectNode(node);\n          updateRangeProperties(this);\n      };\n      WrappedRange.prototype.cloneContents = function () {\n          return this.nativeRange.cloneContents();\n      };\n      // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,\n      // insertNode() is never delegated to the native range.\n      WrappedRange.prototype.surroundContents = function (node) {\n          this.nativeRange.surroundContents(node);\n          updateRangeProperties(this);\n      };\n      WrappedRange.prototype.collapse = function (isStart) {\n          this.nativeRange.collapse(isStart);\n          updateRangeProperties(this);\n      };\n      WrappedRange.prototype.cloneRange = function () {\n          return new WrappedRange(this.nativeRange.cloneRange());\n      };\n      WrappedRange.prototype.refresh = function () {\n          updateRangeProperties(this);\n      };\n      WrappedRange.prototype.toString = function () {\n          return this.nativeRange.toString();\n      };\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n      // correct for it\n      // note: rangy2 don\'t support Firefox <= 2\n      WrappedRange.prototype.setStart = function (node, offset) {\n          this.nativeRange.setStart(node, offset);\n          updateRangeProperties(this);\n      };\n      WrappedRange.prototype.setEnd = function (node, offset) {\n          this.nativeRange.setEnd(node, offset);\n          updateRangeProperties(this);\n      };\n      WrappedRange.createBeforeAfterNodeSetter = function (name) {\n          return function (node) {\n              this.nativeRange[name](node);\n              updateRangeProperties(this);\n          };\n      };\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Always use DOM4-compliant selectNodeContents implementation: it\'s simpler and less code than testing\n      // whether the native implementation can be trusted\n      WrappedRange.prototype.selectNodeContents = function (node) {\n          //implement in domrange\n          this.setStartAndEnd(node, 0, getNodeLength(node));\n      };\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for\n      // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n      // note: this bug is fixed in 2008, so rangy2 don\'t test this\n      WrappedRange.prototype.compareBoundaryPoints = function (how, sourceRange) {\n          return this.nativeRange.compareBoundaryPoints(how, sourceRange.nativeRange || sourceRange);\n      };\n      /*--------------------------------------------------------------------------------------------------------*/\n      WrappedRange.prototype.getName = function () {\n          return "WrappedRange";\n      };\n      return WrappedRange;\n  }(createPrototypeRange(RangeBase, updateNativeRange) /*implements WrappedRangeBase*/));\n  // Object.assign(WrappedRange, comparisonConstants);\n  // change WrappedRange.{deleteContents, extractContents, createContextualFragment} if need\n  function docReadyHandler() {\n      // Create test range and node for feature detection\n      var testTextNode = document.createTextNode("test");\n      getBody(document).appendChild(testTextNode);\n      var range = document.createRange();\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.\n      var el = document.createElement("div");\n      el.innerHTML = "123";\n      var textNode = el.firstChild;\n      var body = getBody(document);\n      body.appendChild(el);\n      range.setStart(textNode, 1);\n      range.setEnd(textNode, 2);\n      range.deleteContents();\n      var rangeProto = WrappedRange.prototype;\n      if (textNode.data == "13") {\n          // Behaviour is correct per DOM4 Range so wrap the browser\'s implementation of deleteContents() and\n          // extractContents()\n          rangeProto.deleteContents = function () {\n              this.nativeRange.deleteContents();\n              updateRangeProperties(this);\n          };\n          rangeProto.extractContents = function () {\n              var frag = this.nativeRange.extractContents();\n              updateRangeProperties(this);\n              return frag;\n          };\n      }\n      body.removeChild(el);\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Test for existence of createContextualFragment and delegate to it if it exists\n      if (isHostMethod(range, "createContextualFragment")) {\n          rangeProto.createContextualFragment = function (fragmentStr) {\n              return this.nativeRange.createContextualFragment(fragmentStr);\n          };\n      }\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Clean up\n      body.removeChild(testTextNode);\n      body = null;\n  }\n  onDocReady(docReadyHandler);\n  function createNativeRange(doc) {\n      doc = getContentDocument(doc, module$2, "createNativeRange");\n      return doc.createRange();\n  }\n  function createRange(doc) {\n      doc = getContentDocument(doc, module$2, "createRange");\n      return new WrappedRange(createNativeRange(doc));\n  }\n  function shimCreateRange(win) {\n      if (!win)\n          win = window;\n      var doc = win.document;\n      if (typeof doc.createRange == "undefined") {\n          doc.createRange = function () {\n              return createRange(doc);\n          };\n      }\n  }\n\n  var module$3 = new Module("WrappedSelection", ["DomRange", "WrappedRange"]);\n  // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification\n  // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)\n  // /* build:replaceWith(api) */rangy/* build:replaceEnd */.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api, module) {\n  var BOOLEAN = "boolean";\n  var NUMBER = "number";\n\n  // Utility function to support direction parameters in the API that may be a string ("backward", "backwards",\n  // "forward" or "forwards") or a Boolean (true for backwards).\n  function isDirectionBackward(dir) {\n      return (typeof dir == "string") ? /^backward(s)?$/i.test(dir) : !!dir;\n  }\n  function getWindow$1(win, methodName) {\n      if (!win) {\n          return window;\n      }\n      else if (isWindow(win)) {\n          return win;\n      }\n      else if (win instanceof WrappedSelection) {\n          return win.win;\n      }\n      else {\n          var doc = getContentDocument(win, module$3, methodName);\n          return getWindow(doc);\n      }\n  }\n  function getNativeSelection(winParam) {\n      return getWindow$1(winParam, "getWinSelection").getSelection();\n  }\n  function winSelectionIsBackward(sel) {\n      var backward = false;\n      if (sel.anchorNode) {\n          backward = (comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);\n      }\n      return backward;\n  }\n  var selectionIsBackward = winSelectionIsBackward;\n  /** @deprecated always return true because we don\'t support TextRange / document.selection in old IE */\n  function isSelectionValid() {\n      return true;\n  }\n  var testSelection = getNativeSelection();\n  // In Firefox, the selection is null in an iframe with display: none. See issue #138.\n  if (!testSelection) {\n      module$3.fail("Native selection was null (possibly issue 138?)");\n      // return false;\n  }\n  var testRange = createNativeRange(document);\n  // Obtaining a range from a selection\n  var selectionHasAnchorAndFocus = features.selectionHasAnchorAndFocus =\n      areHostProperties(testSelection, ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);\n  // Test for existence of native selection extend() method\n  var selectionHasExtend = features.selectionHasExtend =\n      isHostMethod(testSelection, "extend");\n  // Test if rangeCount exists\n  var selectionHasRangeCount = features.selectionHasRangeCount =\n      (typeof testSelection.rangeCount == NUMBER);\n  var addRangeBackwardToNative = selectionHasExtend\n      ? function (nativeSelection, range) {\n          var doc = DomRange.getRangeDocument(range);\n          var endRange = createRange(doc);\n          endRange.collapseToPoint(range.endContainer, range.endOffset);\n          nativeSelection.addRange(getNativeRange(endRange));\n          nativeSelection.extend(range.startContainer, range.startOffset);\n      }\n      : null;\n  // Selection collapsedness\n  var selectionIsCollapsed = selectionHasAnchorAndFocus\n      ? function (sel) {\n          return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n      }\n      : function (sel) {\n          return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n      };\n  function updateAnchorAndFocusFromRange(sel, range, backward) {\n      var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";\n      sel.anchorNode = range[anchorPrefix + "Container"];\n      sel.anchorOffset = range[anchorPrefix + "Offset"];\n      sel.focusNode = range[focusPrefix + "Container"];\n      sel.focusOffset = range[focusPrefix + "Offset"];\n  }\n  function updateAnchorAndFocusFromNativeSelection(sel) {\n      var nativeSel = sel.nativeSelection;\n      sel.anchorNode = nativeSel.anchorNode;\n      sel.anchorOffset = nativeSel.anchorOffset;\n      sel.focusNode = nativeSel.focusNode;\n      sel.focusOffset = nativeSel.focusOffset;\n  }\n  function updateEmptySelection(sel) {\n      sel.anchorNode = sel.focusNode = null;\n      sel.anchorOffset = sel.focusOffset = 0;\n      sel.rangeCount = 0;\n      sel.isCollapsed = true;\n      sel._ranges.length = 0;\n  }\n  function getNativeRange(range) {\n      var nativeRange;\n      if (range instanceof DomRange) {\n          nativeRange = createNativeRange(range.getDocument());\n          nativeRange.setEnd(range.endContainer, range.endOffset);\n          nativeRange.setStart(range.startContainer, range.startOffset);\n      }\n      else if (range instanceof WrappedRange) {\n          nativeRange = range.nativeRange;\n          // } else if (features.implementsDomRange && ((range as any) instanceof dom.getWindow(range.startContainer).Range)) {\n      }\n      else if (range instanceof Range) {\n          nativeRange = range;\n      }\n      return nativeRange;\n  }\n  var getSelectionRangeAt;\n  if (isHostMethod(testSelection, "getRangeAt")) {\n      // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.\n      // Unfortunately, I didn\'t write a comment about the specifics and am now scared to take it out. Let that be a\n      // lesson to us all, especially me.\n      getSelectionRangeAt = function (sel, index) {\n          try {\n              return sel.getRangeAt(index);\n          }\n          catch (ex) {\n              return null;\n          }\n      };\n  }\n  else if (selectionHasAnchorAndFocus) {\n      getSelectionRangeAt = function (sel) {\n          var doc = getDocument(sel.anchorNode);\n          var range = createRange(doc);\n          range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);\n          // Handle the case when the selection was selected backwards (from the end to the start in the\n          // document)\n          if (range.collapsed !== this.isCollapsed) {\n              range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);\n          }\n          return range;\n      };\n  }\n  function deleteProperties(sel) {\n      sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;\n      sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;\n      sel.detached = true;\n  }\n  var cachedRangySelections = [];\n  function actOnCachedSelection(win, action) {\n      var i = cachedRangySelections.length, cached, sel;\n      while (i--) {\n          cached = cachedRangySelections[i];\n          sel = cached.selection;\n          if (action == "deleteAll") {\n              deleteProperties(sel);\n          }\n          else if (cached.win == win) {\n              if (action == "delete") {\n                  cachedRangySelections.splice(i, 1);\n                  return true;\n              }\n              else {\n                  return sel;\n              }\n          }\n      }\n      if (action == "deleteAll") {\n          cachedRangySelections.length = 0;\n      }\n      return null;\n  }\n  function getSelection(win) {\n      // Check if the parameter is a Rangy Selection object\n      if (win && win instanceof WrappedSelection) {\n          win.refresh();\n          return win;\n      }\n      win = getWindow$1(win, "getNativeSelection");\n      var sel = actOnCachedSelection(win);\n      var nativeSel = getNativeSelection(win);\n      if (sel) {\n          sel.nativeSelection = nativeSel;\n          sel.refresh();\n      }\n      else {\n          sel = new WrappedSelection(nativeSel, win);\n          cachedRangySelections.push({ win: win, selection: sel });\n      }\n      return sel;\n  }\n  var refreshSelection;\n  if (isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {\n      refreshSelection = function (sel) {\n          sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n          if (sel.rangeCount) {\n              for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                  sel._ranges[i] = new WrappedRange(sel.nativeSelection.getRangeAt(i));\n              }\n              updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));\n              sel.isCollapsed = selectionIsCollapsed(sel);\n          }\n          else {\n              updateEmptySelection(sel);\n          }\n      };\n  }\n  else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {\n      refreshSelection = function (sel) {\n          var range, nativeSel = sel.nativeSelection;\n          if (nativeSel.anchorNode) {\n              range = getSelectionRangeAt(nativeSel, 0);\n              sel._ranges = [range];\n              sel.rangeCount = 1;\n              updateAnchorAndFocusFromNativeSelection(sel);\n              sel.isCollapsed = selectionIsCollapsed(sel);\n          }\n          else {\n              updateEmptySelection(sel);\n          }\n      };\n  }\n  else {\n      module$3.fail("No means of obtaining a Range or TextRange from the user\'s selection was found");\n      //return false;\n  }\n  // WrappedSelection.prototype = api.selectionPrototype;\n  var WrappedSelBase = /** @class */ (function () {\n      function WrappedSelBase(nativeSelection, win) {\n          this.nativeSelection = nativeSelection;\n          this.win = win;\n          this._ranges = [];\n          //@deprecated the old rangy2 constructor form: (nativeSelection, docSelection: null, win)\n          if (arguments.length == 3) {\n              this.win = arguments[2];\n          }\n          this.refresh();\n      }\n      return WrappedSelBase;\n  }());\n  // TODO\n  function createWrappedSelection(Base) {\n      var _a;\n      function addRangeBackward(sel, range) {\n          addRangeBackwardToNative(sel.nativeSelection, range);\n          sel.refresh();\n      }\n      var addRange = selectionHasRangeCount\n          ? function (range, direction) {\n              if (isDirectionBackward(direction) && selectionHasExtend) {\n                  addRangeBackward(this, range);\n              }\n              else {\n                  var previousRangeCount;\n                  if (features.selectionSupportsMultipleRanges) {\n                      previousRangeCount = this.rangeCount;\n                  }\n                  else {\n                      this.removeAllRanges();\n                      previousRangeCount = 0;\n                  }\n                  // Clone the native range so that changing the selected range does not affect the selection.\n                  // This is contrary to the spec but is the only way to achieve consistency between browsers. See\n                  // issue 80.\n                  var clonedNativeRange = getNativeRange(range).cloneRange();\n                  try {\n                      this.nativeSelection.addRange(clonedNativeRange);\n                  }\n                  catch (ex) {\n                  }\n                  // Check whether adding the range was successful\n                  this.rangeCount = this.nativeSelection.rangeCount;\n                  if (this.rangeCount == previousRangeCount + 1) {\n                      // The range was added successfully\n                      // Check whether the range that we added to the selection is reflected in the last range extracted from\n                      // the selection\n                      if (config.checkSelectionRanges) {\n                          var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                          if (nativeRange && !rangesEqual(nativeRange, range)) {\n                              // Happens in WebKit with, for example, a selection placed at the start of a text node\n                              range = new WrappedRange(nativeRange);\n                          }\n                      }\n                      this._ranges[this.rangeCount - 1] = range;\n                      updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));\n                      this.isCollapsed = selectionIsCollapsed(this);\n                  }\n                  else {\n                      // The range was not added successfully. The simplest thing is to refresh\n                      this.refresh();\n                  }\n              }\n          }\n          : function (range, direction) {\n              if (isDirectionBackward(direction) && selectionHasExtend) {\n                  addRangeBackward(this, range);\n              }\n              else {\n                  this.nativeSelection.addRange(getNativeRange(range));\n                  this.refresh();\n              }\n          };\n      // Removal of a single range\n      function removeRangeManually(sel, range) {\n          var ranges = sel.getAllRanges();\n          sel.removeAllRanges();\n          for (var i = 0, len = ranges.length; i < len; ++i) {\n              if (!rangesEqual(range, ranges[i])) {\n                  sel.addRange(ranges[i]);\n              }\n          }\n          if (!sel.rangeCount) {\n              updateEmptySelection(sel);\n          }\n      }\n      function assertNodeInSameDocument(sel, node) {\n          if (sel.win.document != getDocument(node)) {\n              throw new DOMException("WRONG_DOCUMENT_ERR");\n          }\n      }\n      function createStartOrEndSetter(isStart) {\n          return function (node, offset) {\n              var range;\n              if (this.rangeCount) {\n                  range = this.getRangeAt(0);\n                  range["set" + (isStart ? "Start" : "End")](node, offset);\n              }\n              else {\n                  range = createRange(this.win.document);\n                  range.setStartAndEnd(node, offset);\n              }\n              this.setSingleRange(range, this.isBackward());\n          };\n      }\n      return _a = /** @class */ (function (_super) {\n              __extends(S, _super);\n              function S() {\n                  var _this = _super !== null && _super.apply(this, arguments) || this;\n                  //if (selectionHasRangeCount) {\n                  _this.addRange = addRange;\n                  // Create an alias for backwards compatibility. From 1.3, everything is "backward" rather than "backwards"\n                  _this.isBackwards = _this.isBackward;\n                  _this.setStart = createStartOrEndSetter(true);\n                  _this.setEnd = createStartOrEndSetter(false);\n                  return _this;\n              }\n              S.prototype.removeAllRanges = function () {\n                  this.nativeSelection.removeAllRanges();\n                  updateEmptySelection(this);\n              };\n              S.prototype.setRanges = function (ranges) {\n                  this.removeAllRanges();\n                  for (var i = 0, len = ranges.length; i < len; ++i) {\n                      this.addRange(ranges[i]);\n                  }\n              };\n              S.prototype.getRangeAt = function (index) {\n                  if (index < 0 || index >= this.rangeCount) {\n                      throw new DOMException("INDEX_SIZE_ERR");\n                  }\n                  else {\n                      // Clone the range to preserve selection-range independence. See issue 80.\n                      return this._ranges[index].cloneRange();\n                  }\n              };\n              S.prototype.refresh = function (checkForChanges) {\n                  var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n                  var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;\n                  refreshSelection(this);\n                  if (checkForChanges) {\n                      // Check the range count first\n                      var i = oldRanges.length;\n                      if (i != this._ranges.length) {\n                          return true;\n                      }\n                      // Now check the direction. Checking the anchor position is the same is enough since we\'re checking all the\n                      // ranges after this\n                      if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {\n                          return true;\n                      }\n                      // Finally, compare each range in turn\n                      while (i--) {\n                          if (!rangesEqual(oldRanges[i], this._ranges[i])) {\n                              return true;\n                          }\n                      }\n                      return false;\n                  }\n              };\n              S.prototype.removeRange = function (range) {\n                  removeRangeManually(this, range);\n              };\n              S.prototype.isBackward = function () {\n                  return selectionIsBackward(this);\n              };\n              // Selection stringifier\n              // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla\'s implementation.\n              // The current spec does not yet define this method.\n              S.prototype.toString = function () {\n                  var rangeTexts = [];\n                  for (var i = 0, len = this.rangeCount; i < len; ++i) {\n                      rangeTexts[i] = "" + this._ranges[i];\n                  }\n                  return rangeTexts.join("");\n              };\n              // No current browser conforms fully to the spec for this method, so Rangy\'s own method is always used\n              S.prototype.collapse = function (node, offset) {\n                  assertNodeInSameDocument(this, node);\n                  var range = createRange(node);\n                  range.collapseToPoint(node, offset);\n                  this.setSingleRange(range);\n                  this.isCollapsed = true;\n              };\n              S.prototype.collapseToStart = function () {\n                  if (this.rangeCount) {\n                      var range = this._ranges[0];\n                      this.collapse(range.startContainer, range.startOffset);\n                  }\n                  else {\n                      throw new DOMException("INVALID_STATE_ERR");\n                  }\n              };\n              S.prototype.collapseToEnd = function () {\n                  if (this.rangeCount) {\n                      var range = this._ranges[this.rangeCount - 1];\n                      this.collapse(range.endContainer, range.endOffset);\n                  }\n                  else {\n                      throw new DOMException("INVALID_STATE_ERR");\n                  }\n              };\n              // The spec is very specific on how selectAllChildren should be implemented and not all browsers implement it as\n              // specified so the native implementation is never used by Rangy.\n              S.prototype.selectAllChildren = function (node) {\n                  assertNodeInSameDocument(this, node);\n                  var range = createRange(node);\n                  range.selectNodeContents(node);\n                  this.setSingleRange(range);\n              };\n              S.prototype.deleteFromDocument = function () {\n                  if (this.rangeCount) {\n                      var ranges = this.getAllRanges();\n                      if (ranges.length) {\n                          this.removeAllRanges();\n                          for (var i = 0, len = ranges.length; i < len; ++i) {\n                              ranges[i].deleteContents();\n                          }\n                          // The spec says nothing about what the selection should contain after calling deleteContents on each\n                          // range. Firefox moves the selection to where the final selected range was, so we emulate that\n                          this.addRange(ranges[len - 1]);\n                      }\n                  }\n              };\n              // The following are non-standard extensions\n              S.prototype.eachRange = function (func, returnValue) {\n                  for (var i = 0, len = this._ranges.length; i < len; ++i) {\n                      if (func(this.getRangeAt(i))) {\n                          return returnValue;\n                      }\n                  }\n              };\n              S.prototype.getAllRanges = function () {\n                  var ranges = [];\n                  this.eachRange(function (range) {\n                      ranges.push(range);\n                  });\n                  return ranges;\n              };\n              S.prototype.setSingleRange = function (range, direction) {\n                  this.removeAllRanges();\n                  this.addRange(range, direction);\n              };\n              S.prototype.callMethodOnEachRange = function (methodName, params) {\n                  var results = [];\n                  this.eachRange(function (range) {\n                      results.push(range[methodName].apply(range, params || []));\n                  });\n                  return results;\n              };\n              S.prototype.changeEachRange = function (func) {\n                  var ranges = [];\n                  var backward = this.isBackward();\n                  this.eachRange(function (range) {\n                      func(range);\n                      ranges.push(range);\n                  });\n                  this.removeAllRanges();\n                  if (backward && ranges.length == 1) {\n                      this.addRange(ranges[0], "backward");\n                  }\n                  else {\n                      this.setRanges(ranges);\n                  }\n              };\n              S.prototype.containsNode = function (node, allowPartial) {\n                  return this.eachRange(function (range) {\n                      return range.containsNode(node, allowPartial);\n                  }, true) || false;\n              };\n              S.prototype.getBookmark = function (containerNode) {\n                  return {\n                      backward: this.isBackward(),\n                      rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])\n                  };\n              };\n              S.prototype.moveToBookmark = function (bookmark) {\n                  var selRanges = [];\n                  for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++];) {\n                      range = createRange(this.win);\n                      range.moveToBookmark(rangeBookmark);\n                      selRanges.push(range);\n                  }\n                  if (bookmark.backward) {\n                      this.setSingleRange(selRanges[0], "backward");\n                  }\n                  else {\n                      this.setRanges(selRanges);\n                  }\n              };\n              S.prototype.saveRanges = function () {\n                  return {\n                      backward: this.isBackward(),\n                      ranges: this.callMethodOnEachRange("cloneRange")\n                  };\n              };\n              S.prototype.restoreRanges = function (selRanges) {\n                  this.removeAllRanges();\n                  for (var i = 0, range; range = selRanges.ranges[i]; ++i) {\n                      this.addRange(range, (selRanges.backward && i == 0));\n                  }\n              };\n              S.prototype.toHtml = function () {\n                  var rangeHtmls = [];\n                  this.eachRange(function (range) {\n                      rangeHtmls.push(DomRange.toHtml(range));\n                  });\n                  return rangeHtmls.join("");\n              };\n              S.inspect = function (sel) {\n                  var rangeInspects = [];\n                  var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n                  var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n                  var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";\n                  if (typeof sel.rangeCount != "undefined") {\n                      for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                          rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n                      }\n                  }\n                  return "[" + name + "(Ranges: " + rangeInspects.join(", ") +\n                      ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";\n              };\n              S.prototype.getName = function () {\n                  return "WrappedSelection";\n              };\n              S.prototype.inspect = function () {\n                  return S.inspect(this);\n              };\n              S.prototype.detach = function () {\n                  actOnCachedSelection(this.win, "delete");\n                  deleteProperties(this);\n              };\n              S.detachAll = function () {\n                  actOnCachedSelection(null, "deleteAll");\n              };\n              return S;\n          }(Base)),\n          _a.isDirectionBackward = isDirectionBackward,\n          _a;\n  }\n  var WrappedSelection = createWrappedSelection(WrappedSelBase);\n  //alias\n  var Selection = WrappedSelection;\n  function shimGetSelection(win) {\n      if (!win)\n          win = window;\n      if (typeof win.getSelection == "undefined") {\n          win.getSelection = function () {\n              return getSelection(win);\n          };\n      }\n  }\n\n  // https://medium.com/visual-development/how-to-fix-nasty-circular-dependency-issues-once-and-for-all-in-javascript-typescript-a04c987cf0de\n\n  /**\n   * Rangy, a cross-browser JavaScript range and selection library\n   * https://github.com/timdown/rangy\n   *\n   * Copyright 2019, Tim Down\n   * Licensed under the MIT license.\n   * Version: 2.1.0\n   * Build date: 19 April 2019\n   */\n  function shim(win) {\n      win = win || window;\n      shimCreateRange(win);\n      shimGetSelection(win);\n  }\n\n  exports.DOMException = DOMException;\n  exports.DomRange = DomRange;\n  exports.Module = Module;\n  exports.RangeBase = RangeBase;\n  exports.Selection = Selection;\n  exports.WrappedRange = WrappedRange;\n  exports.WrappedSelection = WrappedSelection;\n  exports.config = config;\n  exports.createNativeRange = createNativeRange;\n  exports.createPrototypeRange = createPrototypeRange;\n  exports.createRange = createRange;\n  exports.createRangyRange = createRangyRange;\n  exports.dom = dom;\n  exports.features = features;\n  exports.getNativeSelection = getNativeSelection;\n  exports.getRangeDocument = getRangeDocument;\n  exports.getSelection = getSelection;\n  exports.isBrowser = isBrowser;\n  exports.isSelectionValid = isSelectionValid;\n  exports.onDocReady = onDocReady;\n  exports.rangesEqual = rangesEqual;\n  exports.shim = shim;\n  exports.shimCreateRange = shimCreateRange;\n  exports.shimGetSelection = shimGetSelection;\n  exports.util = util;\n  exports.version = version;\n\n  Object.defineProperty(exports, \'__esModule\', { value: true });\n\n}));\n//# sourceMappingURL=index.umd.js.map\n\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/bundles/index.umd.js?')},"./node_modules/rangy2/esm5/DOMException.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "DOMException": () => (/* binding */ DOMException)\n/* harmony export */ });\nfunction DOMException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = "DOMException: " + this.codeName;\n}\nDOMException.prototype = {\n    INDEX_SIZE_ERR: 1,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INVALID_STATE_ERR: 11,\n    INVALID_NODE_TYPE_ERR: 24,\n};\n//Object.assign(DOMException, DOMException.prototype);\nDOMException.prototype.toString = function () {\n    return this.message;\n};\n//# sourceMappingURL=DOMException.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/DOMException.js?')},"./node_modules/rangy2/esm5/api.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "version": () => (/* binding */ version),\n/* harmony export */   "isBrowser": () => (/* binding */ isBrowser),\n/* harmony export */   "features": () => (/* binding */ features),\n/* harmony export */   "config": () => (/* binding */ config),\n/* harmony export */   "onDocReady": () => (/* binding */ onDocReady)\n/* harmony export */ });\nvar UNDEF = "undefined";\nvar version = "%%build:version%%";\nvar isBrowser = typeof window != UNDEF && typeof document != UNDEF;\nif (!isBrowser) {\n    console.log("Rangy can only run in a browser");\n}\nvar features = {\n    implementsDomRange: true,\n    implementsTextRange: false,\n    htmlParsingConforms: true,\n    crashyTextNodes: false,\n    implementsWinGetSelection: true,\n    implementsDocSelection: false,\n    selectionSupportsMultipleRanges: false,\n    implementsControlRange: false,\n};\n/** @deprecated all configs is const! */\nvar config = {\n    preferTextRange: false,\n    checkSelectionRanges: true,\n};\n// RangePrototype,\n// rangePrototype: new RangePrototype(),\n// selectionPrototype: new SelectionPrototype(),\nfunction onDocReady(listener) {\n    if (!isBrowser)\n        return;\n    if (document.readyState == "complete") {\n        listener();\n    }\n    else {\n        var onLoaded_1 = function () {\n            document.removeEventListener("DOMContentLoaded", onLoaded_1, false);\n            listener();\n        };\n        document.addEventListener("DOMContentLoaded", onLoaded_1, false);\n    }\n}\n//# sourceMappingURL=api.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/api.js?')},"./node_modules/rangy2/esm5/dom.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBody": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.getBody),\n/* harmony export */   "isHtmlNamespace": () => (/* binding */ isHtmlNamespace),\n/* harmony export */   "parentElement": () => (/* binding */ parentElement),\n/* harmony export */   "getNodeIndex": () => (/* binding */ getNodeIndex),\n/* harmony export */   "getNodeLength": () => (/* binding */ getNodeLength),\n/* harmony export */   "getCommonAncestor": () => (/* binding */ getCommonAncestor),\n/* harmony export */   "isAncestorOf": () => (/* binding */ isAncestorOf),\n/* harmony export */   "isOrIsAncestorOf": () => (/* binding */ isOrIsAncestorOf),\n/* harmony export */   "getClosestAncestorIn": () => (/* binding */ getClosestAncestorIn),\n/* harmony export */   "isCharacterDataNode": () => (/* binding */ isCharacterDataNode),\n/* harmony export */   "isTextOrCommentNode": () => (/* binding */ isTextOrCommentNode),\n/* harmony export */   "insertAfter": () => (/* binding */ insertAfter),\n/* harmony export */   "splitDataNode": () => (/* binding */ splitDataNode),\n/* harmony export */   "getDocument": () => (/* binding */ getDocument),\n/* harmony export */   "getWindow": () => (/* binding */ getWindow),\n/* harmony export */   "getIframeDocument": () => (/* binding */ getIframeDocument),\n/* harmony export */   "getIframeWindow": () => (/* binding */ getIframeWindow),\n/* harmony export */   "isWindow": () => (/* binding */ isWindow),\n/* harmony export */   "getContentDocument": () => (/* binding */ getContentDocument),\n/* harmony export */   "getRootContainer": () => (/* binding */ getRootContainer),\n/* harmony export */   "comparePoints": () => (/* binding */ comparePoints),\n/* harmony export */   "inspectNode": () => (/* binding */ inspectNode),\n/* harmony export */   "fragmentFromNodeChildren": () => (/* binding */ fragmentFromNodeChildren),\n/* harmony export */   "getComputedStyleProperty": () => (/* binding */ getComputedStyleProperty),\n/* harmony export */   "createTestElement": () => (/* binding */ createTestElement),\n/* harmony export */   "removeNode": () => (/* binding */ removeNode),\n/* harmony export */   "NodeIterator": () => (/* binding */ NodeIterator),\n/* harmony export */   "createIterator": () => (/* binding */ createIterator),\n/* harmony export */   "DomPosition": () => (/* binding */ DomPosition)\n/* harmony export */ });\n/* harmony import */ var _module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module */ "./node_modules/rangy2/esm5/module.js");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/rangy2/esm5/util.js");\n\n\n\n// import * as log4javascript from "log4javascript";\n\nvar module = new _module__WEBPACK_IMPORTED_MODULE_0__.Module("DomUtil", []);\n// DOM utility methods used by Rangy\n// /* build:replaceWith(api) */rangy/* build:replaceEnd */.createCoreModule("DomUtil", [], function(api, module) {\n// var log = log4javascript.getLogger("rangy.dom");\nvar UNDEF = "undefined";\n// Perform feature tests\nif (!_util__WEBPACK_IMPORTED_MODULE_1__.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {\n    module.fail("document missing a Node creation method");\n}\nif (!_util__WEBPACK_IMPORTED_MODULE_1__.isHostMethod(document, "getElementsByTagName")) {\n    module.fail("document missing getElementsByTagName method");\n}\n/*----------------------------------------------------------------------------------------------------------------*/\n// Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\nfunction isHtmlNamespace(node) {\n    var ns;\n    return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");\n}\nfunction parentElement(node) {\n    var parent = node.parentNode;\n    return (parent.nodeType == 1) ? parent : null;\n}\nfunction getNodeIndex(node) {\n    var i = 0;\n    while ((node = node.previousSibling)) {\n        ++i;\n    }\n    return i;\n}\nfunction getNodeLength(node) {\n    switch (node.nodeType) {\n        case 7:\n        case 10:\n            return 0;\n        case 3:\n        case 8:\n            return node.length;\n        default:\n            return node.childNodes.length;\n    }\n}\nfunction getCommonAncestor(node1, node2) {\n    var ancestors = [], n;\n    for (n = node1; n; n = n.parentNode) {\n        ancestors.push(n);\n    }\n    for (n = node2; n; n = n.parentNode) {\n        if (ancestors.includes(n)) {\n            return n;\n        }\n    }\n    return null;\n}\nfunction isAncestorOf(ancestor, descendant, selfIsAncestor) {\n    var n = selfIsAncestor ? descendant : descendant.parentNode;\n    while (n) {\n        if (n === ancestor) {\n            return true;\n        }\n        else {\n            n = n.parentNode;\n        }\n    }\n    return false;\n}\nfunction isOrIsAncestorOf(ancestor, descendant) {\n    return isAncestorOf(ancestor, descendant, true);\n}\nfunction getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n    var p, n = selfIsAncestor ? node : node.parentNode;\n    while (n) {\n        p = n.parentNode;\n        if (p === ancestor) {\n            return n;\n        }\n        n = p;\n    }\n    return null;\n}\n// https://basarat.gitbooks.io/typescript/docs/types/typeGuard.html#user-defined-type-guards\nfunction isCharacterDataNode(node) {\n    var t = node.nodeType;\n    return t == 3 || t == 4 || t == 8; // Text, CDataSection or Comment\n}\nfunction isTextOrCommentNode(node) {\n    if (!node) {\n        return false;\n    }\n    var t = node.nodeType;\n    return t == 3 || t == 8; // Text or Comment\n}\nfunction insertAfter(node, precedingNode) {\n    var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;\n    if (nextNode) {\n        parent.insertBefore(node, nextNode);\n    }\n    else {\n        parent.appendChild(node);\n    }\n    return node;\n}\n// Note that we cannot use splitText() because it is bugridden in IE 9.\nfunction splitDataNode(node, index, positionsToPreserve) {\n    // log.debug("splitDataNode called at index " + index + " in node " + inspectNode(node));\n    var newNode = node.cloneNode(false);\n    newNode.deleteData(0, index);\n    node.deleteData(index, node.length - index);\n    insertAfter(newNode, node);\n    // Preserve positions\n    if (positionsToPreserve) {\n        for (var i = 0, position; position = positionsToPreserve[i++];) {\n            // Handle case where position was inside the portion of node after the split point\n            if (position.node == node && position.offset > index) {\n                position.node = newNode;\n                position.offset -= index;\n            }\n            // Handle the case where the position is a node offset within node\'s parent\n            else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {\n                ++position.offset;\n            }\n        }\n    }\n    return newNode;\n}\nfunction getDocument(node) {\n    if (node.nodeType == 9) {\n        return node;\n    }\n    else if (typeof node.ownerDocument != UNDEF) {\n        return node.ownerDocument;\n    }\n    else if (typeof node.document != UNDEF) {\n        return node.document;\n    }\n    else if (node.parentNode) {\n        return getDocument(node.parentNode);\n    }\n    else {\n        throw module.createError("getDocument: no document found for node");\n    }\n}\nfunction getWindow(node) {\n    var doc = getDocument(node);\n    if (typeof doc.defaultView != UNDEF) {\n        return doc.defaultView;\n    }\n    else if (typeof doc.parentWindow != UNDEF) {\n        return doc.parentWindow;\n    }\n    else {\n        throw module.createError("Cannot get a window object for node");\n    }\n}\nfunction getIframeDocument(iframeEl) {\n    if (typeof iframeEl.contentDocument != UNDEF) {\n        return iframeEl.contentDocument;\n    }\n    else if (typeof iframeEl.contentWindow != UNDEF) {\n        return iframeEl.contentWindow.document;\n    }\n    else {\n        throw module.createError("getIframeDocument: No Document object found for iframe element");\n    }\n}\nfunction getIframeWindow(iframeEl) {\n    if (typeof iframeEl.contentWindow != UNDEF) {\n        return iframeEl.contentWindow;\n    }\n    else if (typeof iframeEl.contentDocument != UNDEF) {\n        return iframeEl.contentDocument.defaultView;\n    }\n    else {\n        throw module.createError("getIframeWindow: No Window object found for iframe element");\n    }\n}\n// This looks bad. Is it worth it?\nfunction isWindow(obj) {\n    return obj && _util__WEBPACK_IMPORTED_MODULE_1__.isHostMethod(obj, "setTimeout") && _util__WEBPACK_IMPORTED_MODULE_1__.isHostObject(obj, "document");\n}\nfunction isIframe(o) {\n    return o.nodeType == 1 && o.tagName.toLowerCase() == "iframe";\n}\nfunction getContentDocument(obj, module, methodName) {\n    var doc;\n    if (!obj) {\n        doc = document;\n    }\n    // Test if a DOM node has been passed and obtain a document object for it if so\n    else if (_util__WEBPACK_IMPORTED_MODULE_1__.isHostProperty(obj, "nodeType")) {\n        doc = isIframe(obj) ? getIframeDocument(obj) : getDocument(obj);\n    }\n    // Test if the doc parameter appears to be a Window object\n    else if (isWindow(obj)) {\n        doc = obj.document;\n    }\n    if (!doc) {\n        throw module.createError(methodName + "(): Parameter must be a Window object or DOM node");\n    }\n    return doc;\n}\nfunction getRootContainer(node) {\n    var parent;\n    while ((parent = node.parentNode)) {\n        node = parent;\n    }\n    return node;\n}\nfunction comparePoints(nodeA, offsetA, nodeB, offsetB) {\n    // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n    var nodeC, root, childA, childB, n;\n    if (nodeA == nodeB) {\n        // log.debug("case 1");\n        // Case 1: nodes are the same\n        return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;\n    }\n    else if ((nodeC = getClosestAncestorIn(nodeB, nodeA, true))) {\n        // log.debug("case 2", inspectNode(nodeC), getNodeIndex(nodeC));\n        // Case 2: node C (container B or an ancestor) is a child node of A\n        return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n    }\n    else if ((nodeC = getClosestAncestorIn(nodeA, nodeB, true))) {\n        // log.debug("case 3");\n        // Case 3: node C (container A or an ancestor) is a child node of B\n        return getNodeIndex(nodeC) < offsetB ? -1 : 1;\n    }\n    else {\n        root = getCommonAncestor(nodeA, nodeB);\n        if (!root) {\n            throw new Error("comparePoints error: nodes have no common ancestor");\n        }\n        // Case 4: containers are siblings or descendants of siblings\n        // log.debug("case 4");\n        childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);\n        childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);\n        if (childA === childB) {\n            // This shouldn\'t be possible\n            // log.warn("comparePoints got to case 4 and childA and childB are the same!", nodeA, offsetA, nodeB, offsetB);\n            throw module.createError("comparePoints got to case 4 and childA and childB are the same!");\n        }\n        else {\n            n = root.firstChild;\n            while (n) {\n                if (n === childA) {\n                    return -1;\n                }\n                else if (n === childB) {\n                    return 1;\n                }\n                n = n.nextSibling;\n            }\n        }\n    }\n}\nfunction inspectNode(node) {\n    if (!node) {\n        return "[No node]";\n    }\n    if (isCharacterDataNode(node)) {\n        return \'"\' + node.data + \'"\';\n    }\n    if (node.nodeType == 1) {\n        var idAttr = node.id ? \' id="\' + node.id + \'"\' : "";\n        return "<" + node.nodeName + idAttr +\n            ">[index:" + getNodeIndex(node) +\n            ",length:" + node.childNodes.length + "][" +\n            (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";\n    }\n    return node.nodeName;\n}\nfunction fragmentFromNodeChildren(node) {\n    var fragment = getDocument(node).createDocumentFragment(), child;\n    while ((child = node.firstChild)) {\n        fragment.appendChild(child);\n    }\n    return fragment;\n}\nvar _getComputedStyleProperty;\nif (typeof window.getComputedStyle != UNDEF) {\n    _getComputedStyleProperty = function (el, propName) {\n        return getWindow(el).getComputedStyle(el, null)[propName];\n    };\n}\nelse if (typeof document.documentElement.currentStyle != UNDEF) {\n    _getComputedStyleProperty = function (el, propName) {\n        return el.currentStyle ? el.currentStyle[propName] : "";\n    };\n}\nelse {\n    module.fail("No means of obtaining computed style properties found");\n}\nvar getComputedStyleProperty = _getComputedStyleProperty;\nfunction createTestElement(doc, html, contentEditable) {\n    var body = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getBody)(doc);\n    var el = doc.createElement("div");\n    el.contentEditable = "" + !!contentEditable;\n    if (html) {\n        el.innerHTML = html;\n    }\n    // Insert the test element at the start of the body to prevent scrolling to the bottom in iOS (issue #292)\n    var bodyFirstChild = body.firstChild;\n    if (bodyFirstChild) {\n        body.insertBefore(el, bodyFirstChild);\n    }\n    else {\n        body.appendChild(el);\n    }\n    return el;\n}\nfunction removeNode(node) {\n    return node.parentNode.removeChild(node);\n}\nvar NodeIterator = /** @class */ (function () {\n    function NodeIterator(root) {\n        this.root = root;\n        this._next = root;\n    }\n    NodeIterator.prototype.hasNext = function () {\n        return !!this._next;\n    };\n    NodeIterator.prototype.next = function () {\n        var n = NodeIterator._current = this._next;\n        var child, next;\n        if (NodeIterator._current) {\n            child = n.firstChild;\n            if (child) {\n                this._next = child;\n            }\n            else {\n                next = null;\n                while ((n !== this.root) && !(next = n.nextSibling)) {\n                    n = n.parentNode;\n                }\n                this._next = next;\n            }\n        }\n        return NodeIterator._current;\n    };\n    NodeIterator.prototype.detach = function () {\n        NodeIterator._current = this._next = this.root = null;\n    };\n    NodeIterator._current = null;\n    return NodeIterator;\n}());\n\nfunction createIterator(root) {\n    return new NodeIterator(root);\n}\nvar DomPosition = /** @class */ (function () {\n    function DomPosition(node, offset) {\n        this.node = node;\n        this.offset = offset;\n    }\n    DomPosition.prototype.equals = function (pos) {\n        return !!pos && this.node === pos.node && this.offset == pos.offset;\n    };\n    DomPosition.prototype.inspect = function () {\n        return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";\n    };\n    DomPosition.prototype.toString = function () {\n        return this.inspect();\n    };\n    return DomPosition;\n}());\n\n//# sourceMappingURL=dom.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/dom.js?')},"./node_modules/rangy2/esm5/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "config": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_2__.config),\n/* harmony export */   "features": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_2__.features),\n/* harmony export */   "isBrowser": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_2__.isBrowser),\n/* harmony export */   "onDocReady": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_2__.onDocReady),\n/* harmony export */   "version": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_2__.version),\n/* harmony export */   "util": () => (/* reexport module object */ _util__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   "Module": () => (/* reexport safe */ _module__WEBPACK_IMPORTED_MODULE_4__.Module),\n/* harmony export */   "DOMException": () => (/* reexport safe */ _DOMException__WEBPACK_IMPORTED_MODULE_5__.DOMException),\n/* harmony export */   "dom": () => (/* reexport module object */ _dom__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   "DomRange": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.DomRange),\n/* harmony export */   "RangeBase": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.RangeBase),\n/* harmony export */   "Selection": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.Selection),\n/* harmony export */   "WrappedRange": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.WrappedRange),\n/* harmony export */   "WrappedSelection": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.WrappedSelection),\n/* harmony export */   "createNativeRange": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.createNativeRange),\n/* harmony export */   "createPrototypeRange": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.createPrototypeRange),\n/* harmony export */   "createRange": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.createRange),\n/* harmony export */   "createRangyRange": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.createRangyRange),\n/* harmony export */   "getNativeSelection": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.getNativeSelection),\n/* harmony export */   "getRangeDocument": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.getRangeDocument),\n/* harmony export */   "getSelection": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.getSelection),\n/* harmony export */   "isSelectionValid": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.isSelectionValid),\n/* harmony export */   "rangesEqual": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.rangesEqual),\n/* harmony export */   "shimCreateRange": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.shimCreateRange),\n/* harmony export */   "shimGetSelection": () => (/* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_7__.shimGetSelection),\n/* harmony export */   "shim": () => (/* binding */ shim)\n/* harmony export */ });\n/* harmony import */ var core_js_features_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/features/array/includes */ "./node_modules/core-js/features/array/includes.js");\n/* harmony import */ var core_js_features_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_features_array_includes__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var core_js_features_object_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/features/object/assign */ "./node_modules/core-js/features/object/assign.js");\n/* harmony import */ var core_js_features_object_assign__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_features_object_assign__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api */ "./node_modules/rangy2/esm5/api.js");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/rangy2/esm5/util.js");\n/* harmony import */ var _module__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./module */ "./node_modules/rangy2/esm5/module.js");\n/* harmony import */ var _DOMException__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DOMException */ "./node_modules/rangy2/esm5/DOMException.js");\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom */ "./node_modules/rangy2/esm5/dom.js");\n/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./internal */ "./node_modules/rangy2/esm5/internal/index.js");\n/**\n * Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Copyright %%build:year%%, Tim Down\n * Licensed under the MIT license.\n * Version: %%build:version%%\n * Build date: %%build:date%%\n */\n\n\n\n\n\n\n\n\n\n\n\nfunction shim(win) {\n    win = win || window;\n    (0,_internal__WEBPACK_IMPORTED_MODULE_7__.shimCreateRange)(win);\n    (0,_internal__WEBPACK_IMPORTED_MODULE_7__.shimGetSelection)(win);\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/index.js?')},"./node_modules/rangy2/esm5/internal/_.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "DomRange": () => (/* reexport safe */ _domrange_index__WEBPACK_IMPORTED_MODULE_0__.DomRange),\n/* harmony export */   "RangeBase": () => (/* reexport safe */ _domrange_index__WEBPACK_IMPORTED_MODULE_0__.RangeBase),\n/* harmony export */   "createPrototypeRange": () => (/* reexport safe */ _domrange_index__WEBPACK_IMPORTED_MODULE_0__.createPrototypeRange),\n/* harmony export */   "createRangyRange": () => (/* reexport safe */ _domrange_index__WEBPACK_IMPORTED_MODULE_0__.createRangyRange),\n/* harmony export */   "getRangeDocument": () => (/* reexport safe */ _domrange_index__WEBPACK_IMPORTED_MODULE_0__.getRangeDocument),\n/* harmony export */   "rangeProperties": () => (/* reexport safe */ _domrange_index__WEBPACK_IMPORTED_MODULE_0__.rangeProperties),\n/* harmony export */   "rangesEqual": () => (/* reexport safe */ _domrange_index__WEBPACK_IMPORTED_MODULE_0__.rangesEqual),\n/* harmony export */   "WrappedRange": () => (/* reexport safe */ _wrappedrange__WEBPACK_IMPORTED_MODULE_1__.WrappedRange),\n/* harmony export */   "createNativeRange": () => (/* reexport safe */ _wrappedrange__WEBPACK_IMPORTED_MODULE_1__.createNativeRange),\n/* harmony export */   "createRange": () => (/* reexport safe */ _wrappedrange__WEBPACK_IMPORTED_MODULE_1__.createRange),\n/* harmony export */   "shimCreateRange": () => (/* reexport safe */ _wrappedrange__WEBPACK_IMPORTED_MODULE_1__.shimCreateRange),\n/* harmony export */   "Selection": () => (/* reexport safe */ _wrappedselection__WEBPACK_IMPORTED_MODULE_2__.Selection),\n/* harmony export */   "WrappedSelBase": () => (/* reexport safe */ _wrappedselection__WEBPACK_IMPORTED_MODULE_2__.WrappedSelBase),\n/* harmony export */   "WrappedSelection": () => (/* reexport safe */ _wrappedselection__WEBPACK_IMPORTED_MODULE_2__.WrappedSelection),\n/* harmony export */   "getNativeSelection": () => (/* reexport safe */ _wrappedselection__WEBPACK_IMPORTED_MODULE_2__.getNativeSelection),\n/* harmony export */   "getSelection": () => (/* reexport safe */ _wrappedselection__WEBPACK_IMPORTED_MODULE_2__.getSelection),\n/* harmony export */   "isSelectionValid": () => (/* reexport safe */ _wrappedselection__WEBPACK_IMPORTED_MODULE_2__.isSelectionValid),\n/* harmony export */   "shimGetSelection": () => (/* reexport safe */ _wrappedselection__WEBPACK_IMPORTED_MODULE_2__.shimGetSelection)\n/* harmony export */ });\n/* harmony import */ var _domrange_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./domrange/index */ "./node_modules/rangy2/esm5/internal/domrange/index.js");\n/* harmony import */ var _wrappedrange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrappedrange */ "./node_modules/rangy2/esm5/internal/wrappedrange.js");\n/* harmony import */ var _wrappedselection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrappedselection */ "./node_modules/rangy2/esm5/internal/wrappedselection.js");\n// https://medium.com/visual-development/how-to-fix-nasty-circular-dependency-issues-once-and-for-all-in-javascript-typescript-a04c987cf0de\n// domrange, wrappedrange, wrappedselection are circularly depended on each other\n// In consumer\'s code, pls import \'internal\' instead of importing directly from those 3 modules.\n\n\n\n//# sourceMappingURL=_.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/internal/_.js?')},"./node_modules/rangy2/esm5/internal/domrange/RangeIterator.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "RangeIterator": () => (/* binding */ RangeIterator),\n/* harmony export */   "cloneSubtree": () => (/* binding */ cloneSubtree),\n/* harmony export */   "iterateSubtree": () => (/* binding */ iterateSubtree),\n/* harmony export */   "deleteSubtree": () => (/* binding */ deleteSubtree),\n/* harmony export */   "extractSubtree": () => (/* binding */ extractSubtree)\n/* harmony export */ });\n/* harmony import */ var _DOMException__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../DOMException */ "./node_modules/rangy2/esm5/DOMException.js");\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom */ "./node_modules/rangy2/esm5/dom.js");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_ */ "./node_modules/rangy2/esm5/internal/domrange/_.js");\n// RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n\n\n\n// import * as log4javascript from "log4javascript";\n// var log = log4javascript.getLogger("RangeIterator");\nvar RangeIterator = /** @class */ (function () {\n    function RangeIterator(range, clonePartiallySelectedTextNodes) {\n        this.range = range;\n        this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n        // TODO the following properties are migrated from RangeIterator.prototype\n        // now, those are in RangeIterator\'s instance\n        // so we can remove `detach` method\n        this._current = null;\n        this._next = null;\n        this._first = null;\n        this._last = null;\n        this.isSingleCharacterDataNode = false;\n        // log.info("New RangeIterator ", dom.inspectNode(range.startContainer), range.startOffset, dom.inspectNode(range.endContainer), range.endOffset);\n        if (!range.collapsed) {\n            this.sc = range.startContainer;\n            this.so = range.startOffset;\n            this.ec = range.endContainer;\n            this.eo = range.endOffset;\n            var root = range.commonAncestorContainer;\n            if (this.sc === this.ec && (0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(this.sc)) {\n                this.isSingleCharacterDataNode = true;\n                this._first = this._last = this._next = this.sc;\n            }\n            else {\n                this._first = this._next = (this.sc === root && !(0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(this.sc)) ?\n                    this.sc.childNodes[this.so] : (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getClosestAncestorIn)(this.sc, root, true);\n                this._last = (this.ec === root && !(0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(this.ec)) ?\n                    this.ec.childNodes[this.eo - 1] : (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getClosestAncestorIn)(this.ec, root, true);\n            }\n            // log.info("RangeIterator first and last", dom.inspectNode(this._first), dom.inspectNode(this._last));\n        }\n    }\n    RangeIterator.prototype.reset = function () {\n        this._current = null;\n        this._next = this._first;\n    };\n    RangeIterator.prototype.hasNext = function () {\n        return !!this._next;\n    };\n    RangeIterator.prototype.detach = function () {\n        this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n    };\n    RangeIterator.prototype.next = function () {\n        // Move to next node\n        var current = this._current = this._next;\n        if (current) {\n            this._next = (current !== this._last) ? current.nextSibling : null;\n            // Check for partially selected text nodes\n            if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(current) && this.clonePartiallySelectedTextNodes) {\n                if (current === this.ec) {\n                    current = current.cloneNode(true);\n                    current.deleteData(this.eo, current.length - this.eo);\n                }\n                if (this._current === this.sc) {\n                    current = current.cloneNode(true);\n                    current.deleteData(0, this.so);\n                }\n            }\n        }\n        return current;\n    };\n    RangeIterator.prototype.remove = function () {\n        var current = this._current, start, end;\n        if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(current) && (current === this.sc || current === this.ec)) {\n            start = (current === this.sc) ? this.so : 0;\n            end = (current === this.ec) ? this.eo : current.length;\n            if (start != end) {\n                current.deleteData(start, end - start);\n            }\n        }\n        else {\n            if (current.parentNode) {\n                (0,_dom__WEBPACK_IMPORTED_MODULE_1__.removeNode)(current);\n            }\n            else {\n                // log.warn("Node to be removed has no parent node. Is this the child of an attribute node in Firefox 2?");\n            }\n        }\n    };\n    // Checks if the current node is partially selected\n    RangeIterator.prototype.isPartiallySelectedSubtree = function () {\n        var current = this._current;\n        return (0,___WEBPACK_IMPORTED_MODULE_2__.isNonTextPartiallySelected)(current, this.range);\n    };\n    RangeIterator.prototype.getSubtreeIterator = function () {\n        var subRange;\n        if (this.isSingleCharacterDataNode) {\n            subRange = this.range.cloneRange();\n            subRange.collapse(false);\n        }\n        else {\n            subRange = new ___WEBPACK_IMPORTED_MODULE_2__.DomRange((0,___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument)(this.range));\n            var current = this._current;\n            var startContainer = current, startOffset = 0, endContainer = current, endOffset = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeLength)(current);\n            if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isOrIsAncestorOf)(current, this.sc)) {\n                startContainer = this.sc;\n                startOffset = this.so;\n            }\n            if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isOrIsAncestorOf)(current, this.ec)) {\n                endContainer = this.ec;\n                endOffset = this.eo;\n            }\n            (0,___WEBPACK_IMPORTED_MODULE_2__.updateBoundaries)(subRange, startContainer, startOffset, endContainer, endOffset);\n        }\n        return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n    };\n    return RangeIterator;\n}()); // RangeIterator\n\nfunction cloneSubtree(iterator) {\n    var partiallySelected;\n    for (var node, frag = (0,___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument)(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n        partiallySelected = iterator.isPartiallySelectedSubtree();\n        // log.debug("cloneSubtree got node " + dom.inspectNode(node) + " from iterator. partiallySelected: " + partiallySelected);\n        node = node.cloneNode(!partiallySelected);\n        if (partiallySelected) {\n            subIterator = iterator.getSubtreeIterator();\n            node.appendChild(cloneSubtree(subIterator));\n            subIterator.detach();\n        }\n        if (node.nodeType == 10) { // DocumentType\n            throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("HIERARCHY_REQUEST_ERR");\n        }\n        frag.appendChild(node);\n    }\n    return frag;\n}\nfunction iterateSubtree(iterator, func, iteratorState) {\n    if (iteratorState === void 0) { iteratorState = { stop: false }; }\n    var it, n;\n    for (var node, subIterator; node = iterator.next();) {\n        if (iterator.isPartiallySelectedSubtree()) {\n            if (func(node) === false) {\n                iteratorState.stop = true;\n                return;\n            }\n            else {\n                // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of\n                // the node selected by the Range.\n                subIterator = iterator.getSubtreeIterator();\n                iterateSubtree(subIterator, func, iteratorState);\n                subIterator.detach();\n                if (iteratorState.stop) {\n                    return;\n                }\n            }\n        }\n        else {\n            // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n            // descendants\n            it = _dom__WEBPACK_IMPORTED_MODULE_1__.createIterator(node);\n            while ((n = it.next())) {\n                if (func(n) === false) {\n                    iteratorState.stop = true;\n                    return;\n                }\n            }\n        }\n    }\n}\nfunction deleteSubtree(iterator) {\n    var subIterator;\n    while (iterator.next()) {\n        if (iterator.isPartiallySelectedSubtree()) {\n            subIterator = iterator.getSubtreeIterator();\n            deleteSubtree(subIterator);\n            subIterator.detach();\n        }\n        else {\n            iterator.remove();\n        }\n    }\n}\nfunction extractSubtree(iterator) {\n    // log.debug("extract on iterator", iterator);\n    for (var node, frag = (0,___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument)(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n        // log.debug("extractSubtree got node " + dom.inspectNode(node) + " from iterator. partiallySelected: " + iterator.isPartiallySelectedSubtree());\n        if (iterator.isPartiallySelectedSubtree()) {\n            node = node.cloneNode(false);\n            subIterator = iterator.getSubtreeIterator();\n            node.appendChild(extractSubtree(subIterator));\n            subIterator.detach();\n        }\n        else {\n            iterator.remove();\n        }\n        if (node.nodeType == 10) { // DocumentType\n            throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("HIERARCHY_REQUEST_ERR");\n        }\n        frag.appendChild(node);\n    }\n    return frag;\n}\n//# sourceMappingURL=RangeIterator.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/internal/domrange/RangeIterator.js?')},"./node_modules/rangy2/esm5/internal/domrange/_.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "DomRangeBase": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.DomRangeBase),\n/* harmony export */   "RangeBase": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.RangeBase),\n/* harmony export */   "assertNoDocTypeNotationEntityAncestor": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.assertNoDocTypeNotationEntityAncestor),\n/* harmony export */   "assertNode": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.assertNode),\n/* harmony export */   "assertNodeNotReadOnly": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.assertNodeNotReadOnly),\n/* harmony export */   "assertRangeValid": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.assertRangeValid),\n/* harmony export */   "assertSameDocumentOrFragment": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.assertSameDocumentOrFragment),\n/* harmony export */   "assertValidNodeType": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.assertValidNodeType),\n/* harmony export */   "assertValidOffset": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.assertValidOffset),\n/* harmony export */   "beforeAfterNodeTypes": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.beforeAfterNodeTypes),\n/* harmony export */   "getElementAncestor": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.getElementAncestor),\n/* harmony export */   "getRangeDocument": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.getRangeDocument),\n/* harmony export */   "insertableNodeTypes": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.insertableNodeTypes),\n/* harmony export */   "isNonTextPartiallySelected": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.isNonTextPartiallySelected),\n/* harmony export */   "isRangeValid": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.isRangeValid),\n/* harmony export */   "rangeProperties": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.rangeProperties),\n/* harmony export */   "rootContainerNodeTypes": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.rootContainerNodeTypes),\n/* harmony export */   "surroundNodeTypes": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.surroundNodeTypes),\n/* harmony export */   "updateBoundaries": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.updateBoundaries),\n/* harmony export */   "RangeIterator": () => (/* reexport safe */ _RangeIterator__WEBPACK_IMPORTED_MODULE_1__.RangeIterator),\n/* harmony export */   "cloneSubtree": () => (/* reexport safe */ _RangeIterator__WEBPACK_IMPORTED_MODULE_1__.cloneSubtree),\n/* harmony export */   "deleteSubtree": () => (/* reexport safe */ _RangeIterator__WEBPACK_IMPORTED_MODULE_1__.deleteSubtree),\n/* harmony export */   "extractSubtree": () => (/* reexport safe */ _RangeIterator__WEBPACK_IMPORTED_MODULE_1__.extractSubtree),\n/* harmony export */   "iterateSubtree": () => (/* reexport safe */ _RangeIterator__WEBPACK_IMPORTED_MODULE_1__.iterateSubtree),\n/* harmony export */   "comparisonConstants": () => (/* reexport safe */ _part1__WEBPACK_IMPORTED_MODULE_2__.comparisonConstants),\n/* harmony export */   "copyComparisonConstants": () => (/* reexport safe */ _part1__WEBPACK_IMPORTED_MODULE_2__.copyComparisonConstants),\n/* harmony export */   "createDomRangeP1": () => (/* reexport safe */ _part1__WEBPACK_IMPORTED_MODULE_2__.createDomRangeP1),\n/* harmony export */   "rangeInspect": () => (/* reexport safe */ _part1__WEBPACK_IMPORTED_MODULE_2__.rangeInspect),\n/* harmony export */   "rangeToHtml": () => (/* reexport safe */ _part1__WEBPACK_IMPORTED_MODULE_2__.rangeToHtml),\n/* harmony export */   "rangesEqual": () => (/* reexport safe */ _part1__WEBPACK_IMPORTED_MODULE_2__.rangesEqual),\n/* harmony export */   "DomRange": () => (/* reexport safe */ _part2__WEBPACK_IMPORTED_MODULE_3__.DomRange),\n/* harmony export */   "createPrototypeRange": () => (/* reexport safe */ _part2__WEBPACK_IMPORTED_MODULE_3__.createPrototypeRange),\n/* harmony export */   "createRangyRange": () => (/* reexport safe */ _part2__WEBPACK_IMPORTED_MODULE_3__.createRangyRange)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/rangy2/esm5/internal/domrange/util.js");\n/* harmony import */ var _RangeIterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RangeIterator */ "./node_modules/rangy2/esm5/internal/domrange/RangeIterator.js");\n/* harmony import */ var _part1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./part1 */ "./node_modules/rangy2/esm5/internal/domrange/part1.js");\n/* harmony import */ var _part2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./part2 */ "./node_modules/rangy2/esm5/internal/domrange/part2.js");\n// https://medium.com/visual-development/how-to-fix-nasty-circular-dependency-issues-once-and-for-all-in-javascript-typescript-a04c987cf0de\n\n\n\n\n//# sourceMappingURL=_.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/internal/domrange/_.js?')},"./node_modules/rangy2/esm5/internal/domrange/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rangeProperties": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.rangeProperties),\n/* harmony export */   "RangeBase": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.RangeBase),\n/* harmony export */   "rangesEqual": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.rangesEqual),\n/* harmony export */   "getRangeDocument": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.getRangeDocument),\n/* harmony export */   "createPrototypeRange": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.createPrototypeRange),\n/* harmony export */   "DomRange": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.DomRange),\n/* harmony export */   "createRangyRange": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.createRangyRange)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ */ "./node_modules/rangy2/esm5/internal/domrange/_.js");\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/internal/domrange/index.js?')},"./node_modules/rangy2/esm5/internal/domrange/part1.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rangeInspect": () => (/* binding */ rangeInspect),\n/* harmony export */   "rangeToHtml": () => (/* binding */ rangeToHtml),\n/* harmony export */   "comparisonConstants": () => (/* binding */ comparisonConstants),\n/* harmony export */   "copyComparisonConstants": () => (/* binding */ copyComparisonConstants),\n/* harmony export */   "createDomRangeP1": () => (/* binding */ createDomRangeP1),\n/* harmony export */   "rangesEqual": () => (/* binding */ rangesEqual)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _DOMException__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../DOMException */ "./node_modules/rangy2/esm5/DOMException.js");\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom */ "./node_modules/rangy2/esm5/dom.js");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_ */ "./node_modules/rangy2/esm5/internal/domrange/_.js");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../_ */ "./node_modules/rangy2/esm5/internal/_.js");\n\n\n\n\n\n\n// import * as log4javascript from "log4javascript";\n// var log = log4javascript.getLogger("DomRangeBase");\nfunction getRangeRoot(range) {\n    return (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getRootContainer)(range.startContainer);\n}\nfunction insertNodeAtPosition(node, n, o) {\n    var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n    if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(n)) {\n        if (o == n.length) {\n            _dom__WEBPACK_IMPORTED_MODULE_1__.insertAfter(node, n);\n        }\n        else {\n            n.parentNode.insertBefore(node, o == 0 ? n : (0,_dom__WEBPACK_IMPORTED_MODULE_1__.splitDataNode)(n, o));\n        }\n    }\n    else if (o >= n.childNodes.length) {\n        n.appendChild(node);\n    }\n    else {\n        n.insertBefore(node, n.childNodes[o]);\n    }\n    return firstNodeInserted;\n}\nfunction rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {\n    (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(rangeA);\n    (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(rangeB);\n    if ((0,___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument)(rangeB) != (0,___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument)(rangeA)) {\n        throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("WRONG_DOCUMENT_ERR");\n    }\n    var startComparison = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset), endComparison = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);\n    return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n}\nfunction getNodesInRange(range, nodeTypes, filter) {\n    var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;\n    var filterExists = !!filter;\n    if (filterNodeTypes) {\n        regex = new RegExp("^(" + nodeTypes.join("|") + ")$");\n    }\n    var nodes = [];\n    (0,___WEBPACK_IMPORTED_MODULE_2__.iterateSubtree)(new ___WEBPACK_IMPORTED_MODULE_2__.RangeIterator(range, false), function (node) {\n        if (filterNodeTypes && !regex.test(node.nodeType.toString())) {\n            return;\n        }\n        if (filterExists && !filter(node)) {\n            return;\n        }\n        // Don\'t include a boundary container if it is a character data node and the range does not contain any\n        // of its character data. See issue 190.\n        var sc = range.startContainer;\n        if (node == sc && (0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(sc) && range.startOffset == sc.length) {\n            return;\n        }\n        var ec = range.endContainer;\n        if (node == ec && (0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(ec) && range.endOffset == 0) {\n            return;\n        }\n        nodes.push(node);\n    });\n    return nodes;\n}\nfunction rangeInspect(range) {\n    var name = (typeof range.getName == "undefined") ? "Range" : range.getName();\n    return "[" + name + "(" + _dom__WEBPACK_IMPORTED_MODULE_1__.inspectNode(range.startContainer) + ":" + range.startOffset + ", " +\n        _dom__WEBPACK_IMPORTED_MODULE_1__.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";\n}\nfunction rangeToHtml(range) {\n    (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(range);\n    var container = range.commonAncestorContainer.parentNode.cloneNode(false);\n    container.appendChild(range.cloneContents());\n    return container.innerHTML;\n}\n/*----------------------------------------------------------------------------------------------------------------*/\nvar s2s = 0, s2e = 1, e2e = 2, e2s = 3;\nvar n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;\nvar comparisonConstants = {\n    START_TO_START: s2s,\n    START_TO_END: s2e,\n    END_TO_END: e2e,\n    END_TO_START: e2s,\n    NODE_BEFORE: n_b,\n    NODE_AFTER: n_a,\n    NODE_BEFORE_AND_AFTER: n_b_a,\n    NODE_INSIDE: n_i,\n};\n/**\n * @deprecated please replace by: `class C extends createPrototypeRange(..){..} Object.assign(C, comparisonConstants)`\n * @param C constructor (a class)\n */\nfunction copyComparisonConstants(C) {\n    Object.assign(C, comparisonConstants);\n    Object.assign(C.prototype, comparisonConstants);\n}\n/*----------------------------------------------------------------------------------------------------------------*/\nfunction createDomRangeP1(Base) {\n    return /** @class */ (function (_super) {\n        tslib__WEBPACK_IMPORTED_MODULE_4__.__extends(class_1, _super);\n        function class_1() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        class_1.prototype.compareBoundaryPoints = function (how, range) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertSameDocumentOrFragment)(this.startContainer, range.startContainer);\n            var nodeA, offsetA, nodeB, offsetB;\n            var prefixA = (how == e2s || how == s2s) ? "start" : "end";\n            var prefixB = (how == s2e || how == s2s) ? "start" : "end";\n            nodeA = this[prefixA + "Container"];\n            offsetA = this[prefixA + "Offset"];\n            nodeB = range[prefixB + "Container"];\n            offsetB = range[prefixB + "Offset"];\n            return (0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(nodeA, offsetA, nodeB, offsetB);\n        };\n        class_1.prototype.insertNode = function (node) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertValidNodeType)(node, ___WEBPACK_IMPORTED_MODULE_2__.insertableNodeTypes);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNodeNotReadOnly)(this.startContainer);\n            if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isOrIsAncestorOf)(node, this.startContainer)) {\n                throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("HIERARCHY_REQUEST_ERR");\n            }\n            // No check for whether the container of the start of the Range is of a type that does not allow\n            // children of the type of node: the browser\'s DOM implementation should do this for us when we attempt\n            // to add the node\n            var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n            this.setStartBefore(firstNodeInserted);\n        };\n        class_1.prototype.cloneContents = function () {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            var clone, frag;\n            if (this.collapsed) {\n                return (0,___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument)(this).createDocumentFragment();\n            }\n            else {\n                if (this.startContainer === this.endContainer && (0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(this.startContainer)) {\n                    clone = this.startContainer.cloneNode(true);\n                    clone.data = clone.data.slice(this.startOffset, this.endOffset);\n                    frag = (0,___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument)(this).createDocumentFragment();\n                    frag.appendChild(clone);\n                    return frag;\n                }\n                else {\n                    var iterator = new ___WEBPACK_IMPORTED_MODULE_2__.RangeIterator(this, true);\n                    clone = (0,___WEBPACK_IMPORTED_MODULE_2__.cloneSubtree)(iterator);\n                    iterator.detach();\n                }\n                return clone;\n            }\n        };\n        class_1.prototype.canSurroundContents = function () {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNodeNotReadOnly)(this.startContainer);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNodeNotReadOnly)(this.endContainer);\n            // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n            // no non-text nodes.\n            // see https://developer.mozilla.org/en-US/docs/Web/API/Range/surroundContents\n            var iterator = new ___WEBPACK_IMPORTED_MODULE_2__.RangeIterator(this, true);\n            var boundariesInvalid = (iterator._first && (0,___WEBPACK_IMPORTED_MODULE_2__.isNonTextPartiallySelected)(iterator._first, this) ||\n                (iterator._last && (0,___WEBPACK_IMPORTED_MODULE_2__.isNonTextPartiallySelected)(iterator._last, this)));\n            iterator.detach();\n            return !boundariesInvalid;\n        };\n        class_1.prototype.surroundContents = function (newParent) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertValidNodeType)(newParent, ___WEBPACK_IMPORTED_MODULE_2__.surroundNodeTypes);\n            if (!this.canSurroundContents()) {\n                throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("INVALID_STATE_ERR");\n            }\n            // Extract the contents\n            var content = this.extractContents();\n            // Clear the children of the node\n            if (newParent.hasChildNodes()) {\n                while (newParent.lastChild) {\n                    newParent.removeChild(newParent.lastChild);\n                }\n            }\n            // Insert the new node and add the extracted contents\n            insertNodeAtPosition(newParent, this.startContainer, this.startOffset);\n            newParent.appendChild(content);\n            this.selectNode(newParent);\n        };\n        class_1.prototype.cloneRange = function () {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            var range = new ___WEBPACK_IMPORTED_MODULE_2__.DomRange((0,___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument)(this));\n            for (var _i = 0, rangeProperties_1 = ___WEBPACK_IMPORTED_MODULE_2__.rangeProperties; _i < rangeProperties_1.length; _i++) {\n                var prop = rangeProperties_1[_i];\n                range[prop] = this[prop];\n            }\n            return range;\n        };\n        class_1.prototype.toString = function () {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            var sc = this.startContainer;\n            if (sc === this.endContainer && (0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(sc)) {\n                return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";\n            }\n            else {\n                var textParts = [], iterator = new ___WEBPACK_IMPORTED_MODULE_2__.RangeIterator(this, true);\n                // log.info("toString iterator: " + dom.inspectNode(iterator._first) + ", " + dom.inspectNode(iterator._last));\n                (0,___WEBPACK_IMPORTED_MODULE_2__.iterateSubtree)(iterator, function (node) {\n                    // Accept only text or CDATA nodes, not comments\n                    if (node.nodeType == 3 || node.nodeType == 4) {\n                        textParts.push(node.data);\n                    }\n                });\n                iterator.detach();\n                return textParts.join("");\n            }\n        };\n        // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n        // been removed from Mozilla.\n        class_1.prototype.compareNode = function (node) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            var parent = node.parentNode;\n            var nodeIndex = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeIndex)(node);\n            if (!parent) {\n                throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("NOT_FOUND_ERR");\n            }\n            var startComparison = this.comparePoint(parent, nodeIndex), endComparison = this.comparePoint(parent, nodeIndex + 1);\n            if (startComparison < 0) { // Node starts before\n                return (endComparison > 0) ? n_b_a : n_b;\n            }\n            else {\n                return (endComparison > 0) ? n_a : n_i;\n            }\n        };\n        /**\n         * Returns −1 if the point is before the range, 0 if the point is\n         * in the range, and 1 if the point is after the range.\n         */\n        class_1.prototype.comparePoint = function (node, offset) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNode)(node, "HIERARCHY_REQUEST_ERR");\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertSameDocumentOrFragment)(node, this.startContainer);\n            if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(node, offset, this.startContainer, this.startOffset) < 0) {\n                return -1;\n            }\n            else if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(node, offset, this.endContainer, this.endOffset) > 0) {\n                return 1;\n            }\n            return 0;\n        };\n        // Implementation as per HTML parsing spec, trusting in the browser\'s implementation of innerHTML. See\n        // discussion and base code for this implementation at issue 67.\n        // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n        // Thanks to Aleks Williams.\n        class_1.prototype.createContextualFragment = function (fragment) {\n            // "Let node the context object\'s start\'s node."\n            var node = this.startContainer;\n            var doc = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getDocument)(node);\n            // "If the context object\'s start\'s node is null, raise an INVALID_STATE_ERR\n            // exception and abort these steps."\n            if (!node) {\n                throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("INVALID_STATE_ERR");\n            }\n            // "Let element be as follows, depending on node\'s interface:"\n            // Document, Document Fragment: null\n            var el = null;\n            // "Element: node"\n            if (node.nodeType == 1) {\n                el = node;\n                // "Text, Comment: node\'s parentElement"\n            }\n            else if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(node)) {\n                el = _dom__WEBPACK_IMPORTED_MODULE_1__.parentElement(node);\n            }\n            // "If either element is null or element\'s ownerDocument is an HTML document\n            // and element\'s local name is "html" and element\'s namespace is the HTML\n            // namespace"\n            if (el === null || (el.nodeName == "HTML" &&\n                _dom__WEBPACK_IMPORTED_MODULE_1__.isHtmlNamespace((0,_dom__WEBPACK_IMPORTED_MODULE_1__.getDocument)(el).documentElement) &&\n                _dom__WEBPACK_IMPORTED_MODULE_1__.isHtmlNamespace(el))) {\n                // "let element be a new Element with "body" as its local name and the HTML\n                // namespace as its namespace.""\n                el = doc.createElement("body");\n            }\n            else {\n                el = el.cloneNode(false);\n            }\n            // "If the node\'s document is an HTML document: Invoke the HTML fragment parsing algorithm."\n            // "If the node\'s document is an XML document: Invoke the XML fragment parsing algorithm."\n            // "In either case, the algorithm must be invoked with fragment as the input\n            // and element as the context element."\n            el.innerHTML = fragment;\n            // "If this raises an exception, then abort these steps. Otherwise, let new\n            // children be the nodes returned."\n            // "Let fragment be a new DocumentFragment."\n            // "Append all new children to fragment."\n            // "Return fragment."\n            return _dom__WEBPACK_IMPORTED_MODULE_1__.fragmentFromNodeChildren(el);\n        };\n        class_1.prototype.toHtml = function () {\n            return rangeToHtml(this);\n        };\n        // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n        // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n        class_1.prototype.intersectsNode = function (node, touchingIsIntersecting) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.getRootContainer)(node) != getRangeRoot(this)) {\n                return false;\n            }\n            var parent = node.parentNode, offset = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeIndex)(node);\n            if (!parent) {\n                return true;\n            }\n            var startComparison = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(parent, offset, this.endContainer, this.endOffset), endComparison = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(parent, offset + 1, this.startContainer, this.startOffset);\n            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n        };\n        class_1.prototype.isPointInRange = function (node, offset) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNode)(node, "HIERARCHY_REQUEST_ERR");\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertSameDocumentOrFragment)(node, this.startContainer);\n            return ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(node, offset, this.startContainer, this.startOffset) >= 0) &&\n                ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(node, offset, this.endContainer, this.endOffset) <= 0);\n        };\n        // The methods below are non-standard and invented by me.\n        class_1.prototype.intersectsRange = function (range) {\n            return rangesIntersect(this, range, false);\n        };\n        class_1.prototype.intersectsOrTouchesRange = function (range) {\n            return rangesIntersect(this, range, true);\n        };\n        class_1.prototype.intersection = function (range) {\n            if (this.intersectsRange(range)) {\n                var startComparison = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(this.startContainer, this.startOffset, range.startContainer, range.startOffset), endComparison = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n                var intersectionRange = this.cloneRange();\n                // log.info("intersection", this.inspect(), range.inspect(), startComparison, endComparison);\n                if (startComparison == -1) {\n                    intersectionRange.setStart(range.startContainer, range.startOffset);\n                }\n                if (endComparison == 1) {\n                    intersectionRange.setEnd(range.endContainer, range.endOffset);\n                }\n                return intersectionRange;\n            }\n            return null;\n        };\n        class_1.prototype.union = function (range) {\n            if (this.intersectsOrTouchesRange(range)) {\n                var unionRange = this.cloneRange();\n                if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n                    unionRange.setStart(range.startContainer, range.startOffset);\n                }\n                if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n                    unionRange.setEnd(range.endContainer, range.endOffset);\n                }\n                return unionRange;\n            }\n            else {\n                throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("Ranges do not intersect");\n            }\n        };\n        class_1.prototype.containsNode = function (node, allowPartial) {\n            if (allowPartial) {\n                return this.intersectsNode(node, false);\n            }\n            else {\n                return this.compareNode(node) == n_i;\n            }\n        };\n        class_1.prototype.containsNodeContents = function (node) {\n            return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeLength)(node)) <= 0;\n        };\n        class_1.prototype.containsRange = function (range) {\n            var intersection = this.intersection(range);\n            return intersection !== null && range.equals(intersection);\n        };\n        class_1.prototype.containsNodeText = function (node) {\n            var nodeRange = this.cloneRange();\n            nodeRange.selectNode(node);\n            var textNodes = nodeRange.getNodes([3]);\n            if (textNodes.length > 0) {\n                nodeRange.setStart(textNodes[0], 0);\n                var lastTextNode = textNodes.pop();\n                nodeRange.setEnd(lastTextNode, lastTextNode.length);\n                return this.containsRange(nodeRange);\n            }\n            else {\n                return this.containsNodeContents(node);\n            }\n        };\n        class_1.prototype.getNodes = function (nodeTypes, filter) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            return getNodesInRange(this, nodeTypes, filter);\n        };\n        class_1.prototype.getDocument = function () {\n            return (0,___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument)(this);\n        };\n        class_1.prototype.collapseBefore = function (node) {\n            this.setEndBefore(node);\n            this.collapse(false);\n        };\n        class_1.prototype.collapseAfter = function (node) {\n            this.setStartAfter(node);\n            this.collapse(true);\n        };\n        class_1.prototype.getBookmark = function (containerNode) {\n            var doc = (0,___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument)(this);\n            var preSelectionRange = (0,___WEBPACK_IMPORTED_MODULE_3__.createRange)(doc);\n            containerNode = containerNode || _dom__WEBPACK_IMPORTED_MODULE_1__.getBody(doc);\n            preSelectionRange.selectNodeContents(containerNode);\n            var range = this.intersection(preSelectionRange);\n            var start = 0, end = 0;\n            if (range) {\n                preSelectionRange.setEnd(range.startContainer, range.startOffset);\n                start = preSelectionRange.toString().length;\n                end = start + range.toString().length;\n            }\n            return {\n                start: start,\n                end: end,\n                containerNode: containerNode\n            };\n        };\n        class_1.prototype.moveToBookmark = function (bookmark) {\n            var containerNode = bookmark.containerNode;\n            var charIndex = 0;\n            this.setStart(containerNode, 0);\n            this.collapse(true);\n            var nodeStack = [containerNode], node, foundStart = false, stop = false;\n            var nextCharIndex, i, childNodes;\n            while (!stop && (node = nodeStack.pop())) {\n                if (node.nodeType == 3) {\n                    nextCharIndex = charIndex + node.length;\n                    if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {\n                        this.setStart(node, bookmark.start - charIndex);\n                        foundStart = true;\n                    }\n                    if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {\n                        this.setEnd(node, bookmark.end - charIndex);\n                        stop = true;\n                    }\n                    charIndex = nextCharIndex;\n                }\n                else {\n                    childNodes = node.childNodes;\n                    i = childNodes.length;\n                    while (i--) {\n                        nodeStack.push(childNodes[i]);\n                    }\n                }\n            }\n        };\n        class_1.prototype.getName = function () {\n            return "DomRange";\n        };\n        class_1.prototype.equals = function (range) {\n            return rangesEqual(this, range);\n        };\n        class_1.prototype.isValid = function () {\n            return (0,___WEBPACK_IMPORTED_MODULE_2__.isRangeValid)(this);\n        };\n        class_1.prototype.inspect = function () {\n            return rangeInspect(this);\n        };\n        class_1.prototype.detach = function () {\n            // In DOM4, detach() is now a no-op.\n        };\n        // in rangy1, this method is implement in wrappedselection.js\n        // TODO declare in RangeP1Ex\n        class_1.prototype.select = function (direction) {\n            (0,___WEBPACK_IMPORTED_MODULE_3__.getSelection)(this.getDocument()).setSingleRange(this, direction);\n        };\n        return class_1;\n    }(Base));\n} // createDomRangeP1\nfunction rangesEqual(r1, r2) {\n    return r1.startContainer === r2.startContainer &&\n        r1.startOffset === r2.startOffset &&\n        r1.endContainer === r2.endContainer &&\n        r1.endOffset === r2.endOffset;\n}\n//# sourceMappingURL=part1.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/internal/domrange/part1.js?')},"./node_modules/rangy2/esm5/internal/domrange/part2.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createPrototypeRange": () => (/* binding */ createPrototypeRange),\n/* harmony export */   "DomRange": () => (/* binding */ DomRange),\n/* harmony export */   "createRangyRange": () => (/* binding */ createRangyRange)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../module */ "./node_modules/rangy2/esm5/module.js");\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom */ "./node_modules/rangy2/esm5/dom.js");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_ */ "./node_modules/rangy2/esm5/internal/domrange/_.js");\n\n\n\n\n\n// import * as log4javascript from "log4javascript";\n// var log = log4javascript.getLogger("rangy.DomRange");\n// Pure JavaScript implementation of DOM Range\nvar module = new _module__WEBPACK_IMPORTED_MODULE_0__.Module("DomRange", ["DomUtil"]);\n/*----------------------------------------------------------------------------------------------------------------*/\n// Utility functions\nfunction getBoundaryBeforeNode(node) {\n    return new _dom__WEBPACK_IMPORTED_MODULE_1__.DomPosition(node.parentNode, (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeIndex)(node));\n}\nfunction getBoundaryAfterNode(node) {\n    return new _dom__WEBPACK_IMPORTED_MODULE_1__.DomPosition(node.parentNode, (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeIndex)(node) + 1);\n}\nfunction splitRangeBoundaries(range, positionsToPreserve) {\n    (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(range);\n    // log.debug("splitBoundaries called " + range.inspect(), positionsToPreserve);\n    var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;\n    var startEndSame = (sc === ec);\n    if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(ec) && eo > 0 && eo < ec.length) {\n        (0,_dom__WEBPACK_IMPORTED_MODULE_1__.splitDataNode)(ec, eo, positionsToPreserve);\n        // log.debug("Split end", dom.inspectNode(ec), eo);\n    }\n    if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(sc) && so > 0 && so < sc.length) {\n        // log.debug("Splitting start", dom.inspectNode(sc), so);\n        sc = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.splitDataNode)(sc, so, positionsToPreserve);\n        if (startEndSame) {\n            eo -= so;\n            ec = sc;\n        }\n        else if (ec == sc.parentNode && eo >= (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeIndex)(sc)) {\n            eo++;\n        }\n        so = 0;\n        // log.debug("Split start", dom.inspectNode(sc), so);\n    }\n    range.setStartAndEnd(sc, so, ec, eo);\n    // log.debug("splitBoundaries done");\n}\n/*----------------------------------------------------------------------------------------------------------------*/\nfunction createRangeContentRemover(remover, boundaryUpdater) {\n    return function () {\n        (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n        var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;\n        var iterator = new ___WEBPACK_IMPORTED_MODULE_2__.RangeIterator(this, true);\n        // Work out where to position the range after content removal\n        var node, boundary;\n        if (sc !== root) {\n            node = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getClosestAncestorIn)(sc, root, true);\n            boundary = getBoundaryAfterNode(node);\n            sc = boundary.node;\n            so = boundary.offset;\n        }\n        // Check none of the range is read-only\n        (0,___WEBPACK_IMPORTED_MODULE_2__.iterateSubtree)(iterator, ___WEBPACK_IMPORTED_MODULE_2__.assertNodeNotReadOnly);\n        iterator.reset();\n        // Remove the content\n        var returnValue = remover(iterator);\n        iterator.detach();\n        // Move to the new position\n        boundaryUpdater(this, sc, so, sc, so);\n        return returnValue;\n    };\n}\n// https://mariusschulz.com/blog/typescript-2-2-mixin-classes\nfunction createDomRangeP2(Base, boundaryUpdater) {\n    function createBeforeAfterNodeSetter(isBefore, isStart) {\n        return function (node) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertValidNodeType)(node, ___WEBPACK_IMPORTED_MODULE_2__.beforeAfterNodeTypes);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertValidNodeType)((0,_dom__WEBPACK_IMPORTED_MODULE_1__.getRootContainer)(node), ___WEBPACK_IMPORTED_MODULE_2__.rootContainerNodeTypes);\n            var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n            (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n        };\n    }\n    function setRangeStart(range, node, offset) {\n        var ec = range.endContainer, eo = range.endOffset;\n        if (node !== range.startContainer || offset !== range.startOffset) {\n            // Check the root containers of the range and the new boundary, and also check whether the new boundary\n            // is after the current end. In either case, collapse the range to the new position\n            if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.getRootContainer)(node) != (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getRootContainer)(ec) || (0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(node, offset, ec, eo) == 1) {\n                ec = node;\n                eo = offset;\n            }\n            boundaryUpdater(range, node, offset, ec, eo);\n        }\n    }\n    function setRangeEnd(range, node, offset) {\n        var sc = range.startContainer, so = range.startOffset;\n        if (node !== range.endContainer || offset !== range.endOffset) {\n            // Check the root containers of the range and the new boundary, and also check whether the new boundary\n            // is after the current end. In either case, collapse the range to the new position\n            if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.getRootContainer)(node) != (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getRootContainer)(sc) || (0,_dom__WEBPACK_IMPORTED_MODULE_1__.comparePoints)(node, offset, sc, so) == -1) {\n                sc = node;\n                so = offset;\n            }\n            boundaryUpdater(range, sc, so, node, offset);\n        }\n    }\n    /*\n            // Set up inheritance\n            var F = function() {};\n            F.prototype = api.rangePrototype;\n            Base.prototype = new F();\n    \n            util.extend(Base.prototype, {\n               ...\n            });\n    */\n    return /** @class */ (function (_super) {\n        tslib__WEBPACK_IMPORTED_MODULE_3__.__extends(class_1, _super);\n        function class_1() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.setStartBefore = createBeforeAfterNodeSetter(true, true);\n            _this.setStartAfter = createBeforeAfterNodeSetter(false, true);\n            _this.setEndBefore = createBeforeAfterNodeSetter(true, false);\n            _this.setEndAfter = createBeforeAfterNodeSetter(false, false);\n            _this.extractContents = createRangeContentRemover(___WEBPACK_IMPORTED_MODULE_2__.extractSubtree, boundaryUpdater);\n            _this.deleteContents = createRangeContentRemover(___WEBPACK_IMPORTED_MODULE_2__.deleteSubtree, boundaryUpdater);\n            return _this;\n        }\n        class_1.prototype.setStart = function (node, offset) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNoDocTypeNotationEntityAncestor)(node, true);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertValidOffset)(node, offset);\n            setRangeStart(this, node, offset);\n        };\n        class_1.prototype.setEnd = function (node, offset) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNoDocTypeNotationEntityAncestor)(node, true);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertValidOffset)(node, offset);\n            setRangeEnd(this, node, offset);\n        };\n        class_1.prototype.setStartAndEnd = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var sc = args[0], so = args[1], ec = sc, eo = so;\n            switch (args.length) {\n                case 3:\n                    eo = args[2];\n                    break;\n                case 4:\n                    ec = args[2];\n                    eo = args[3];\n                    break;\n            }\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNoDocTypeNotationEntityAncestor)(sc, true);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertValidOffset)(sc, so);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNoDocTypeNotationEntityAncestor)(ec, true);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertValidOffset)(ec, eo);\n            boundaryUpdater(this, sc, so, ec, eo);\n        };\n        class_1.prototype.setBoundary = function (node, offset, isStart) {\n            this["set" + (isStart ? "Start" : "End")](node, offset);\n        };\n        class_1.prototype.collapse = function (toStart) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            if (toStart) {\n                boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n            }\n            else {\n                boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n            }\n        };\n        class_1.prototype.selectNodeContents = function (node) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNoDocTypeNotationEntityAncestor)(node, true);\n            boundaryUpdater(this, node, 0, node, (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeLength)(node));\n        };\n        class_1.prototype.selectNode = function (node) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNoDocTypeNotationEntityAncestor)(node, false);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertValidNodeType)(node, ___WEBPACK_IMPORTED_MODULE_2__.beforeAfterNodeTypes);\n            var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);\n            boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n        };\n        class_1.prototype.splitBoundaries = function () {\n            splitRangeBoundaries(this);\n        };\n        class_1.prototype.splitBoundariesPreservingPositions = function (positionsToPreserve) {\n            splitRangeBoundaries(this, positionsToPreserve);\n        };\n        class_1.prototype.normalizeBoundaries = function () {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;\n            var mergeForward = function (node) {\n                var sibling = node.nextSibling;\n                if (sibling && sibling.nodeType == node.nodeType) {\n                    ec = node;\n                    eo = node.length;\n                    node.appendData(sibling.data);\n                    (0,_dom__WEBPACK_IMPORTED_MODULE_1__.removeNode)(sibling);\n                }\n            };\n            var mergeBackward = function (node) {\n                var sibling = node.previousSibling;\n                if (sibling && sibling.nodeType == node.nodeType) {\n                    sc = node;\n                    var nodeLength = node.length;\n                    so = sibling.length;\n                    node.insertData(0, sibling.data);\n                    (0,_dom__WEBPACK_IMPORTED_MODULE_1__.removeNode)(sibling);\n                    if (sc == ec) {\n                        eo += so;\n                        ec = sc;\n                    }\n                    else if (ec == node.parentNode) {\n                        var nodeIndex = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeIndex)(node);\n                        if (eo == nodeIndex) {\n                            ec = node;\n                            eo = nodeLength;\n                        }\n                        else if (eo > nodeIndex) {\n                            eo--;\n                        }\n                    }\n                }\n            };\n            var normalizeStart = true;\n            var sibling;\n            if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(ec)) {\n                if (eo == ec.length) {\n                    mergeForward(ec);\n                }\n                else if (eo == 0) {\n                    sibling = ec.previousSibling;\n                    if (sibling && sibling.nodeType == ec.nodeType) {\n                        eo = sibling.length;\n                        if (sc == ec) {\n                            normalizeStart = false;\n                        }\n                        sibling.appendData(ec.data);\n                        (0,_dom__WEBPACK_IMPORTED_MODULE_1__.removeNode)(ec);\n                        ec = sibling;\n                    }\n                }\n            }\n            else {\n                if (eo > 0) {\n                    var endNode = ec.childNodes[eo - 1];\n                    if (endNode && (0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(endNode)) {\n                        mergeForward(endNode);\n                    }\n                }\n                normalizeStart = !this.collapsed;\n            }\n            if (normalizeStart) {\n                if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(sc)) {\n                    if (so == 0) {\n                        mergeBackward(sc);\n                    }\n                    else if (so == sc.length) {\n                        sibling = sc.nextSibling;\n                        if (sibling && sibling.nodeType == sc.nodeType) {\n                            if (ec == sibling) {\n                                ec = sc;\n                                eo += sc.length;\n                            }\n                            sc.appendData(sibling.data);\n                            (0,_dom__WEBPACK_IMPORTED_MODULE_1__.removeNode)(sibling);\n                        }\n                    }\n                }\n                else {\n                    if (so < sc.childNodes.length) {\n                        var startNode = sc.childNodes[so];\n                        if (startNode && (0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(startNode)) {\n                            mergeBackward(startNode);\n                        }\n                    }\n                }\n            }\n            else {\n                sc = ec;\n                so = eo;\n            }\n            boundaryUpdater(this, sc, so, ec, eo);\n        };\n        class_1.prototype.collapseToPoint = function (node, offset) {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertNoDocTypeNotationEntityAncestor)(node, true);\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertValidOffset)(node, offset);\n            this.setStartAndEnd(node, offset);\n        };\n        class_1.prototype.parentElement = function () {\n            (0,___WEBPACK_IMPORTED_MODULE_2__.assertRangeValid)(this);\n            return (0,___WEBPACK_IMPORTED_MODULE_2__.getElementAncestor)(this.commonAncestorContainer, true);\n        };\n        return class_1;\n    }(Base));\n}\n/*----------------------------------------------------------------------------------------------------------------*/\n/** TODO remove comment\n * @requires call `Object.assign(R, comparisonConstants)` after call this function:\n *      `class R extends createPrototypeRange(..`\n * or\n *      `const R = createPrototypeRange(..`\n */\nfunction createPrototypeRange(Base, boundaryUpdater) {\n    // R1 is a not completed class because createDomRangeP1 only implement RangeP1\n    // the missing members in RangeP2 will be provided at createDomRangeP2\n    // and the missing members in ComparisonConstants will be provided here in `createPrototypeRange`\n    // so result `R12` will be a completed class that implement `Range`\n    var MixinBase = Base;\n    var R1 = (0,___WEBPACK_IMPORTED_MODULE_2__.createDomRangeP1)(MixinBase);\n    //after this, instances of R1 will have consts like: START_TO_START,..\n    Object.assign(R1.prototype, ___WEBPACK_IMPORTED_MODULE_2__.comparisonConstants);\n    var R12 = createDomRangeP2(R1, boundaryUpdater);\n    // this is similar to add `static START_TO_START = ..` into R12\n    // note that, we can ass static members in subclasses: class A{static s = ..} class B extends A{} B.s\n    return Object.assign(R12, ___WEBPACK_IMPORTED_MODULE_2__.comparisonConstants);\n}\n// TODO remove comment\n// we need this const to bypass TS2506: \'DomRange\' is referenced directly or indirectly in it own base expression\n// export const _DomRange = createPrototypeRange(RangeBase, updateBoundaries);\n// export type DomRange = InstanceType<typeof DomRange>;\nvar DomRange = /** @class */ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_3__.__extends(DomRange, _super);\n    function DomRange() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    DomRange.inspect = ___WEBPACK_IMPORTED_MODULE_2__.rangeInspect;\n    DomRange.toHtml = ___WEBPACK_IMPORTED_MODULE_2__.rangeToHtml;\n    DomRange.getRangeDocument = ___WEBPACK_IMPORTED_MODULE_2__.getRangeDocument;\n    DomRange.rangesEqual = ___WEBPACK_IMPORTED_MODULE_2__.rangesEqual;\n    return DomRange;\n}(createPrototypeRange(___WEBPACK_IMPORTED_MODULE_2__.DomRangeBase, ___WEBPACK_IMPORTED_MODULE_2__.updateBoundaries)));\n\n// @deprecated pls directly import & use the exported member of this module\nObject.assign(DomRange, {\n    rangeProperties: ___WEBPACK_IMPORTED_MODULE_2__.rangeProperties,\n    RangeIterator: ___WEBPACK_IMPORTED_MODULE_2__.RangeIterator,\n    copyComparisonConstants: ___WEBPACK_IMPORTED_MODULE_2__.copyComparisonConstants,\n    createPrototypeRange: createPrototypeRange,\n});\nfunction createRangyRange(doc) {\n    doc = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getContentDocument)(doc, module, "createRangyRange");\n    return new DomRange(doc);\n}\n//# sourceMappingURL=part2.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/internal/domrange/part2.js?')},"./node_modules/rangy2/esm5/internal/domrange/util.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isNonTextPartiallySelected": () => (/* binding */ isNonTextPartiallySelected),\n/* harmony export */   "beforeAfterNodeTypes": () => (/* binding */ beforeAfterNodeTypes),\n/* harmony export */   "rootContainerNodeTypes": () => (/* binding */ rootContainerNodeTypes),\n/* harmony export */   "insertableNodeTypes": () => (/* binding */ insertableNodeTypes),\n/* harmony export */   "surroundNodeTypes": () => (/* binding */ surroundNodeTypes),\n/* harmony export */   "getElementAncestor": () => (/* binding */ getElementAncestor),\n/* harmony export */   "assertNoDocTypeNotationEntityAncestor": () => (/* binding */ assertNoDocTypeNotationEntityAncestor),\n/* harmony export */   "assertValidNodeType": () => (/* binding */ assertValidNodeType),\n/* harmony export */   "assertValidOffset": () => (/* binding */ assertValidOffset),\n/* harmony export */   "assertSameDocumentOrFragment": () => (/* binding */ assertSameDocumentOrFragment),\n/* harmony export */   "assertNodeNotReadOnly": () => (/* binding */ assertNodeNotReadOnly),\n/* harmony export */   "assertNode": () => (/* binding */ assertNode),\n/* harmony export */   "isRangeValid": () => (/* binding */ isRangeValid),\n/* harmony export */   "assertRangeValid": () => (/* binding */ assertRangeValid),\n/* harmony export */   "getRangeDocument": () => (/* binding */ getRangeDocument),\n/* harmony export */   "updateBoundaries": () => (/* binding */ updateBoundaries),\n/* harmony export */   "rangeProperties": () => (/* binding */ rangeProperties),\n/* harmony export */   "RangeBase": () => (/* binding */ RangeBase),\n/* harmony export */   "DomRangeBase": () => (/* binding */ DomRangeBase)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _DOMException__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../DOMException */ "./node_modules/rangy2/esm5/DOMException.js");\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom */ "./node_modules/rangy2/esm5/dom.js");\n\n\n\n\nfunction isNonTextPartiallySelected(node, range) {\n    return (node.nodeType != 3) &&\n        ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isOrIsAncestorOf)(node, range.startContainer) || (0,_dom__WEBPACK_IMPORTED_MODULE_1__.isOrIsAncestorOf)(node, range.endContainer));\n}\n/*----------------------------------------------------------------------------------------------------------------*/\nvar beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\nvar rootContainerNodeTypes = [2, 9, 11];\nvar readonlyNodeTypes = [5, 6, 10, 12];\nvar insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\nvar surroundNodeTypes = [1, 3, 4, 5, 7, 8];\nfunction createAncestorFinder(nodeTypes) {\n    return function (node, selfIsAncestor) {\n        var t, n = selfIsAncestor ? node : node.parentNode;\n        while (n) {\n            t = n.nodeType;\n            if (nodeTypes.includes(t)) {\n                return n;\n            }\n            n = n.parentNode;\n        }\n        return null;\n    };\n}\nvar getDocumentOrFragmentContainer = createAncestorFinder([9, 11]);\nvar getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\nvar getDocTypeNotationEntityAncestor = createAncestorFinder([6, 10, 12]);\nvar getElementAncestor = createAncestorFinder([1]);\nfunction assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n    if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n        throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("INVALID_NODE_TYPE_ERR");\n    }\n}\nfunction assertValidNodeType(node, invalidTypes) {\n    if (!invalidTypes.includes(node.nodeType)) {\n        throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("INVALID_NODE_TYPE_ERR");\n    }\n}\nfunction assertValidOffset(node, offset) {\n    if (offset < 0 || offset > ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(node) ? node.length : node.childNodes.length)) {\n        throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("INDEX_SIZE_ERR");\n    }\n}\nfunction assertSameDocumentOrFragment(node1, node2) {\n    if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n        throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("WRONG_DOCUMENT_ERR");\n    }\n}\nfunction assertNodeNotReadOnly(node) {\n    if (getReadonlyAncestor(node, true)) {\n        throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException("NO_MODIFICATION_ALLOWED_ERR");\n    }\n}\nfunction assertNode(node, codeName) {\n    if (!node) {\n        throw new _DOMException__WEBPACK_IMPORTED_MODULE_0__.DOMException(codeName);\n    }\n}\nfunction isValidOffset(node, offset) {\n    return offset <= ((0,_dom__WEBPACK_IMPORTED_MODULE_1__.isCharacterDataNode)(node) ? node.length : node.childNodes.length);\n}\nfunction isRangeValid(range) {\n    return (!!range.startContainer && !!range.endContainer &&\n        (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getRootContainer)(range.startContainer) == (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getRootContainer)(range.endContainer) &&\n        isValidOffset(range.startContainer, range.startOffset) &&\n        isValidOffset(range.endContainer, range.endOffset));\n}\nfunction assertRangeValid(range) {\n    if (!isRangeValid(range)) {\n        throw new Error("Range error: Range is not valid. This usually happens after DOM mutation. Range: (" + range.inspect() + ")");\n    }\n}\n/*----------------------------------------------------------------------------------------------------------------*/\nfunction getRangeDocument(range) {\n    return range.document || (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getDocument)(range.startContainer);\n}\n// Updates commonAncestorContainer and collapsed after boundary change\nfunction updateCollapsedAndCommonAncestor(range) {\n    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n    range.commonAncestorContainer = range.collapsed ?\n        range.startContainer : _dom__WEBPACK_IMPORTED_MODULE_1__.getCommonAncestor(range.startContainer, range.endContainer);\n}\nfunction updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n    range.startContainer = startContainer;\n    range.startOffset = startOffset;\n    range.endContainer = endContainer;\n    range.endOffset = endOffset;\n    range.document = _dom__WEBPACK_IMPORTED_MODULE_1__.getDocument(startContainer);\n    updateCollapsedAndCommonAncestor(range);\n}\nvar rangeProperties = [\n    "startContainer",\n    "startOffset",\n    "endContainer",\n    "endOffset",\n    "collapsed",\n    "commonAncestorContainer"\n];\n// note RangeBase\'s method list == const rangeProperties above\nvar RangeBase = /** @class */ (function () {\n    function RangeBase() {\n    }\n    return RangeBase;\n}());\n\nvar DomRangeBase = /** @class */ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_2__.__extends(DomRangeBase, _super);\n    function DomRangeBase(doc) {\n        var _this = _super.call(this) || this;\n        updateBoundaries(_this, doc, 0, doc, 0);\n        return _this;\n    }\n    return DomRangeBase;\n}(RangeBase));\n\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/internal/domrange/util.js?')},"./node_modules/rangy2/esm5/internal/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "RangeBase": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.RangeBase),\n/* harmony export */   "rangesEqual": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.rangesEqual),\n/* harmony export */   "getRangeDocument": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.getRangeDocument),\n/* harmony export */   "createPrototypeRange": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.createPrototypeRange),\n/* harmony export */   "DomRange": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.DomRange),\n/* harmony export */   "createRangyRange": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.createRangyRange),\n/* harmony export */   "WrappedRange": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.WrappedRange),\n/* harmony export */   "createNativeRange": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.createNativeRange),\n/* harmony export */   "createRange": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.createRange),\n/* harmony export */   "shimCreateRange": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.shimCreateRange),\n/* harmony export */   "getNativeSelection": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.getNativeSelection),\n/* harmony export */   "isSelectionValid": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.isSelectionValid),\n/* harmony export */   "getSelection": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.getSelection),\n/* harmony export */   "Selection": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.Selection),\n/* harmony export */   "WrappedSelection": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.WrappedSelection),\n/* harmony export */   "shimGetSelection": () => (/* reexport safe */ ___WEBPACK_IMPORTED_MODULE_0__.shimGetSelection)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ */ "./node_modules/rangy2/esm5/internal/_.js");\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/internal/index.js?')},"./node_modules/rangy2/esm5/internal/wrappedrange.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "WrappedRange": () => (/* binding */ WrappedRange),\n/* harmony export */   "createNativeRange": () => (/* binding */ createNativeRange),\n/* harmony export */   "createRange": () => (/* binding */ createRange),\n/* harmony export */   "shimCreateRange": () => (/* binding */ shimCreateRange)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/rangy2/esm5/util.js");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api */ "./node_modules/rangy2/esm5/api.js");\n/* harmony import */ var _module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../module */ "./node_modules/rangy2/esm5/module.js");\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom */ "./node_modules/rangy2/esm5/dom.js");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_ */ "./node_modules/rangy2/esm5/internal/_.js");\n\n\n\n\n\n\n// import * as log4javascript from "log4javascript";\nvar module = new _module__WEBPACK_IMPORTED_MODULE_2__.Module("WrappedRange", ["DomRange"]);\n// Wrappers for the browser\'s native DOM Range implementation\n// /* build:replaceWith(api) */rangy/* build:replaceEnd */.createCoreModule("WrappedRange", ["DomRange"], function(api, module) {\n// var log = log4javascript.getLogger("rangy.WrappedRange");\n/*----------------------------------------------------------------------------------------------------------------*/\n// if (api.features.implementsDomRange) {\n// This is a wrapper around the browser\'s native DOM Range. It has two aims:\n// - Provide workarounds for specific browser bugs\n// - provide convenient extensions, which are inherited from Rangy\'s DomRange\nfunction updateRangeProperties(range) {\n    for (var _i = 0, rangeProperties_1 = ___WEBPACK_IMPORTED_MODULE_4__.rangeProperties; _i < rangeProperties_1.length; _i++) {\n        var prop = rangeProperties_1[_i];\n        range[prop] = range.nativeRange[prop];\n    }\n    // Fix for broken collapsed property in IE 9.\n    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n}\nfunction updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);\n    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);\n    var nativeRangeDifferent = !range.equals(range.nativeRange);\n    // Always set both boundaries for the benefit of IE9 (see issue 35)\n    if (startMoved || endMoved || nativeRangeDifferent) {\n        range.setEnd(endContainer, endOffset);\n        range.setStart(startContainer, startOffset);\n    }\n}\nvar WrappedRange = /** @class */ (function (_super) {\n    tslib__WEBPACK_IMPORTED_MODULE_5__.__extends(WrappedRange, _super); /*implements WrappedRangeBase*/\n    function WrappedRange(nativeRange) {\n        var _this = _super.call(this) || this;\n        _this.nativeRange = nativeRange;\n        _this.setStartBefore = WrappedRange.createBeforeAfterNodeSetter("setStartBefore");\n        _this.setStartAfter = WrappedRange.createBeforeAfterNodeSetter("setStartAfter");\n        _this.setEndBefore = WrappedRange.createBeforeAfterNodeSetter("setEndBefore");\n        _this.setEndAfter = WrappedRange.createBeforeAfterNodeSetter("setEndAfter");\n        if (!nativeRange) {\n            throw module.createError("WrappedRange: Range must be specified");\n        }\n        updateRangeProperties(_this);\n        return _this;\n    }\n    // nativeRange: Range; //declare here\n    WrappedRange.prototype.selectNode = function (node) {\n        this.nativeRange.selectNode(node);\n        updateRangeProperties(this);\n    };\n    ;\n    WrappedRange.prototype.cloneContents = function () {\n        return this.nativeRange.cloneContents();\n    };\n    ;\n    // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,\n    // insertNode() is never delegated to the native range.\n    WrappedRange.prototype.surroundContents = function (node) {\n        this.nativeRange.surroundContents(node);\n        updateRangeProperties(this);\n    };\n    ;\n    WrappedRange.prototype.collapse = function (isStart) {\n        this.nativeRange.collapse(isStart);\n        updateRangeProperties(this);\n    };\n    ;\n    WrappedRange.prototype.cloneRange = function () {\n        return new WrappedRange(this.nativeRange.cloneRange());\n    };\n    ;\n    WrappedRange.prototype.refresh = function () {\n        updateRangeProperties(this);\n    };\n    ;\n    WrappedRange.prototype.toString = function () {\n        return this.nativeRange.toString();\n    };\n    ;\n    /*--------------------------------------------------------------------------------------------------------*/\n    // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n    // correct for it\n    // note: rangy2 don\'t support Firefox <= 2\n    WrappedRange.prototype.setStart = function (node, offset) {\n        this.nativeRange.setStart(node, offset);\n        updateRangeProperties(this);\n    };\n    ;\n    WrappedRange.prototype.setEnd = function (node, offset) {\n        this.nativeRange.setEnd(node, offset);\n        updateRangeProperties(this);\n    };\n    ;\n    WrappedRange.createBeforeAfterNodeSetter = function (name) {\n        return function (node) {\n            this.nativeRange[name](node);\n            updateRangeProperties(this);\n        };\n    };\n    /*--------------------------------------------------------------------------------------------------------*/\n    // Always use DOM4-compliant selectNodeContents implementation: it\'s simpler and less code than testing\n    // whether the native implementation can be trusted\n    WrappedRange.prototype.selectNodeContents = function (node) {\n        //implement in domrange\n        this.setStartAndEnd(node, 0, (0,_dom__WEBPACK_IMPORTED_MODULE_3__.getNodeLength)(node));\n    };\n    ;\n    /*--------------------------------------------------------------------------------------------------------*/\n    // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for\n    // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n    // note: this bug is fixed in 2008, so rangy2 don\'t test this\n    WrappedRange.prototype.compareBoundaryPoints = function (how, sourceRange) {\n        return this.nativeRange.compareBoundaryPoints(how, sourceRange.nativeRange || sourceRange);\n    };\n    /*--------------------------------------------------------------------------------------------------------*/\n    WrappedRange.prototype.getName = function () {\n        return "WrappedRange";\n    };\n    ;\n    return WrappedRange;\n}((0,___WEBPACK_IMPORTED_MODULE_4__.createPrototypeRange)(___WEBPACK_IMPORTED_MODULE_4__.RangeBase, updateNativeRange) /*implements WrappedRangeBase*/));\n\n// Object.assign(WrappedRange, comparisonConstants);\n// change WrappedRange.{deleteContents, extractContents, createContextualFragment} if need\nfunction docReadyHandler() {\n    // Create test range and node for feature detection\n    var testTextNode = document.createTextNode("test");\n    (0,_dom__WEBPACK_IMPORTED_MODULE_3__.getBody)(document).appendChild(testTextNode);\n    var range = document.createRange();\n    /*--------------------------------------------------------------------------------------------------------*/\n    // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.\n    var el = document.createElement("div");\n    el.innerHTML = "123";\n    var textNode = el.firstChild;\n    var body = (0,_dom__WEBPACK_IMPORTED_MODULE_3__.getBody)(document);\n    body.appendChild(el);\n    range.setStart(textNode, 1);\n    range.setEnd(textNode, 2);\n    range.deleteContents();\n    var rangeProto = WrappedRange.prototype;\n    if (textNode.data == "13") {\n        // Behaviour is correct per DOM4 Range so wrap the browser\'s implementation of deleteContents() and\n        // extractContents()\n        rangeProto.deleteContents = function () {\n            this.nativeRange.deleteContents();\n            updateRangeProperties(this);\n        };\n        rangeProto.extractContents = function () {\n            var frag = this.nativeRange.extractContents();\n            updateRangeProperties(this);\n            return frag;\n        };\n    }\n    else {\n        // log.info("Incorrect native Range deleteContents() implementation. Using Rangy\'s own.");\n    }\n    body.removeChild(el);\n    /*--------------------------------------------------------------------------------------------------------*/\n    // Test for existence of createContextualFragment and delegate to it if it exists\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isHostMethod)(range, "createContextualFragment")) {\n        rangeProto.createContextualFragment = function (fragmentStr) {\n            return this.nativeRange.createContextualFragment(fragmentStr);\n        };\n    }\n    /*--------------------------------------------------------------------------------------------------------*/\n    // Clean up\n    body.removeChild(testTextNode);\n    body = null;\n}\n(0,_api__WEBPACK_IMPORTED_MODULE_1__.onDocReady)(docReadyHandler);\nfunction createNativeRange(doc) {\n    doc = (0,_dom__WEBPACK_IMPORTED_MODULE_3__.getContentDocument)(doc, module, "createNativeRange");\n    return doc.createRange();\n}\n;\nfunction createRange(doc) {\n    doc = (0,_dom__WEBPACK_IMPORTED_MODULE_3__.getContentDocument)(doc, module, "createRange");\n    return new WrappedRange(createNativeRange(doc));\n}\n;\nfunction shimCreateRange(win) {\n    if (!win)\n        win = window;\n    var doc = win.document;\n    if (typeof doc.createRange == "undefined") {\n        doc.createRange = function () {\n            return createRange(doc);\n        };\n    }\n}\n//# sourceMappingURL=wrappedrange.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/internal/wrappedrange.js?')},"./node_modules/rangy2/esm5/internal/wrappedselection.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getNativeSelection": () => (/* binding */ getNativeSelection),\n/* harmony export */   "isSelectionValid": () => (/* binding */ isSelectionValid),\n/* harmony export */   "getSelection": () => (/* binding */ getSelection),\n/* harmony export */   "WrappedSelBase": () => (/* binding */ WrappedSelBase),\n/* harmony export */   "WrappedSelection": () => (/* binding */ WrappedSelection),\n/* harmony export */   "Selection": () => (/* binding */ Selection),\n/* harmony export */   "shimGetSelection": () => (/* binding */ shimGetSelection)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");\n/* harmony import */ var _module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../module */ "./node_modules/rangy2/esm5/module.js");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api */ "./node_modules/rangy2/esm5/api.js");\n/* harmony import */ var _DOMException__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DOMException */ "./node_modules/rangy2/esm5/DOMException.js");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util */ "./node_modules/rangy2/esm5/util.js");\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom */ "./node_modules/rangy2/esm5/dom.js");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_ */ "./node_modules/rangy2/esm5/internal/_.js");\n\n\n\n\n\n\n\n\n\n// import * as log4javascript from "log4javascript";\nvar module = new _module__WEBPACK_IMPORTED_MODULE_0__.Module("WrappedSelection", ["DomRange", "WrappedRange"]);\n// This module creates a selection object wrapper that conforms as closely as possible to the Selection specification\n// in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)\n// /* build:replaceWith(api) */rangy/* build:replaceEnd */.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api, module) {\nvar BOOLEAN = "boolean";\nvar NUMBER = "number";\n// var log = log4javascript.getLogger("rangy.WrappedSelection");\n// Utility function to support direction parameters in the API that may be a string ("backward", "backwards",\n// "forward" or "forwards") or a Boolean (true for backwards).\nfunction isDirectionBackward(dir) {\n    return (typeof dir == "string") ? /^backward(s)?$/i.test(dir) : !!dir;\n}\nfunction getWindow(win, methodName) {\n    if (!win) {\n        return window;\n    }\n    else if (_dom__WEBPACK_IMPORTED_MODULE_4__.isWindow(win)) {\n        return win;\n    }\n    else if (win instanceof WrappedSelection) {\n        return win.win;\n    }\n    else {\n        var doc = _dom__WEBPACK_IMPORTED_MODULE_4__.getContentDocument(win, module, methodName);\n        return _dom__WEBPACK_IMPORTED_MODULE_4__.getWindow(doc);\n    }\n}\nfunction getNativeSelection(winParam) {\n    return getWindow(winParam, "getWinSelection").getSelection();\n}\nfunction winSelectionIsBackward(sel) {\n    var backward = false;\n    if (sel.anchorNode) {\n        backward = (_dom__WEBPACK_IMPORTED_MODULE_4__.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);\n    }\n    return backward;\n}\nvar selectionIsBackward = winSelectionIsBackward;\n/** @deprecated always return true because we don\'t support TextRange / document.selection in old IE */\nfunction isSelectionValid() {\n    return true;\n}\nvar testSelection = getNativeSelection();\n// In Firefox, the selection is null in an iframe with display: none. See issue #138.\nif (!testSelection) {\n    module.fail("Native selection was null (possibly issue 138?)");\n    // return false;\n}\nvar testRange = (0,___WEBPACK_IMPORTED_MODULE_5__.createNativeRange)(document);\n// Obtaining a range from a selection\nvar selectionHasAnchorAndFocus = _api__WEBPACK_IMPORTED_MODULE_1__.features.selectionHasAnchorAndFocus =\n    _util__WEBPACK_IMPORTED_MODULE_3__.areHostProperties(testSelection, ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);\n// Test for existence of native selection extend() method\nvar selectionHasExtend = _api__WEBPACK_IMPORTED_MODULE_1__.features.selectionHasExtend =\n    (0,_util__WEBPACK_IMPORTED_MODULE_3__.isHostMethod)(testSelection, "extend");\n// Test if rangeCount exists\nvar selectionHasRangeCount = _api__WEBPACK_IMPORTED_MODULE_1__.features.selectionHasRangeCount =\n    (typeof testSelection.rangeCount == NUMBER);\nvar addRangeBackwardToNative = selectionHasExtend\n    ? function (nativeSelection, range) {\n        var doc = ___WEBPACK_IMPORTED_MODULE_5__.DomRange.getRangeDocument(range);\n        var endRange = (0,___WEBPACK_IMPORTED_MODULE_5__.createRange)(doc);\n        endRange.collapseToPoint(range.endContainer, range.endOffset);\n        nativeSelection.addRange(getNativeRange(endRange));\n        nativeSelection.extend(range.startContainer, range.startOffset);\n    }\n    : null;\n// Selection collapsedness\nvar selectionIsCollapsed = selectionHasAnchorAndFocus\n    ? function (sel) {\n        return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n    }\n    : function (sel) {\n        return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n    };\nfunction updateAnchorAndFocusFromRange(sel, range, backward) {\n    var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";\n    sel.anchorNode = range[anchorPrefix + "Container"];\n    sel.anchorOffset = range[anchorPrefix + "Offset"];\n    sel.focusNode = range[focusPrefix + "Container"];\n    sel.focusOffset = range[focusPrefix + "Offset"];\n}\nfunction updateAnchorAndFocusFromNativeSelection(sel) {\n    var nativeSel = sel.nativeSelection;\n    sel.anchorNode = nativeSel.anchorNode;\n    sel.anchorOffset = nativeSel.anchorOffset;\n    sel.focusNode = nativeSel.focusNode;\n    sel.focusOffset = nativeSel.focusOffset;\n}\nfunction updateEmptySelection(sel) {\n    sel.anchorNode = sel.focusNode = null;\n    sel.anchorOffset = sel.focusOffset = 0;\n    sel.rangeCount = 0;\n    sel.isCollapsed = true;\n    sel._ranges.length = 0;\n}\nfunction getNativeRange(range) {\n    var nativeRange;\n    if (range instanceof ___WEBPACK_IMPORTED_MODULE_5__.DomRange) {\n        nativeRange = (0,___WEBPACK_IMPORTED_MODULE_5__.createNativeRange)(range.getDocument());\n        nativeRange.setEnd(range.endContainer, range.endOffset);\n        nativeRange.setStart(range.startContainer, range.startOffset);\n    }\n    else if (range instanceof ___WEBPACK_IMPORTED_MODULE_5__.WrappedRange) {\n        nativeRange = range.nativeRange;\n        // } else if (features.implementsDomRange && ((range as any) instanceof dom.getWindow(range.startContainer).Range)) {\n    }\n    else if (range instanceof Range) {\n        nativeRange = range;\n    }\n    return nativeRange;\n}\nvar getSelectionRangeAt;\nif ((0,_util__WEBPACK_IMPORTED_MODULE_3__.isHostMethod)(testSelection, "getRangeAt")) {\n    // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.\n    // Unfortunately, I didn\'t write a comment about the specifics and am now scared to take it out. Let that be a\n    // lesson to us all, especially me.\n    getSelectionRangeAt = function (sel, index) {\n        try {\n            return sel.getRangeAt(index);\n        }\n        catch (ex) {\n            return null;\n        }\n    };\n}\nelse if (selectionHasAnchorAndFocus) {\n    getSelectionRangeAt = function (sel) {\n        var doc = (0,_dom__WEBPACK_IMPORTED_MODULE_4__.getDocument)(sel.anchorNode);\n        var range = (0,___WEBPACK_IMPORTED_MODULE_5__.createRange)(doc);\n        range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);\n        // Handle the case when the selection was selected backwards (from the end to the start in the\n        // document)\n        if (range.collapsed !== this.isCollapsed) {\n            range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);\n        }\n        return range;\n    };\n}\nfunction deleteProperties(sel) {\n    sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;\n    sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;\n    sel.detached = true;\n}\nvar cachedRangySelections = [];\nfunction actOnCachedSelection(win, action) {\n    var i = cachedRangySelections.length, cached, sel;\n    while (i--) {\n        cached = cachedRangySelections[i];\n        sel = cached.selection;\n        if (action == "deleteAll") {\n            deleteProperties(sel);\n        }\n        else if (cached.win == win) {\n            if (action == "delete") {\n                cachedRangySelections.splice(i, 1);\n                return true;\n            }\n            else {\n                return sel;\n            }\n        }\n    }\n    if (action == "deleteAll") {\n        cachedRangySelections.length = 0;\n    }\n    return null;\n}\nfunction getSelection(win) {\n    // Check if the parameter is a Rangy Selection object\n    if (win && win instanceof WrappedSelection) {\n        win.refresh();\n        return win;\n    }\n    win = getWindow(win, "getNativeSelection");\n    var sel = actOnCachedSelection(win);\n    var nativeSel = getNativeSelection(win);\n    if (sel) {\n        sel.nativeSelection = nativeSel;\n        sel.refresh();\n    }\n    else {\n        sel = new WrappedSelection(nativeSel, win);\n        cachedRangySelections.push({ win: win, selection: sel });\n    }\n    return sel;\n}\n;\nvar refreshSelection;\nif ((0,_util__WEBPACK_IMPORTED_MODULE_3__.isHostMethod)(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {\n    refreshSelection = function (sel) {\n        sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n        if (sel.rangeCount) {\n            for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                sel._ranges[i] = new ___WEBPACK_IMPORTED_MODULE_5__.WrappedRange(sel.nativeSelection.getRangeAt(i));\n            }\n            updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));\n            sel.isCollapsed = selectionIsCollapsed(sel);\n        }\n        else {\n            updateEmptySelection(sel);\n        }\n    };\n}\nelse if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && _api__WEBPACK_IMPORTED_MODULE_1__.features.implementsDomRange) {\n    refreshSelection = function (sel) {\n        var range, nativeSel = sel.nativeSelection;\n        if (nativeSel.anchorNode) {\n            range = getSelectionRangeAt(nativeSel, 0);\n            sel._ranges = [range];\n            sel.rangeCount = 1;\n            updateAnchorAndFocusFromNativeSelection(sel);\n            sel.isCollapsed = selectionIsCollapsed(sel);\n        }\n        else {\n            updateEmptySelection(sel);\n        }\n    };\n}\nelse {\n    module.fail("No means of obtaining a Range or TextRange from the user\'s selection was found");\n    //return false;\n}\n// WrappedSelection.prototype = api.selectionPrototype;\nvar WrappedSelBase = /** @class */ (function () {\n    function WrappedSelBase(nativeSelection, win) {\n        this.nativeSelection = nativeSelection;\n        this.win = win;\n        this._ranges = [];\n        //@deprecated the old rangy2 constructor form: (nativeSelection, docSelection: null, win)\n        if (arguments.length == 3) {\n            this.win = arguments[2];\n        }\n        this.refresh();\n    }\n    return WrappedSelBase;\n}());\n\n// TODO\nfunction createWrappedSelection(Base) {\n    var _a;\n    function addRangeBackward(sel, range) {\n        addRangeBackwardToNative(sel.nativeSelection, range);\n        sel.refresh();\n    }\n    ;\n    var addRange = selectionHasRangeCount\n        ? function (range, direction) {\n            if (isDirectionBackward(direction) && selectionHasExtend) {\n                addRangeBackward(this, range);\n            }\n            else {\n                var previousRangeCount;\n                if (_api__WEBPACK_IMPORTED_MODULE_1__.features.selectionSupportsMultipleRanges) {\n                    previousRangeCount = this.rangeCount;\n                }\n                else {\n                    this.removeAllRanges();\n                    previousRangeCount = 0;\n                }\n                // Clone the native range so that changing the selected range does not affect the selection.\n                // This is contrary to the spec but is the only way to achieve consistency between browsers. See\n                // issue 80.\n                var clonedNativeRange = getNativeRange(range).cloneRange();\n                try {\n                    this.nativeSelection.addRange(clonedNativeRange);\n                }\n                catch (ex) {\n                    // log.error("Native addRange threw error \'" + ex + "\' with range " + DomRange.inspect(clonedNativeRange), ex);\n                }\n                // Check whether adding the range was successful\n                this.rangeCount = this.nativeSelection.rangeCount;\n                if (this.rangeCount == previousRangeCount + 1) {\n                    // The range was added successfully\n                    // Check whether the range that we added to the selection is reflected in the last range extracted from\n                    // the selection\n                    if (_api__WEBPACK_IMPORTED_MODULE_1__.config.checkSelectionRanges) {\n                        var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                        if (nativeRange && !(0,___WEBPACK_IMPORTED_MODULE_5__.rangesEqual)(nativeRange, range)) {\n                            // Happens in WebKit with, for example, a selection placed at the start of a text node\n                            range = new ___WEBPACK_IMPORTED_MODULE_5__.WrappedRange(nativeRange);\n                        }\n                    }\n                    this._ranges[this.rangeCount - 1] = range;\n                    updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));\n                    this.isCollapsed = selectionIsCollapsed(this);\n                }\n                else {\n                    // The range was not added successfully. The simplest thing is to refresh\n                    this.refresh();\n                }\n            }\n        }\n        : function (range, direction) {\n            if (isDirectionBackward(direction) && selectionHasExtend) {\n                addRangeBackward(this, range);\n            }\n            else {\n                this.nativeSelection.addRange(getNativeRange(range));\n                this.refresh();\n            }\n        };\n    // Removal of a single range\n    function removeRangeManually(sel, range) {\n        var ranges = sel.getAllRanges();\n        sel.removeAllRanges();\n        for (var i = 0, len = ranges.length; i < len; ++i) {\n            if (!(0,___WEBPACK_IMPORTED_MODULE_5__.rangesEqual)(range, ranges[i])) {\n                sel.addRange(ranges[i]);\n            }\n        }\n        if (!sel.rangeCount) {\n            updateEmptySelection(sel);\n        }\n    }\n    ;\n    function assertNodeInSameDocument(sel, node) {\n        if (sel.win.document != (0,_dom__WEBPACK_IMPORTED_MODULE_4__.getDocument)(node)) {\n            throw new _DOMException__WEBPACK_IMPORTED_MODULE_2__.DOMException("WRONG_DOCUMENT_ERR");\n        }\n    }\n    function createStartOrEndSetter(isStart) {\n        return function (node, offset) {\n            var range;\n            if (this.rangeCount) {\n                range = this.getRangeAt(0);\n                range["set" + (isStart ? "Start" : "End")](node, offset);\n            }\n            else {\n                range = (0,___WEBPACK_IMPORTED_MODULE_5__.createRange)(this.win.document);\n                range.setStartAndEnd(node, offset);\n            }\n            this.setSingleRange(range, this.isBackward());\n        };\n    }\n    return _a = /** @class */ (function (_super) {\n            tslib__WEBPACK_IMPORTED_MODULE_6__.__extends(S, _super);\n            function S() {\n                var _this = _super !== null && _super.apply(this, arguments) || this;\n                //if (selectionHasRangeCount) {\n                _this.addRange = addRange;\n                // Create an alias for backwards compatibility. From 1.3, everything is "backward" rather than "backwards"\n                _this.isBackwards = _this.isBackward;\n                _this.setStart = createStartOrEndSetter(true);\n                _this.setEnd = createStartOrEndSetter(false);\n                return _this;\n            }\n            S.prototype.removeAllRanges = function () {\n                this.nativeSelection.removeAllRanges();\n                updateEmptySelection(this);\n            };\n            ;\n            S.prototype.setRanges = function (ranges) {\n                this.removeAllRanges();\n                for (var i = 0, len = ranges.length; i < len; ++i) {\n                    this.addRange(ranges[i]);\n                }\n            };\n            ;\n            S.prototype.getRangeAt = function (index) {\n                if (index < 0 || index >= this.rangeCount) {\n                    throw new _DOMException__WEBPACK_IMPORTED_MODULE_2__.DOMException("INDEX_SIZE_ERR");\n                }\n                else {\n                    // Clone the range to preserve selection-range independence. See issue 80.\n                    return this._ranges[index].cloneRange();\n                }\n            };\n            ;\n            S.prototype.refresh = function (checkForChanges) {\n                var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n                var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;\n                refreshSelection(this);\n                if (checkForChanges) {\n                    // Check the range count first\n                    var i = oldRanges.length;\n                    if (i != this._ranges.length) {\n                        // log.debug("Selection.refresh: Range count has changed: was " + i + ", is now " + this._ranges.length);\n                        return true;\n                    }\n                    // Now check the direction. Checking the anchor position is the same is enough since we\'re checking all the\n                    // ranges after this\n                    if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {\n                        // log.debug("Selection.refresh: anchor different, so selection has changed");\n                        return true;\n                    }\n                    // Finally, compare each range in turn\n                    while (i--) {\n                        if (!(0,___WEBPACK_IMPORTED_MODULE_5__.rangesEqual)(oldRanges[i], this._ranges[i])) {\n                            // log.debug("Selection.refresh: Range at index " + i + " has changed: was " + oldRanges[i].inspect() + ", is now " + this._ranges[i].inspect());\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            };\n            ;\n            S.prototype.removeRange = function (range) {\n                removeRangeManually(this, range);\n            };\n            ;\n            S.prototype.isBackward = function () {\n                return selectionIsBackward(this);\n            };\n            ;\n            // Selection stringifier\n            // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla\'s implementation.\n            // The current spec does not yet define this method.\n            S.prototype.toString = function () {\n                // log.debug("selection toString called");\n                var rangeTexts = [];\n                for (var i = 0, len = this.rangeCount; i < len; ++i) {\n                    rangeTexts[i] = "" + this._ranges[i];\n                }\n                return rangeTexts.join("");\n            };\n            ;\n            // No current browser conforms fully to the spec for this method, so Rangy\'s own method is always used\n            S.prototype.collapse = function (node, offset) {\n                assertNodeInSameDocument(this, node);\n                var range = (0,___WEBPACK_IMPORTED_MODULE_5__.createRange)(node);\n                range.collapseToPoint(node, offset);\n                this.setSingleRange(range);\n                this.isCollapsed = true;\n            };\n            ;\n            S.prototype.collapseToStart = function () {\n                if (this.rangeCount) {\n                    var range = this._ranges[0];\n                    this.collapse(range.startContainer, range.startOffset);\n                }\n                else {\n                    throw new _DOMException__WEBPACK_IMPORTED_MODULE_2__.DOMException("INVALID_STATE_ERR");\n                }\n            };\n            ;\n            S.prototype.collapseToEnd = function () {\n                if (this.rangeCount) {\n                    var range = this._ranges[this.rangeCount - 1];\n                    this.collapse(range.endContainer, range.endOffset);\n                }\n                else {\n                    throw new _DOMException__WEBPACK_IMPORTED_MODULE_2__.DOMException("INVALID_STATE_ERR");\n                }\n            };\n            ;\n            // The spec is very specific on how selectAllChildren should be implemented and not all browsers implement it as\n            // specified so the native implementation is never used by Rangy.\n            S.prototype.selectAllChildren = function (node) {\n                assertNodeInSameDocument(this, node);\n                var range = (0,___WEBPACK_IMPORTED_MODULE_5__.createRange)(node);\n                range.selectNodeContents(node);\n                this.setSingleRange(range);\n            };\n            ;\n            S.prototype.deleteFromDocument = function () {\n                if (this.rangeCount) {\n                    var ranges = this.getAllRanges();\n                    if (ranges.length) {\n                        this.removeAllRanges();\n                        for (var i = 0, len = ranges.length; i < len; ++i) {\n                            ranges[i].deleteContents();\n                        }\n                        // The spec says nothing about what the selection should contain after calling deleteContents on each\n                        // range. Firefox moves the selection to where the final selected range was, so we emulate that\n                        this.addRange(ranges[len - 1]);\n                    }\n                }\n            };\n            ;\n            // The following are non-standard extensions\n            S.prototype.eachRange = function (func, returnValue) {\n                for (var i = 0, len = this._ranges.length; i < len; ++i) {\n                    if (func(this.getRangeAt(i))) {\n                        return returnValue;\n                    }\n                }\n            };\n            ;\n            S.prototype.getAllRanges = function () {\n                var ranges = [];\n                this.eachRange(function (range) {\n                    ranges.push(range);\n                });\n                return ranges;\n            };\n            ;\n            S.prototype.setSingleRange = function (range, direction) {\n                this.removeAllRanges();\n                this.addRange(range, direction);\n            };\n            ;\n            S.prototype.callMethodOnEachRange = function (methodName, params) {\n                var results = [];\n                this.eachRange(function (range) {\n                    results.push(range[methodName].apply(range, params || []));\n                });\n                return results;\n            };\n            ;\n            S.prototype.changeEachRange = function (func) {\n                var ranges = [];\n                var backward = this.isBackward();\n                this.eachRange(function (range) {\n                    func(range);\n                    ranges.push(range);\n                });\n                this.removeAllRanges();\n                if (backward && ranges.length == 1) {\n                    this.addRange(ranges[0], "backward");\n                }\n                else {\n                    this.setRanges(ranges);\n                }\n            };\n            ;\n            S.prototype.containsNode = function (node, allowPartial) {\n                return this.eachRange(function (range) {\n                    return range.containsNode(node, allowPartial);\n                }, true) || false;\n            };\n            ;\n            S.prototype.getBookmark = function (containerNode) {\n                return {\n                    backward: this.isBackward(),\n                    rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])\n                };\n            };\n            ;\n            S.prototype.moveToBookmark = function (bookmark) {\n                var selRanges = [];\n                for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++];) {\n                    range = (0,___WEBPACK_IMPORTED_MODULE_5__.createRange)(this.win);\n                    range.moveToBookmark(rangeBookmark);\n                    selRanges.push(range);\n                }\n                if (bookmark.backward) {\n                    this.setSingleRange(selRanges[0], "backward");\n                }\n                else {\n                    this.setRanges(selRanges);\n                }\n            };\n            ;\n            S.prototype.saveRanges = function () {\n                return {\n                    backward: this.isBackward(),\n                    ranges: this.callMethodOnEachRange("cloneRange")\n                };\n            };\n            ;\n            S.prototype.restoreRanges = function (selRanges) {\n                this.removeAllRanges();\n                for (var i = 0, range; range = selRanges.ranges[i]; ++i) {\n                    this.addRange(range, (selRanges.backward && i == 0));\n                }\n            };\n            ;\n            S.prototype.toHtml = function () {\n                var rangeHtmls = [];\n                this.eachRange(function (range) {\n                    rangeHtmls.push(___WEBPACK_IMPORTED_MODULE_5__.DomRange.toHtml(range));\n                });\n                return rangeHtmls.join("");\n            };\n            ;\n            S.inspect = function (sel) {\n                var rangeInspects = [];\n                var anchor = new _dom__WEBPACK_IMPORTED_MODULE_4__.DomPosition(sel.anchorNode, sel.anchorOffset);\n                var focus = new _dom__WEBPACK_IMPORTED_MODULE_4__.DomPosition(sel.focusNode, sel.focusOffset);\n                var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";\n                if (typeof sel.rangeCount != "undefined") {\n                    for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                        rangeInspects[i] = ___WEBPACK_IMPORTED_MODULE_5__.DomRange.inspect(sel.getRangeAt(i));\n                    }\n                }\n                return "[" + name + "(Ranges: " + rangeInspects.join(", ") +\n                    ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";\n            };\n            S.prototype.getName = function () {\n                return "WrappedSelection";\n            };\n            ;\n            S.prototype.inspect = function () {\n                return S.inspect(this);\n            };\n            ;\n            S.prototype.detach = function () {\n                actOnCachedSelection(this.win, "delete");\n                deleteProperties(this);\n            };\n            ;\n            S.detachAll = function () {\n                actOnCachedSelection(null, "deleteAll");\n            };\n            ;\n            return S;\n        }(Base)),\n        _a.isDirectionBackward = isDirectionBackward,\n        _a;\n}\nvar WrappedSelection = createWrappedSelection(WrappedSelBase);\n//alias\nvar Selection = WrappedSelection;\nfunction shimGetSelection(win) {\n    if (!win)\n        win = window;\n    if (typeof win.getSelection == "undefined") {\n        win.getSelection = function () {\n            return getSelection(win);\n        };\n    }\n}\n;\n//# sourceMappingURL=wrappedselection.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/internal/wrappedselection.js?')},"./node_modules/rangy2/esm5/module.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Module": () => (/* binding */ Module)\n/* harmony export */ });\nvar Module = /** @class */ (function () {\n    function Module(name, dependencies) {\n        this.name = name;\n        this.dependencies = dependencies;\n    }\n    Module.prototype.fail = function (reason) {\n        console.log("Module \'" + this.name + "\' failed to load: " + reason);\n        throw new Error(reason);\n    };\n    Module.prototype.warn = function (msg) {\n        console.log("Module " + this.name + ": " + msg);\n    };\n    Module.prototype.createError = function (msg) {\n        return new Error("Error in Rangy " + this.name + " module: " + msg);\n    };\n    return Module;\n}());\n\n//# sourceMappingURL=module.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/module.js?')},"./node_modules/rangy2/esm5/util.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isHostMethod": () => (/* binding */ isHostMethod),\n/* harmony export */   "isHostObject": () => (/* binding */ isHostObject),\n/* harmony export */   "isHostProperty": () => (/* binding */ isHostProperty),\n/* harmony export */   "areHostMethods": () => (/* binding */ areHostMethods),\n/* harmony export */   "areHostObjects": () => (/* binding */ areHostObjects),\n/* harmony export */   "areHostProperties": () => (/* binding */ areHostProperties),\n/* harmony export */   "getBody": () => (/* binding */ getBody)\n/* harmony export */ });\n// Trio of functions taken from Peter Michaux\'s article:\n// http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\nfunction isHostMethod(o, p) {\n    var t = typeof o[p];\n    return t == "function" || (!!(t == "object" && o[p])) || t == "unknown";\n}\nfunction isHostObject(o, p) {\n    return !!(typeof o[p] == "object" && o[p]);\n}\nfunction isHostProperty(o, p) {\n    return typeof o[p] != "undefined";\n}\n// Creates a convenience function to save verbose repeated calls to tests functions\nfunction createMultiplePropertyTest(testFunc) {\n    return function (o, props) {\n        var i = props.length;\n        while (i--) {\n            if (!testFunc(o, props[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n// Next trio of functions are a convenience to save verbose repeated calls to previous two functions\nvar areHostMethods = createMultiplePropertyTest(isHostMethod);\nvar areHostObjects = createMultiplePropertyTest(isHostObject);\nvar areHostProperties = createMultiplePropertyTest(isHostProperty);\nfunction getBody(doc) {\n    return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://sat/./node_modules/rangy2/esm5/util.js?')},"./node_modules/split.js/dist/split.js":function(module){eval("/*! Split.js - v1.6.4 */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n}(this, (function () { 'use strict';\n\n    // The programming goals of Split.js are to deliver readable, understandable and\n    // maintainable code, while at the same time manually optimizing for tiny minified file size,\n    // browser compatibility without additional requirements\n    // and very few assumptions about the user's page layout.\n    var global = typeof window !== 'undefined' ? window : null;\n    var ssr = global === null;\n    var document = !ssr ? global.document : undefined;\n\n    // Save a couple long function names that are used frequently.\n    // This optimization saves around 400 bytes.\n    var addEventListener = 'addEventListener';\n    var removeEventListener = 'removeEventListener';\n    var getBoundingClientRect = 'getBoundingClientRect';\n    var gutterStartDragging = '_a';\n    var aGutterSize = '_b';\n    var bGutterSize = '_c';\n    var HORIZONTAL = 'horizontal';\n    var NOOP = function () { return false; };\n\n    // Helper function determines which prefixes of CSS calc we need.\n    // We only need to do this once on startup, when this anonymous function is called.\n    //\n    // Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n    // http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\n    var calc = ssr\n        ? 'calc'\n        : ((['', '-webkit-', '-moz-', '-o-']\n              .filter(function (prefix) {\n                  var el = document.createElement('div');\n                  el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n                  return !!el.style.length\n              })\n              .shift()) + \"calc\");\n\n    // Helper function checks if its argument is a string-like type\n    var isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n    // Helper function allows elements and string selectors to be used\n    // interchangeably. In either case an element is returned. This allows us to\n    // do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\n    var elementOrSelector = function (el) {\n        if (isString(el)) {\n            var ele = document.querySelector(el);\n            if (!ele) {\n                throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n            }\n            return ele\n        }\n\n        return el\n    };\n\n    // Helper function gets a property from the properties object, with a default fallback\n    var getOption = function (options, propName, def) {\n        var value = options[propName];\n        if (value !== undefined) {\n            return value\n        }\n        return def\n    };\n\n    var getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n        if (isFirst) {\n            if (gutterAlign === 'end') {\n                return 0\n            }\n            if (gutterAlign === 'center') {\n                return gutterSize / 2\n            }\n        } else if (isLast) {\n            if (gutterAlign === 'start') {\n                return 0\n            }\n            if (gutterAlign === 'center') {\n                return gutterSize / 2\n            }\n        }\n\n        return gutterSize\n    };\n\n    // Default options\n    var defaultGutterFn = function (i, gutterDirection) {\n        var gut = document.createElement('div');\n        gut.className = \"gutter gutter-\" + gutterDirection;\n        return gut\n    };\n\n    var defaultElementStyleFn = function (dim, size, gutSize) {\n        var style = {};\n\n        if (!isString(size)) {\n            style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n        } else {\n            style[dim] = size;\n        }\n\n        return style\n    };\n\n    var defaultGutterStyleFn = function (dim, gutSize) {\n        var obj;\n\n        return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n    };\n\n    // The main function to initialize a split. Split.js thinks about each pair\n    // of elements as an independant pair. Dragging the gutter between two elements\n    // only changes the dimensions of elements in that pair. This is key to understanding\n    // how the following functions operate, since each function is bound to a pair.\n    //\n    // A pair object is shaped like this:\n    //\n    // {\n    //     a: DOM element,\n    //     b: DOM element,\n    //     aMin: Number,\n    //     bMin: Number,\n    //     dragging: Boolean,\n    //     parent: DOM element,\n    //     direction: 'horizontal' | 'vertical'\n    // }\n    //\n    // The basic sequence:\n    //\n    // 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    //    A lot of the behavior in the rest of the library is paramatized down to\n    //    rely on CSS strings and classes.\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // 4. Loop through the elements while pairing them off. Every pair gets an\n    //    `pair` object and a gutter.\n    // 5. Actually size the pair elements, insert gutters and attach event listeners.\n    var Split = function (idsOption, options) {\n        if ( options === void 0 ) options = {};\n\n        if (ssr) { return {} }\n\n        var ids = idsOption;\n        var dimension;\n        var clientAxis;\n        var position;\n        var positionEnd;\n        var clientSize;\n        var elements;\n\n        // Allow HTMLCollection to be used as an argument when supported\n        if (Array.from) {\n            ids = Array.from(ids);\n        }\n\n        // All DOM elements in the split should have a common parent. We can grab\n        // the first elements parent and hope users read the docs because the\n        // behavior will be whacky otherwise.\n        var firstElement = elementOrSelector(ids[0]);\n        var parent = firstElement.parentNode;\n        var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n        var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n        // Set default options.sizes to equal percentages of the parent element.\n        var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n        // Standardize minSize and maxSize to an array if it isn't already.\n        // This allows minSize and maxSize to be passed as a number.\n        var minSize = getOption(options, 'minSize', 100);\n        var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n        var maxSize = getOption(options, 'maxSize', Infinity);\n        var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n\n        // Get other options\n        var expandToMin = getOption(options, 'expandToMin', false);\n        var gutterSize = getOption(options, 'gutterSize', 10);\n        var gutterAlign = getOption(options, 'gutterAlign', 'center');\n        var snapOffset = getOption(options, 'snapOffset', 30);\n        var dragInterval = getOption(options, 'dragInterval', 1);\n        var direction = getOption(options, 'direction', HORIZONTAL);\n        var cursor = getOption(\n            options,\n            'cursor',\n            direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n        );\n        var gutter = getOption(options, 'gutter', defaultGutterFn);\n        var elementStyle = getOption(\n            options,\n            'elementStyle',\n            defaultElementStyleFn\n        );\n        var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n        // 2. Initialize a bunch of strings based on the direction we're splitting.\n        // A lot of the behavior in the rest of the library is paramatized down to\n        // rely on CSS strings and classes.\n        if (direction === HORIZONTAL) {\n            dimension = 'width';\n            clientAxis = 'clientX';\n            position = 'left';\n            positionEnd = 'right';\n            clientSize = 'clientWidth';\n        } else if (direction === 'vertical') {\n            dimension = 'height';\n            clientAxis = 'clientY';\n            position = 'top';\n            positionEnd = 'bottom';\n            clientSize = 'clientHeight';\n        }\n\n        // 3. Define the dragging helper functions, and a few helpers to go with them.\n        // Each helper is bound to a pair object that contains its metadata. This\n        // also makes it easy to store references to listeners that that will be\n        // added and removed.\n        //\n        // Even though there are no other functions contained in them, aliasing\n        // this to self saves 50 bytes or so since it's used so frequently.\n        //\n        // The pair object saves metadata like dragging state, position and\n        // event listener references.\n\n        function setElementSize(el, size, gutSize, i) {\n            // Split.js allows setting sizes via numbers (ideally), or if you must,\n            // by string, like '300px'. This is less than ideal, because it breaks\n            // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n            // make sure you calculate the gutter size by hand.\n            var style = elementStyle(dimension, size, gutSize, i);\n\n            Object.keys(style).forEach(function (prop) {\n                // eslint-disable-next-line no-param-reassign\n                el.style[prop] = style[prop];\n            });\n        }\n\n        function setGutterSize(gutterElement, gutSize, i) {\n            var style = gutterStyle(dimension, gutSize, i);\n\n            Object.keys(style).forEach(function (prop) {\n                // eslint-disable-next-line no-param-reassign\n                gutterElement.style[prop] = style[prop];\n            });\n        }\n\n        function getSizes() {\n            return elements.map(function (element) { return element.size; })\n        }\n\n        // Supports touch events, but not multitouch, so only the first\n        // finger `touches[0]` is counted.\n        function getMousePosition(e) {\n            if ('touches' in e) { return e.touches[0][clientAxis] }\n            return e[clientAxis]\n        }\n\n        // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n        // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n        // which allows the viewport to be resized without additional logic.\n        // Element a's size is the same as offset. b's size is total size - a size.\n        // Both sizes are calculated from the initial parent percentage,\n        // then the gutter size is subtracted.\n        function adjust(offset) {\n            var a = elements[this.a];\n            var b = elements[this.b];\n            var percentage = a.size + b.size;\n\n            a.size = (offset / this.size) * percentage;\n            b.size = percentage - (offset / this.size) * percentage;\n\n            setElementSize(a.element, a.size, this[aGutterSize], a.i);\n            setElementSize(b.element, b.size, this[bGutterSize], b.i);\n        }\n\n        // drag, where all the magic happens. The logic is really quite simple:\n        //\n        // 1. Ignore if the pair is not dragging.\n        // 2. Get the offset of the event.\n        // 3. Snap offset to min if within snappable range (within min + snapOffset).\n        // 4. Actually adjust each element in the pair to offset.\n        //\n        // ---------------------------------------------------------------------\n        // |    | <- a.minSize               ||              b.minSize -> |    |\n        // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n        // |    |  |                         ||                        |  |    |\n        // |    |  |                         ||                        |  |    |\n        // ---------------------------------------------------------------------\n        // | <- this.start                                        this.size -> |\n        function drag(e) {\n            var offset;\n            var a = elements[this.a];\n            var b = elements[this.b];\n\n            if (!this.dragging) { return }\n\n            // Get the offset of the event from the first side of the\n            // pair `this.start`. Then offset by the initial position of the\n            // mouse compared to the gutter size.\n            offset =\n                getMousePosition(e) -\n                this.start +\n                (this[aGutterSize] - this.dragOffset);\n\n            if (dragInterval > 1) {\n                offset = Math.round(offset / dragInterval) * dragInterval;\n            }\n\n            // If within snapOffset of min or max, set offset to min or max.\n            // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n            // Include the appropriate gutter sizes to prevent overflows.\n            if (offset <= a.minSize + snapOffset + this[aGutterSize]) {\n                offset = a.minSize + this[aGutterSize];\n            } else if (\n                offset >=\n                this.size - (b.minSize + snapOffset + this[bGutterSize])\n            ) {\n                offset = this.size - (b.minSize + this[bGutterSize]);\n            }\n\n            if (offset >= a.maxSize - snapOffset + this[aGutterSize]) {\n                offset = a.maxSize + this[aGutterSize];\n            } else if (\n                offset <=\n                this.size - (b.maxSize - snapOffset + this[bGutterSize])\n            ) {\n                offset = this.size - (b.maxSize + this[bGutterSize]);\n            }\n\n            // Actually adjust the size.\n            adjust.call(this, offset);\n\n            // Call the drag callback continously. Don't do anything too intensive\n            // in this callback.\n            getOption(options, 'onDrag', NOOP)(getSizes());\n        }\n\n        // Cache some important sizes when drag starts, so we don't have to do that\n        // continously:\n        //\n        // `size`: The total size of the pair. First + second + first gutter + second gutter.\n        // `start`: The leading side of the first element.\n        //\n        // ------------------------------------------------\n        // |      aGutterSize -> |||                      |\n        // |                     |||                      |\n        // |                     |||                      |\n        // |                     ||| <- bGutterSize       |\n        // ------------------------------------------------\n        // | <- start                             size -> |\n        function calculateSizes() {\n            // Figure out the parent size minus padding.\n            var a = elements[this.a].element;\n            var b = elements[this.b].element;\n\n            var aBounds = a[getBoundingClientRect]();\n            var bBounds = b[getBoundingClientRect]();\n\n            this.size =\n                aBounds[dimension] +\n                bBounds[dimension] +\n                this[aGutterSize] +\n                this[bGutterSize];\n            this.start = aBounds[position];\n            this.end = aBounds[positionEnd];\n        }\n\n        function innerSize(element) {\n            // Return nothing if getComputedStyle is not supported (< IE9)\n            // Or if parent element has no layout yet\n            if (!getComputedStyle) { return null }\n\n            var computedStyle = getComputedStyle(element);\n\n            if (!computedStyle) { return null }\n\n            var size = element[clientSize];\n\n            if (size === 0) { return null }\n\n            if (direction === HORIZONTAL) {\n                size -=\n                    parseFloat(computedStyle.paddingLeft) +\n                    parseFloat(computedStyle.paddingRight);\n            } else {\n                size -=\n                    parseFloat(computedStyle.paddingTop) +\n                    parseFloat(computedStyle.paddingBottom);\n            }\n\n            return size\n        }\n\n        // When specifying percentage sizes that are less than the computed\n        // size of the element minus the gutter, the lesser percentages must be increased\n        // (and decreased from the other elements) to make space for the pixels\n        // subtracted by the gutters.\n        function trimToMin(sizesToTrim) {\n            // Try to get inner size of parent element.\n            // If it's no supported, return original sizes.\n            var parentSize = innerSize(parent);\n            if (parentSize === null) {\n                return sizesToTrim\n            }\n\n            if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n                return sizesToTrim\n            }\n\n            // Keep track of the excess pixels, the amount of pixels over the desired percentage\n            // Also keep track of the elements with pixels to spare, to decrease after if needed\n            var excessPixels = 0;\n            var toSpare = [];\n\n            var pixelSizes = sizesToTrim.map(function (size, i) {\n                // Convert requested percentages to pixel sizes\n                var pixelSize = (parentSize * size) / 100;\n                var elementGutterSize = getGutterSize(\n                    gutterSize,\n                    i === 0,\n                    i === sizesToTrim.length - 1,\n                    gutterAlign\n                );\n                var elementMinSize = minSizes[i] + elementGutterSize;\n\n                // If element is too smal, increase excess pixels by the difference\n                // and mark that it has no pixels to spare\n                if (pixelSize < elementMinSize) {\n                    excessPixels += elementMinSize - pixelSize;\n                    toSpare.push(0);\n                    return elementMinSize\n                }\n\n                // Otherwise, mark the pixels it has to spare and return it's original size\n                toSpare.push(pixelSize - elementMinSize);\n                return pixelSize\n            });\n\n            // If nothing was adjusted, return the original sizes\n            if (excessPixels === 0) {\n                return sizesToTrim\n            }\n\n            return pixelSizes.map(function (pixelSize, i) {\n                var newPixelSize = pixelSize;\n\n                // While there's still pixels to take, and there's enough pixels to spare,\n                // take as many as possible up to the total excess pixels\n                if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                    var takenPixels = Math.min(\n                        excessPixels,\n                        toSpare[i] - excessPixels\n                    );\n\n                    // Subtract the amount taken for the next iteration\n                    excessPixels -= takenPixels;\n                    newPixelSize = pixelSize - takenPixels;\n                }\n\n                // Return the pixel size adjusted as a percentage\n                return (newPixelSize / parentSize) * 100\n            })\n        }\n\n        // stopDragging is very similar to startDragging in reverse.\n        function stopDragging() {\n            var self = this;\n            var a = elements[self.a].element;\n            var b = elements[self.b].element;\n\n            if (self.dragging) {\n                getOption(options, 'onDragEnd', NOOP)(getSizes());\n            }\n\n            self.dragging = false;\n\n            // Remove the stored event listeners. This is why we store them.\n            global[removeEventListener]('mouseup', self.stop);\n            global[removeEventListener]('touchend', self.stop);\n            global[removeEventListener]('touchcancel', self.stop);\n            global[removeEventListener]('mousemove', self.move);\n            global[removeEventListener]('touchmove', self.move);\n\n            // Clear bound function references\n            self.stop = null;\n            self.move = null;\n\n            a[removeEventListener]('selectstart', NOOP);\n            a[removeEventListener]('dragstart', NOOP);\n            b[removeEventListener]('selectstart', NOOP);\n            b[removeEventListener]('dragstart', NOOP);\n\n            a.style.userSelect = '';\n            a.style.webkitUserSelect = '';\n            a.style.MozUserSelect = '';\n            a.style.pointerEvents = '';\n\n            b.style.userSelect = '';\n            b.style.webkitUserSelect = '';\n            b.style.MozUserSelect = '';\n            b.style.pointerEvents = '';\n\n            self.gutter.style.cursor = '';\n            self.parent.style.cursor = '';\n            document.body.style.cursor = '';\n        }\n\n        // startDragging calls `calculateSizes` to store the inital size in the pair object.\n        // It also adds event listeners for mouse/touch events,\n        // and prevents selection while dragging so avoid the selecting text.\n        function startDragging(e) {\n            // Right-clicking can't start dragging.\n            if ('button' in e && e.button !== 0) {\n                return\n            }\n\n            // Alias frequently used variables to save space. 200 bytes.\n            var self = this;\n            var a = elements[self.a].element;\n            var b = elements[self.b].element;\n\n            // Call the onDragStart callback.\n            if (!self.dragging) {\n                getOption(options, 'onDragStart', NOOP)(getSizes());\n            }\n\n            // Don't actually drag the element. We emulate that in the drag function.\n            e.preventDefault();\n\n            // Set the dragging property of the pair object.\n            self.dragging = true;\n\n            // Create two event listeners bound to the same pair object and store\n            // them in the pair object.\n            self.move = drag.bind(self);\n            self.stop = stopDragging.bind(self);\n\n            // All the binding. `window` gets the stop events in case we drag out of the elements.\n            global[addEventListener]('mouseup', self.stop);\n            global[addEventListener]('touchend', self.stop);\n            global[addEventListener]('touchcancel', self.stop);\n            global[addEventListener]('mousemove', self.move);\n            global[addEventListener]('touchmove', self.move);\n\n            // Disable selection. Disable!\n            a[addEventListener]('selectstart', NOOP);\n            a[addEventListener]('dragstart', NOOP);\n            b[addEventListener]('selectstart', NOOP);\n            b[addEventListener]('dragstart', NOOP);\n\n            a.style.userSelect = 'none';\n            a.style.webkitUserSelect = 'none';\n            a.style.MozUserSelect = 'none';\n            a.style.pointerEvents = 'none';\n\n            b.style.userSelect = 'none';\n            b.style.webkitUserSelect = 'none';\n            b.style.MozUserSelect = 'none';\n            b.style.pointerEvents = 'none';\n\n            // Set the cursor at multiple levels\n            self.gutter.style.cursor = cursor;\n            self.parent.style.cursor = cursor;\n            document.body.style.cursor = cursor;\n\n            // Cache the initial sizes of the pair.\n            calculateSizes.call(self);\n\n            // Determine the position of the mouse compared to the gutter\n            self.dragOffset = getMousePosition(e) - self.end;\n        }\n\n        // adjust sizes to ensure percentage is within min size and gutter.\n        sizes = trimToMin(sizes);\n\n        // 5. Create pair and element objects. Each pair has an index reference to\n        // elements `a` and `b` of the pair (first and second elements).\n        // Loop through the elements while pairing them off. Every pair gets a\n        // `pair` object and a gutter.\n        //\n        // Basic logic:\n        //\n        // - Starting with the second element `i > 0`, create `pair` objects with\n        //   `a = i - 1` and `b = i`\n        // - Set gutter sizes based on the _pair_ being first/last. The first and last\n        //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n        // - Create gutter elements and add event listeners.\n        // - Set the size of the elements, minus the gutter sizes.\n        //\n        // -----------------------------------------------------------------------\n        // |     i=0     |         i=1         |        i=2       |      i=3     |\n        // |             |                     |                  |              |\n        // |           pair 0                pair 1             pair 2           |\n        // |             |                     |                  |              |\n        // -----------------------------------------------------------------------\n        var pairs = [];\n        elements = ids.map(function (id, i) {\n            // Create the element object.\n            var element = {\n                element: elementOrSelector(id),\n                size: sizes[i],\n                minSize: minSizes[i],\n                maxSize: maxSizes[i],\n                i: i,\n            };\n\n            var pair;\n\n            if (i > 0) {\n                // Create the pair object with its metadata.\n                pair = {\n                    a: i - 1,\n                    b: i,\n                    dragging: false,\n                    direction: direction,\n                    parent: parent,\n                };\n\n                pair[aGutterSize] = getGutterSize(\n                    gutterSize,\n                    i - 1 === 0,\n                    false,\n                    gutterAlign\n                );\n                pair[bGutterSize] = getGutterSize(\n                    gutterSize,\n                    false,\n                    i === ids.length - 1,\n                    gutterAlign\n                );\n\n                // if the parent has a reverse flex-direction, switch the pair elements.\n                if (\n                    parentFlexDirection === 'row-reverse' ||\n                    parentFlexDirection === 'column-reverse'\n                ) {\n                    var temp = pair.a;\n                    pair.a = pair.b;\n                    pair.b = temp;\n                }\n            }\n\n            // Determine the size of the current element. IE8 is supported by\n            // staticly assigning sizes without draggable gutters. Assigns a string\n            // to `size`.\n            //\n            // Create gutter elements for each pair.\n            if (i > 0) {\n                var gutterElement = gutter(i, direction, element.element);\n                setGutterSize(gutterElement, gutterSize, i);\n\n                // Save bound event listener for removal later\n                pair[gutterStartDragging] = startDragging.bind(pair);\n\n                // Attach bound event listener\n                gutterElement[addEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                gutterElement[addEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n\n                parent.insertBefore(gutterElement, element.element);\n\n                pair.gutter = gutterElement;\n            }\n\n            setElementSize(\n                element.element,\n                element.size,\n                getGutterSize(\n                    gutterSize,\n                    i === 0,\n                    i === ids.length - 1,\n                    gutterAlign\n                ),\n                i\n            );\n\n            // After the first iteration, and we have a pair object, append it to the\n            // list of pairs.\n            if (i > 0) {\n                pairs.push(pair);\n            }\n\n            return element\n        });\n\n        function adjustToMin(element) {\n            var isLast = element.i === pairs.length;\n            var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n            calculateSizes.call(pair);\n\n            var size = isLast\n                ? pair.size - element.minSize - pair[bGutterSize]\n                : element.minSize + pair[aGutterSize];\n\n            adjust.call(pair, size);\n        }\n\n        elements.forEach(function (element) {\n            var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n            if (computedSize < element.minSize) {\n                if (expandToMin) {\n                    adjustToMin(element);\n                } else {\n                    // eslint-disable-next-line no-param-reassign\n                    element.minSize = computedSize;\n                }\n            }\n        });\n\n        function setSizes(newSizes) {\n            var trimmed = trimToMin(newSizes);\n            trimmed.forEach(function (newSize, i) {\n                if (i > 0) {\n                    var pair = pairs[i - 1];\n\n                    var a = elements[pair.a];\n                    var b = elements[pair.b];\n\n                    a.size = trimmed[i - 1];\n                    b.size = newSize;\n\n                    setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                    setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n                }\n            });\n        }\n\n        function destroy(preserveStyles, preserveGutter) {\n            pairs.forEach(function (pair) {\n                if (preserveGutter !== true) {\n                    pair.parent.removeChild(pair.gutter);\n                } else {\n                    pair.gutter[removeEventListener](\n                        'mousedown',\n                        pair[gutterStartDragging]\n                    );\n                    pair.gutter[removeEventListener](\n                        'touchstart',\n                        pair[gutterStartDragging]\n                    );\n                }\n\n                if (preserveStyles !== true) {\n                    var style = elementStyle(\n                        dimension,\n                        pair.a.size,\n                        pair[aGutterSize]\n                    );\n\n                    Object.keys(style).forEach(function (prop) {\n                        elements[pair.a].element.style[prop] = '';\n                        elements[pair.b].element.style[prop] = '';\n                    });\n                }\n            });\n        }\n\n        return {\n            setSizes: setSizes,\n            getSizes: getSizes,\n            collapse: function collapse(i) {\n                adjustToMin(elements[i]);\n            },\n            destroy: destroy,\n            parent: parent,\n            pairs: pairs,\n        }\n    };\n\n    return Split;\n\n})));\n\n\n//# sourceURL=webpack://sat/./node_modules/split.js/dist/split.js?")},"./src/main.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sat */ "./src/sat.ts");\n/* harmony import */ var _node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/rangy2/bundles/index.umd */ "./node_modules/rangy2/bundles/index.umd.js");\n/* harmony import */ var _node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_split_js_dist_split__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/split.js/dist/split */ "./node_modules/split.js/dist/split.js");\n/* harmony import */ var _node_modules_split_js_dist_split__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_split_js_dist_split__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../node_modules/hotkeys-js/dist/hotkeys */ "./node_modules/hotkeys-js/dist/hotkeys.js");\n/* harmony import */ var _node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3__);\n\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nlet g_zumen_clicked = false;\r\nlet sat;\r\n/*\r\n * ====================== ページ読み込み完了時の動作関連 ======================\r\n */\r\nwindow.addEventListener("load", () => __awaiter(void 0, void 0, void 0, function* () {\r\n    const tool_type = document.getElementById("tool_type").innerText;\r\n    // content_root, content_window設定\r\n    let content_root, content_window;\r\n    if (tool_type === "pdf_canvas") {\r\n        // @ts-ignore\r\n        window.decoratePage = decoratePage;\r\n        yield new Promise((resolve, reject) => {\r\n            const timer1 = setInterval(() => {\r\n                if (document.querySelector("iframe").contentWindow.document.body &&\r\n                    document.querySelector("iframe").contentWindow.document.body\r\n                        .innerHTML !== "") {\r\n                    clearInterval(timer1);\r\n                    resolve(null);\r\n                }\r\n            }, 500);\r\n        }).then(() => {\r\n            content_window = document.querySelector("iframe").contentWindow;\r\n            content_root = content_window.document.getElementById("viewer");\r\n        });\r\n    }\r\n    else {\r\n        content_window = window;\r\n        content_root = document.getElementById("content");\r\n    }\r\n    // スペクトルバー初期化\r\n    const div_style = window.getComputedStyle(document.getElementById("spectrum"));\r\n    const cv = document.getElementById("spectrum_bar");\r\n    cv.width = Number(div_style.width.replace("px", ""));\r\n    cv.height = Number(div_style.height.replace("px", ""));\r\n    // オブジェクト、HTMLなど初期化\r\n    const tmp = document.getElementById("selected_color").innerHTML;\r\n    const selected_color = tmp ? JSON.parse(tmp) : {};\r\n    sat = new _sat__WEBPACK_IMPORTED_MODULE_0__.Sat(tool_type, content_root, content_window, cv, selected_color, document.getElementById("dark_mode").checked, document.getElementById("block_mode").checked);\r\n    initializeHTML();\r\n    setKeyboardPreference();\r\n    // 初期描画\r\n    sat.word.setOption(getWordOption());\r\n    sat.word.invert(sat.content_root);\r\n    setColoredQuery();\r\n    setTimeout(() => {\r\n        sat.cv.updateData();\r\n        sat.cv.draw();\r\n        sat.comment.sort();\r\n        sat.comment.arrange();\r\n    }, 0);\r\n}));\r\n/**\r\n * キーボード操作の挙動を定義\r\n */\r\nfunction setKeyboardPreference() {\r\n    // ショートカットキーを追加\r\n    // @ts-ignore\r\n    (_node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3___default().filter) = (event) => {\r\n        return true; // contenteditableな要素の中でもショートカットを有効にする\r\n    };\r\n    if (sat.tool_type === "free_text") {\r\n        _node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3___default()("ctrl+b", (event, _handler) => {\r\n            event.preventDefault();\r\n            decorate("bold");\r\n        });\r\n        _node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3___default()("ctrl+u", (event, _handler) => {\r\n            event.preventDefault();\r\n            decorate("underline");\r\n        });\r\n    }\r\n    _node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3___default()("ctrl+h", (event, _handler) => {\r\n        var _a;\r\n        event.preventDefault();\r\n        highlight();\r\n        (_a = sat.content_window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\r\n    });\r\n    _node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3___default()("ctrl+d", (event, _handler) => {\r\n        var _a;\r\n        event.preventDefault();\r\n        dehighlight();\r\n        (_a = sat.content_window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\r\n    });\r\n    _node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3___default()("ctrl+1", (event, _handler) => {\r\n        event.preventDefault();\r\n        comment();\r\n    });\r\n    _node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3___default()("ctrl+s", (event, _handler) => {\r\n        event.preventDefault();\r\n        if (sat.tool_type === "pdf_canvas") {\r\n            // showSpinner("ダウンロードファイル生成中...", 150, downloadJSON);\r\n        }\r\n        else {\r\n            showSpinner("ダウンロードファイル生成中...", 150, downloadHTML);\r\n        }\r\n    });\r\n    _node_modules_hotkeys_js_dist_hotkeys__WEBPACK_IMPORTED_MODULE_3___default()("ctrl+shift+f", (event, _handler) => {\r\n        event.preventDefault();\r\n        function setCaretToEnd(target) {\r\n            const range = document.createRange();\r\n            const sel = window.getSelection();\r\n            range.selectNodeContents(target);\r\n            range.collapse(false);\r\n            sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();\r\n            sel === null || sel === void 0 ? void 0 : sel.addRange(range);\r\n            target.focus();\r\n            range.detach();\r\n        }\r\n        const div = document.getElementById("word_query");\r\n        div.click();\r\n        setCaretToEnd(div);\r\n    });\r\n    // backspaceでページが戻ることを防止＆コメント部分の削除処理等を定義\r\n    // 以下のコードを参考に作成\r\n    // https://stackoverflow.com/questions/1495219/how-can-i-prevent-the-backspace-key-from-navigating-back\r\n    document.addEventListener("keydown", (e) => {\r\n        var _a, _b, _c;\r\n        if (!(e instanceof KeyboardEvent))\r\n            return;\r\n        if (e.keyCode === 8) {\r\n            let doPrevent = true;\r\n            const d = e.target;\r\n            if (d.id === "word_query") {\r\n                doPrevent = false;\r\n            }\r\n            else if (d.isContentEditable) {\r\n                doPrevent = false;\r\n                const div_element = (_c = (_b = (_a = window\r\n                    .getSelection()) === null || _a === void 0 ? void 0 : _a.anchorNode) === null || _b === void 0 ? void 0 : _b.parentElement) === null || _c === void 0 ? void 0 : _c.closest("div.comment");\r\n                // コメントが空のときにBackspaceが押されたら、コメントを削除\r\n                if (div_element &&\r\n                    (div_element.innerText === "\\n" || div_element.innerText === "")) {\r\n                    doPrevent = true;\r\n                    sat.updated = true;\r\n                    sat.comment.remove(div_element.getAttribute("comment_id"));\r\n                    sat.cv.updateData();\r\n                    sat.cv.draw();\r\n                    sat.comment.sort();\r\n                    sat.comment.arrange();\r\n                }\r\n            }\r\n            else if (d.tagName === "INPUT") {\r\n                doPrevent = false;\r\n            }\r\n            else if (d.tagName === "TEXTAREA") {\r\n                doPrevent = false;\r\n            }\r\n            if (doPrevent) {\r\n                e.preventDefault();\r\n                return;\r\n            }\r\n        }\r\n        else if (e.keyCode === 112) {\r\n            toggleZumenColumn();\r\n            e.preventDefault();\r\n        }\r\n    });\r\n}\r\n/**\r\n * イベントハンドラの設定など\r\n */\r\nfunction initializeHTML() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        document.addEventListener("click", (e) => {\r\n            if (!(e.target instanceof HTMLElement))\r\n                return;\r\n            const color_picker = document.getElementById("color_picker");\r\n            if (color_picker.style.display !== "none" &&\r\n                !color_picker.contains(e.target)) {\r\n                color_picker.style.display = "none";\r\n            }\r\n            const color_picker_comment = document.getElementById("color_picker_comment");\r\n            if (color_picker_comment.style.display !== "none" &&\r\n                !color_picker_comment.contains(e.target)) {\r\n                color_picker_comment.style.display = "none";\r\n                color_picker.setAttribute("comment_id", "");\r\n            }\r\n            const help_box = document.getElementById("help");\r\n            if (help_box.style.display !== "none" && !help_box.contains(e.target)) {\r\n                help_box.style.display = "none";\r\n            }\r\n        });\r\n        // イベントハンドラ追加（コメント側）\r\n        Array.from(document.querySelectorAll("div.comment")).forEach((div_element) => {\r\n            div_element.addEventListener("mouseover", (e) => {\r\n                sat.comment.onMouseOver(div_element.getAttribute("comment_id"));\r\n            });\r\n            div_element.addEventListener("mouseout", (e) => {\r\n                // 子要素への移動であれば無視\r\n                if (e instanceof MouseEvent &&\r\n                    e.relatedTarget instanceof HTMLElement &&\r\n                    e.relatedTarget.parentElement !== null &&\r\n                    e.relatedTarget.parentElement.closest(`div.comment[comment_id="${div_element.getAttribute("comment_id")}"]`) !== null) {\r\n                    return;\r\n                }\r\n                sat.comment.onMouseOut(div_element.getAttribute("comment_id"));\r\n            });\r\n        });\r\n        Array.from(document.getElementById("comment_svg").querySelectorAll("polygon")).forEach((polygon_element) => {\r\n            polygon_element.addEventListener("click", (e) => {\r\n                if (e.target instanceof SVGPolygonElement) {\r\n                    sat.comment.onPolygonClick(e.target.getAttribute("comment_id"));\r\n                }\r\n            });\r\n        });\r\n        // イベントハンドラ追加（被コメント側）\r\n        Array.from(sat.content_root.querySelectorAll("span.commented")).forEach((span_element) => {\r\n            span_element.addEventListener("mouseover", (e) => {\r\n                sat.comment.onMouseOver(span_element.getAttribute("comment_id"));\r\n            });\r\n            span_element.addEventListener("mouseout", (e) => {\r\n                // 子要素への移動であれば無視\r\n                if (e instanceof MouseEvent &&\r\n                    e.relatedTarget instanceof HTMLElement &&\r\n                    e.relatedTarget.parentElement !== null &&\r\n                    e.relatedTarget.parentElement.closest(`span.commented[comment_id="${span_element.getAttribute("comment_id")}"]`) !== null) {\r\n                    return;\r\n                }\r\n                sat.comment.onMouseOut(span_element.getAttribute("comment_id"));\r\n            });\r\n        });\r\n        // スペクトルバー関連\r\n        if (sat.tool_type === "pdf_canvas") {\r\n            sat.content_root.parentElement.addEventListener("scroll", (e) => {\r\n                sat.cv.draw();\r\n                const comment_container = document.getElementById("comment_container");\r\n                comment_container.scrollTo(0, e.target.scrollTop *\r\n                    (comment_container.scrollHeight / e.target.scrollHeight));\r\n            });\r\n        }\r\n        else {\r\n            document.getElementById("main").addEventListener("scroll", (e) => {\r\n                sat.cv.draw();\r\n            });\r\n        }\r\n        window.addEventListener("resize", (_e) => {\r\n            setTimeout(() => {\r\n                const div_style = window.getComputedStyle(document.getElementById("spectrum"));\r\n                const cv = document.getElementById("spectrum_bar");\r\n                cv.width = Number(div_style.width.replace("px", ""));\r\n                cv.height = Number(div_style.height.replace("px", ""));\r\n                // 何故か、sat.cv.updateData();を先にしないとsat.comment.sort()とarrange()が機能しない。。。\r\n                sat.cv.updateData();\r\n                sat.cv.draw();\r\n                sat.comment.sort();\r\n                sat.comment.arrange();\r\n            }, 0);\r\n        });\r\n        sat.cv.element.onclick = (e) => {\r\n            if (sat.tool_type === "pdf_canvas") {\r\n                sat.content_root.parentElement.scrollTo(0, e.layerY *\r\n                    (sat.content_root.parentElement.scrollHeight /\r\n                        sat.cv.element.height) -\r\n                    sat.cv.element.height / 2);\r\n            }\r\n            else {\r\n                document\r\n                    .getElementById("main")\r\n                    .scrollTo(0, e.layerY *\r\n                    (document.getElementById("main").scrollHeight /\r\n                        sat.cv.element.height) -\r\n                    sat.cv.element.height / 2);\r\n            }\r\n        };\r\n        sat.cv.element.onmousedown = (e) => {\r\n            sat.cv.element.onmousemove = (e) => {\r\n                if (sat.tool_type === "pdf_canvas") {\r\n                    sat.content_root.parentElement.scrollTo(0, e.layerY *\r\n                        (sat.content_root.parentElement.scrollHeight /\r\n                            sat.cv.element.height) -\r\n                        sat.cv.element.height / 2);\r\n                    document\r\n                        .getElementById("comment_container")\r\n                        .scrollTo(0, e.layerY *\r\n                        (document.getElementById("comment_container").scrollHeight /\r\n                            sat.cv.element.height) -\r\n                        sat.cv.element.height / 2);\r\n                }\r\n                else {\r\n                    document\r\n                        .getElementById("main")\r\n                        .scrollTo(0, e.layerY *\r\n                        (document.getElementById("main").scrollHeight /\r\n                            sat.cv.element.height) -\r\n                        sat.cv.element.height / 2);\r\n                }\r\n            };\r\n            sat.cv.element.onmouseup = () => {\r\n                sat.cv.element.onmousemove = null;\r\n                sat.cv.element.onmouseup = null;\r\n            };\r\n        };\r\n        sat.cv.element.onmouseover = () => {\r\n            sat.cv.element.onmousemove = null;\r\n        };\r\n        // ページ移動時のアラート\r\n        window.addEventListener("beforeunload", (e) => {\r\n            if (sat.updated) {\r\n                e.returnValue =\r\n                    "編集内容が保存されていませんが、ページを離れてもよろしいですか？";\r\n            }\r\n        });\r\n        // 上のメニューのイベントハンドラ\r\n        document.getElementById("doc_title").addEventListener("input", (e) => {\r\n            if (!(e.target instanceof HTMLInputElement))\r\n                return;\r\n            if (e.target.value !== "") {\r\n                document.title = e.target.value;\r\n            }\r\n            else {\r\n                if (sat.tool_type === "free_text") {\r\n                    document.title = "SAT（フリーテキスト版）";\r\n                }\r\n                else if (sat.tool_type === "pdf_canvas") {\r\n                    document.title = "SAT（PDF版）";\r\n                }\r\n                else if (sat.tool_type === "pdf_svg") {\r\n                    document.title = "SAT（PDF版）";\r\n                }\r\n                else {\r\n                    document.title = "SAT (Spectrum Annotation Tool)";\r\n                }\r\n            }\r\n        });\r\n        document.getElementById("block_mode").addEventListener("change", (e) => {\r\n            // @ts-ignore\r\n            localStorage.setItem("SAT_block_mode", e.target.checked.toString());\r\n            showSpinner("ワード反転中...", 10, () => {\r\n                if (e.target instanceof HTMLInputElement && e.target.checked) {\r\n                    sat.word.block_mode = true;\r\n                    sat.word.invert(sat.content_root);\r\n                    sat.cv.updateData();\r\n                    sat.cv.draw();\r\n                }\r\n                else {\r\n                    sat.word.block_mode = false;\r\n                    sat.word.invert(sat.content_root);\r\n                    sat.cv.updateData();\r\n                    sat.cv.draw();\r\n                }\r\n            });\r\n        });\r\n        document.getElementById("btn_bold").addEventListener("click", () => {\r\n            decorate("bold");\r\n        });\r\n        document.getElementById("btn_underline").addEventListener("click", () => {\r\n            decorate("underline");\r\n        });\r\n        document.getElementById("btn_highlight").addEventListener("click", () => {\r\n            var _a;\r\n            highlight();\r\n            (_a = sat.content_window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\r\n        });\r\n        document\r\n            .getElementById("btn_select_highlight_color")\r\n            .addEventListener("click", (e) => {\r\n            if (!(e.target instanceof HTMLElement))\r\n                return;\r\n            const color_picker = document.getElementById("color_picker");\r\n            color_picker.setAttribute("mode", "highlight");\r\n            color_picker.style.display = "block";\r\n            color_picker.style.left = `${sat.getOffset(e.target, document.body).offset_left +\r\n                e.target.offsetWidth / 2 -\r\n                document.getElementById("color_picker").offsetWidth / 2}px`;\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        });\r\n        document\r\n            .getElementById("btn_select_comment_color")\r\n            .addEventListener("click", (e) => {\r\n            if (!(e.target instanceof HTMLElement))\r\n                return;\r\n            const color_picker = document.getElementById("color_picker");\r\n            color_picker.setAttribute("mode", "comment");\r\n            color_picker.style.display = "block";\r\n            color_picker.style.left = `${sat.getOffset(e.target, document.body).offset_left +\r\n                e.target.offsetWidth / 2 -\r\n                document.getElementById("color_picker").offsetWidth / 2}px`;\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        });\r\n        document.getElementById("btn_erase").addEventListener("click", (e) => {\r\n            var _a;\r\n            dehighlight();\r\n            (_a = sat.content_window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\r\n        });\r\n        document.getElementById("btn_comment").addEventListener("click", () => {\r\n            comment();\r\n        });\r\n        document.getElementById("btn_download").addEventListener("click", () => {\r\n            showSpinner("ダウンロードファイル生成中...", 150, downloadHTML);\r\n        });\r\n        document.getElementById("btn_figureOn").addEventListener("click", () => {\r\n            toggleZumenColumn();\r\n            document.getElementById("li_figureOn").classList.add("hidden");\r\n            document.getElementById("li_figureOff").classList.remove("hidden");\r\n        });\r\n        document.getElementById("btn_figureOff").addEventListener("click", () => {\r\n            toggleZumenColumn();\r\n            document.getElementById("li_figureOff").classList.add("hidden");\r\n            document.getElementById("li_figureOn").classList.remove("hidden");\r\n        });\r\n        document.getElementById("btn_editUnlock").addEventListener("click", () => {\r\n            document.getElementById("content").contentEditable = "true";\r\n            document.getElementById("li_editUnlock").classList.add("hidden");\r\n            document.getElementById("li_editLock").classList.remove("hidden");\r\n        });\r\n        document.getElementById("btn_editLock").addEventListener("click", () => {\r\n            document.getElementById("content").contentEditable = "false";\r\n            document.getElementById("li_editLock").classList.add("hidden");\r\n            document.getElementById("li_editUnlock").classList.remove("hidden");\r\n        });\r\n        document.getElementById("word_query").addEventListener("keydown", (e) => {\r\n            if (e.key === "Enter") {\r\n                e.preventDefault();\r\n                showSpinner("ワード反転中...", 0, () => {\r\n                    sat.word.setOption(getWordOption());\r\n                    sat.word.invert(sat.content_root);\r\n                    setColoredQuery();\r\n                    sat.cv.updateData();\r\n                    sat.cv.draw();\r\n                    document.getElementById("word_query").blur();\r\n                    sat.updated = true;\r\n                });\r\n            }\r\n        });\r\n        document\r\n            .getElementById("btn_word_inversion_help")\r\n            .addEventListener("click", (e) => {\r\n            if (!(e.target instanceof HTMLElement))\r\n                return;\r\n            const help_box = document.getElementById("help");\r\n            if (help_box.style.display === "block") {\r\n                help_box.style.display = "none";\r\n            }\r\n            else {\r\n                help_box.style.display = "block";\r\n                help_box.innerHTML = `\r\n            <h3>ワード反転方法</h3>\r\n            <p> （入力例）<img src="./img/word_inversion_example.png" style="vertical-align: middle";/></p>\r\n            <ul>\r\n              <li>\r\n                反転したいワードを、スペースで区切って入力した後、Enterキーを押してください。\r\n              </li>\r\n              <li>＋で繋いだワードは同じ色に反転されます。</li>\r\n              <li>\r\n                _（アンダーバー）は、色反転時に半角スペースとして変換されます。英語の複数語をまとめて色反転したい場合にご使用ください。<br />\r\n              </li>\r\n              <li>\r\n                /でワードを囲むと、正規表現として認識されます。（例：/請求項[0-9０-９]+/）<br />\r\n                末尾のオプションは省略可能です。（自動でgオプションがつきます）\r\n              </li>\r\n  \r\n              <li>\r\n                ワード反転後、ボックス中のワードをクリックすると、反転色を変更できます。\r\n              </li>\r\n              <li>\r\n                ブロック反転にチェックを入れると、漢字・カタカナ・英数字を含めたブロック単位で反転を行います。\r\n              </li>\r\n            </ul>`;\r\n                help_box.style.left = `${sat.getOffset(e.target, document.body).offset_left +\r\n                    e.target.offsetWidth / 2 -\r\n                    document.getElementById("help").offsetWidth / 2}px`;\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n            }\r\n        });\r\n        document.getElementById("btn_marker_help").addEventListener("click", (e) => {\r\n            if (!(e.target instanceof HTMLElement))\r\n                return;\r\n            const help_box = document.getElementById("help");\r\n            if (help_box.style.display === "block") {\r\n                help_box.style.display = "none";\r\n            }\r\n            else {\r\n                help_box.style.display = "block";\r\n                help_box.innerHTML = `\r\n          <h3>本文の装飾方法</h3>\r\n          <p> マーカーなどの装飾を行いたい箇所をドラッグして選択した後に、ボタンを押してください。</p>\r\n          <p> コメントボタンで挿入したコメントを削除したい場合は、右側のコメントボックス内の文字を全て削除して空にした状態で、さらにBackspaceキーを押してください。</p>\r\n          <p> 挿入したコメントの吹き出しの三角形をクリックすると、コメントの色を変えることができます。</p>\r\n          <p> マーカーを削除したい場合は、<b>同じ色で</b>削除したい部分をマークするか、ハイライト削除ボタンを使用してください。</p>`;\r\n                help_box.style.left = `${sat.getOffset(e.target, document.body).offset_left +\r\n                    e.target.offsetWidth / 2 -\r\n                    document.getElementById("help").offsetWidth / 2}px`;\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n            }\r\n        });\r\n        document.getElementById("dark_mode").addEventListener("change", (e) => {\r\n            if (!(e.target instanceof HTMLInputElement))\r\n                return;\r\n            localStorage.setItem("SAT_dark_mode", e.target.checked.toString());\r\n            if (e.target.checked) {\r\n                document.body.classList.add("dark");\r\n                sat.dark_mode = true;\r\n            }\r\n            else {\r\n                document.body.classList.remove("dark");\r\n                sat.dark_mode = false;\r\n            }\r\n            if (sat.tool_type === "pdf_canvas") {\r\n                if (e.target.checked) {\r\n                    sat.content_window.document.body.classList.add("dark");\r\n                }\r\n                else {\r\n                    sat.content_window.document.body.classList.remove("dark");\r\n                }\r\n            }\r\n            sat.cv.updateData();\r\n            sat.cv.draw();\r\n        });\r\n        // カラーピッカー関連\r\n        document.getElementById("colormap").addEventListener("mouseout", (e) => {\r\n            colorPickerMouseOut();\r\n        });\r\n        Array.from(document.getElementById("colormap").querySelectorAll("area")).forEach((area) => {\r\n            area.addEventListener("mouseover", (e) => {\r\n                colorPickerMouseOver(area.alt);\r\n            });\r\n            area.addEventListener("click", (e) => {\r\n                colorPickerClick(area.alt);\r\n            });\r\n        });\r\n        // オブザーバ関係（サイズ変更の監視）\r\n        const comment_removal_observer = new MutationObserver((mutations) => {\r\n            mutations.forEach((mutation) => {\r\n                mutation.removedNodes.forEach((node) => {\r\n                    if (node instanceof HTMLSpanElement) {\r\n                        if (node.classList.contains("commented")) {\r\n                            const comment_id = node.getAttribute("comment_id");\r\n                            const span_with_same_comment_id = document\r\n                                .getElementById("content")\r\n                                .querySelector(`span.commented[comment_id="${comment_id}"]`);\r\n                            if (!span_with_same_comment_id) {\r\n                                sat.comment.remove(comment_id);\r\n                            }\r\n                            sat.cv.updateData();\r\n                            sat.cv.draw();\r\n                            sat.comment.sort();\r\n                            sat.comment.arrange();\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        comment_removal_observer.observe(document.getElementById("content"), {\r\n            childList: true,\r\n            subtree: true,\r\n        });\r\n        const comment_resize_observer = new MutationObserver((mutations) => {\r\n            sat.comment.arrange();\r\n        });\r\n        comment_resize_observer.observe(document.getElementById("comment_div"), {\r\n            attributes: true,\r\n            childList: true,\r\n            subtree: true,\r\n            characterData: true,\r\n            attributeFilter: ["offsetHeight", "clientHeight", "scrollHeight", "height"],\r\n        });\r\n        const body_resize_observer = new MutationObserver((mutations) => {\r\n            sat.cv.updateData();\r\n            sat.cv.draw();\r\n            sat.comment.sort();\r\n            sat.comment.arrange();\r\n        });\r\n        body_resize_observer.observe(document.body, {\r\n            attributes: true,\r\n            attributeFilter: [\r\n                "offsetHeight",\r\n                "clientHeight",\r\n                "scrollHeight",\r\n                "height",\r\n                "offsetWidth",\r\n                "clientWidth",\r\n                "scrollWidth",\r\n                "width",\r\n            ],\r\n        });\r\n        const cv_resize_observer = new MutationObserver((mutations) => {\r\n            sat.cv.updateData();\r\n            sat.cv.draw();\r\n            sat.comment.sort();\r\n            sat.comment.arrange();\r\n        });\r\n        cv_resize_observer.observe(document.getElementById("spectrum"), {\r\n            attributes: true,\r\n            attributeFilter: [\r\n                "offsetHeight",\r\n                "clientHeight",\r\n                "scrollHeight",\r\n                "height",\r\n                "offsetWidth",\r\n                "clientWidth",\r\n                "scrollWidth",\r\n                "width",\r\n            ],\r\n        });\r\n        // 本文部分のイベントハンドラ登録\r\n        document.getElementById("content").addEventListener("input", (e) => {\r\n            sat.updated = true;\r\n            sat.comment.arrange();\r\n        });\r\n        // 簡易ワード反転のクリックイベント（color_pickerのクリックイベント時にこのイベントの実行を中止させたいので、focusでなくclickイベントを選択）\r\n        document.getElementById("word_query").addEventListener("click", (e) => {\r\n            if (!(e.target instanceof HTMLElement))\r\n                return;\r\n            e.target.querySelectorAll("span").forEach((span) => {\r\n                span.className = "";\r\n                span.onclick = null;\r\n            });\r\n        });\r\n        // ワード設定ボックスへの貼り付け時に書式を消す\r\n        document.getElementById("word_query").addEventListener("paste", (e) => {\r\n            e.preventDefault();\r\n            const text = e.clipboardData.getData("text/plain");\r\n            document.execCommand("insertHTML", false, text);\r\n        });\r\n        // split.js設定\r\n        if (sat.tool_type !== "pdf_canvas") {\r\n            // flexboxをresizableに\r\n            _node_modules_split_js_dist_split__WEBPACK_IMPORTED_MODULE_2___default()(["#content", "#comment_container"], {\r\n                sizes: [70, 30],\r\n                minSize: [50, 50],\r\n                elementStyle: (_dimension, size, _gutterSize, _index) => {\r\n                    return {\r\n                        width: `${size}%`,\r\n                    };\r\n                },\r\n                onDragEnd: (_sizes) => {\r\n                    // setTimeoutしないと、コメント位置が正しく設定されない（何故？）\r\n                    setTimeout(() => {\r\n                        sat.comment.arrange();\r\n                        sat.cv.updateData();\r\n                        sat.cv.draw();\r\n                    }, 0);\r\n                    sat.comment.arrange();\r\n                    sat.cv.updateData();\r\n                    sat.cv.draw();\r\n                },\r\n                gutterSize: 5,\r\n            });\r\n        }\r\n        // マーカー色設定などのロード\r\n        if (document.getElementById("dark_mode").checked.toString() !== localStorage.getItem("SAT_dark_mode")) {\r\n            document.getElementById("dark_mode").click();\r\n        }\r\n        if (document.getElementById("block_mode").checked.toString() !== localStorage.getItem("SAT_block_mode")) {\r\n            document.getElementById("block_mode").click();\r\n        }\r\n        let highlight_color, comment_color;\r\n        if ((highlight_color = localStorage.getItem("SAT_highlight_color"))) {\r\n            const btn_highlight = document.getElementById("btn_highlight");\r\n            btn_highlight.setAttribute("highlightColor", highlight_color);\r\n            btn_highlight.style.backgroundColor = highlight_color;\r\n        }\r\n        if ((comment_color = localStorage.getItem("SAT_comment_color"))) {\r\n            const btn_comment = document.getElementById("btn_comment");\r\n            btn_comment.setAttribute("commentColor", comment_color);\r\n            btn_comment.style.backgroundColor = comment_color;\r\n        }\r\n        if (sat.tool_type === "tazumen") {\r\n            // flexboxをresizableに\r\n            _node_modules_split_js_dist_split__WEBPACK_IMPORTED_MODULE_2___default()(["div#zumen", "div#text"], {\r\n                sizes: [30, 70],\r\n                elementStyle: (_dimension, size, gutterSize, _index) => {\r\n                    return {\r\n                        width: `calc(${size}% - ${gutterSize + 20}px)`,\r\n                    };\r\n                },\r\n                onDragEnd: (_sizes) => {\r\n                    // setTimeoutしないと、コメント位置が正しく設定されない（何故？）\r\n                    setTimeout(() => {\r\n                        sat.comment.arrange();\r\n                        sat.cv.updateData();\r\n                        sat.cv.draw();\r\n                    }, 0);\r\n                    sat.comment.arrange();\r\n                    sat.cv.updateData();\r\n                    sat.cv.draw();\r\n                },\r\n                gutterSize: 4,\r\n            });\r\n            addZumenEventHandler();\r\n        }\r\n        //\r\n        if (sat.tool_type === "tazumen" &&\r\n            document.getElementById("content").innerHTML === "tazumen_gyomu") {\r\n            const modal = document.getElementById("paste_modal_window");\r\n            modal.style.display = "block";\r\n            const input = document.getElementById("paste_modal_input");\r\n            input.focus();\r\n            input.addEventListener("paste", (e) => {\r\n                // @ts-ignore\r\n                const paste_data = (e.clipboardData || window.clipboardData).getData("text");\r\n                console.log(paste_data);\r\n                modal.style.display = "none";\r\n                e.preventDefault();\r\n                setDataFromTazumenBrowser(JSON.parse(paste_data));\r\n            });\r\n        }\r\n        // 多図面ブラウザ等からのデータの受信に関する処理\r\n        window.addEventListener("message", (e) => {\r\n            console.log(e);\r\n            switch (e.data.message_type) {\r\n                case "tazumen":\r\n                    if (e.origin === "http://npsx8.jpo.go.jp") {\r\n                        setDataFromTazumenBrowser(e.data);\r\n                    }\r\n                    break;\r\n                case "free_text":\r\n                    sat.content_root.innerText = e.data.innerText;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n    });\r\n}\r\n/*\r\n * ====================== ダウンロード、ロード関連 ======================\r\n */\r\n/**\r\n * HTMLファイルの保存（参考：https://blog.mudatobunka.org/entry/2015/12/23/211425）\r\n */\r\nfunction downloadHTML() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        // テキストノードを整理\r\n        sat.content_root.normalize();\r\n        // 画像をbase64形式に変更\r\n        Array.from(document.querySelectorAll("img")).forEach((img) => {\r\n            if (img.src.substr(0, 11) !== "data:image/") {\r\n                img.src = getDataUrl(img);\r\n            }\r\n        });\r\n        // <html> を cloneし、色々と処理\r\n        const html = document.querySelector("html").cloneNode(true);\r\n        Array.from(html.querySelectorAll(".gutter")).forEach((gutter) => {\r\n            gutter.remove();\r\n        });\r\n        html.querySelector("#spinner").classList.remove("visible");\r\n        Array.from(html.querySelectorAll("script")).forEach((script) => {\r\n            if (/log[^/]*\\.js/.test(script.src)) {\r\n                script.remove();\r\n            }\r\n        });\r\n        html\r\n            .querySelector("#doc_title")\r\n            .setAttribute("value", html.querySelector("#doc_title").value);\r\n        // if ((html.querySelector("#dark_mode")! as HTMLInputElement).checked) {\r\n        //   html.querySelector("#dark_mode")!.setAttribute("checked", "");\r\n        // }\r\n        if (html.querySelector("#block_mode").checked) {\r\n            html.querySelector("#block_mode").setAttribute("checked", "");\r\n        }\r\n        html.querySelector("#word_query").innerHTML =\r\n            html.querySelector("#word_query").innerHTML;\r\n        html.querySelector("#selected_color").innerHTML = JSON.stringify(sat.word.selected_color);\r\n        // 外部CSS, JSファイルをダウンロードしてHTMLに埋め込む\r\n        let promiseFactories = Array.from(html.querySelectorAll("link"))\r\n            .filter((link) => {\r\n            return link.rel === "stylesheet";\r\n        })\r\n            .map((link) => {\r\n            return () => new Promise((resolve, reject) => {\r\n                fetch(link.href)\r\n                    .then((res) => {\r\n                    return res.text();\r\n                })\r\n                    .then((text) => {\r\n                    link.remove();\r\n                    const style = document.createElement("style");\r\n                    style.innerHTML = text;\r\n                    html.querySelector("head").appendChild(style);\r\n                    resolve(null);\r\n                });\r\n            });\r\n        });\r\n        yield executeSequentially(promiseFactories);\r\n        promiseFactories = Array.from(html.querySelectorAll("script"))\r\n            .filter((script) => {\r\n            return script.src !== undefined && script.src !== "";\r\n        })\r\n            .map((script) => {\r\n            return () => new Promise((resolve, reject) => {\r\n                if (script.src.indexOf("js-tazumen") === -1) {\r\n                    fetch(script.src)\r\n                        .then((res) => {\r\n                        return res.text();\r\n                    })\r\n                        .then((text) => {\r\n                        script.removeAttribute("src");\r\n                        script.innerHTML = text;\r\n                        resolve(null);\r\n                    });\r\n                }\r\n                else {\r\n                    resolve(null);\r\n                }\r\n            });\r\n        });\r\n        yield executeSequentially(promiseFactories);\r\n        const src = html.innerHTML;\r\n        // 上記の src には DOCTYPE が含まれていないので別途用意\r\n        const name = document.doctype.name;\r\n        const publicId = document.doctype.publicId;\r\n        const systemID = document.doctype.systemId;\r\n        const doctype = "<!DOCTYPE " +\r\n            name +\r\n            (publicId ? \' PUBLIC "\' + publicId + \'"\' : "") +\r\n            (systemID ? \' "\' + systemID + \'"\' : "") +\r\n            ">";\r\n        // <html> タグを再構成\r\n        let htmlTag = "<html";\r\n        const attrs = html.attributes;\r\n        for (let i = 0, n = attrs.length; i < n; i++) {\r\n            const attr = attrs[i];\r\n            htmlTag +=\r\n                " " +\r\n                    attr.nodeName +\r\n                    (attr.nodeValue ? \'="\' + attr.nodeValue + \'"\' : "");\r\n        }\r\n        htmlTag += ">";\r\n        // ソースコードを Blob オブジェクトに変換してURLを取得\r\n        const blob = new Blob([doctype, "\\n", htmlTag, "\\n", src, "\\n</html>"]);\r\n        const url = window.URL || window.webkitURL;\r\n        const blobURL = url.createObjectURL(blob);\r\n        // <a> を新たに作成し、ダウンロード用の設定をいろいろ\r\n        const a = document.createElement("a");\r\n        a.download = `${document.title}.html`;\r\n        a.href = blobURL;\r\n        document.body.appendChild(a);\r\n        a.click();\r\n        document.body.removeChild(a);\r\n        sat.updated = false;\r\n    });\r\n}\r\nfunction executeSequentially(promiseFactories) {\r\n    let result = Promise.resolve();\r\n    promiseFactories.forEach((promiseFactory) => {\r\n        result = result.then(promiseFactory);\r\n    });\r\n    return result;\r\n}\r\n/**\r\n * 画像のbase64形式での表現を取得\r\n * @param {object} img imgエレメントのオブジェクト\r\n */\r\nfunction getDataUrl(img) {\r\n    const canvas = document.createElement("canvas");\r\n    const ctx = canvas.getContext("2d");\r\n    canvas.width = img.naturalWidth;\r\n    canvas.height = img.naturalHeight;\r\n    ctx.drawImage(img, 0, 0);\r\n    return canvas.toDataURL("image/png");\r\n}\r\n/*\r\n * ====================== decoration, comment関連 ======================\r\n */\r\n/**\r\n * 選択された領域の修飾\r\n * @param {string} class_name 修飾に対応するclassの名前\r\n */\r\nfunction decorate(class_name) {\r\n    const selection = sat.content_window.getSelection();\r\n    if (!selection)\r\n        return;\r\n    // 選択範囲がsat.content_rootに含まれていなければ終了\r\n    if (!sat.content_root.contains(selection.anchorNode) ||\r\n        !sat.content_root.contains(selection.focusNode)) {\r\n        return;\r\n    }\r\n    sat.decoration.add(class_name);\r\n    sat.updated = true;\r\n}\r\n/**\r\n * 選択された領域のハイライト\r\n */\r\nfunction highlight() {\r\n    const color_code = document\r\n        .getElementById("btn_highlight")\r\n        .getAttribute("highlightColor");\r\n    const selection = sat.content_window.getSelection();\r\n    if (!selection)\r\n        return;\r\n    // 選択範囲がsat.content_rootに含まれていなければ終了\r\n    if (!sat.content_root.contains(selection.anchorNode) ||\r\n        !sat.content_root.contains(selection.focusNode)) {\r\n        return;\r\n    }\r\n    sat.decoration.highlight(color_code);\r\n    sat.updated = true;\r\n}\r\n/**\r\n * 選択された領域のハイライト削除\r\n */\r\nfunction dehighlight() {\r\n    sat.decoration.dehighlight();\r\n}\r\n/**\r\n * 選択された領域へのコメントを追加\r\n */\r\nfunction comment() {\r\n    const color_code = document\r\n        .getElementById("btn_comment")\r\n        .getAttribute("commentColor");\r\n    const selection = sat.content_window.getSelection();\r\n    if (!selection)\r\n        return;\r\n    // 選択範囲がsat.content_rootに含まれていなければ終了\r\n    if (!sat.content_root.contains(selection.anchorNode) ||\r\n        !sat.content_root.contains(selection.focusNode)) {\r\n        return;\r\n    }\r\n    // Selectionにコメントが含まれている場合、コメントを追加しない\r\n    const sel = (0,_node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_1__.getSelection)(sat.content_window);\r\n    if (sel.rangeCount) {\r\n        if (sel.getRangeAt(0).getNodes([], (node) => {\r\n            return node instanceof Element && node.classList.contains("commented");\r\n        }).length > 0) {\r\n            alert("同じ領域に複数のコメントをつけることはできません。");\r\n            return;\r\n        }\r\n        if (sel\r\n            .getRangeAt(0)\r\n            .commonAncestorContainer.parentElement.closest("span.commented") !==\r\n            null) {\r\n            alert("同じ領域に複数のコメントをつけることはできません。");\r\n            return;\r\n        }\r\n    }\r\n    sat.comment.addComment(color_code);\r\n    sat.updated = true;\r\n}\r\n/*\r\n * ====================== ワード反転関連 ======================\r\n */\r\n/**\r\n * #word_query内に入力されたクエリからワード反転のオプションを生成\r\n * @return {object} satオブジェクトに渡すワード反転のオプション\r\n */\r\nfunction getWordOption() {\r\n    const query = document\r\n        .getElementById("word_query")\r\n        .innerText.trim()\r\n        .replace(/[\\r\\n]+/g, " ");\r\n    if (query === "" || /^\\s+$/.test(query)) {\r\n        return {};\r\n    }\r\n    const word_arr = query.split(/\\s+/).map((word) => {\r\n        const slash_match = word.match(/(^\\/|[^\\\\]\\/|\\/$)/g);\r\n        if (slash_match && slash_match.length > 0 && slash_match.length % 2 === 0) {\r\n            // クエリの最小単位を求める再帰関数（先頭から順に最小単位を切り取っていく）\r\n            return getQueryUnitArr(word, []);\r\n        }\r\n        else {\r\n            return word.split(/[+＋]/g);\r\n        }\r\n    });\r\n    // 反転ワード情報を更新\r\n    const colors = sat.word.getWordColors(word_arr.length);\r\n    const word_option = {};\r\n    word_arr.forEach((words, i) => {\r\n        words.forEach((word) => {\r\n            if (!word_option[i]) {\r\n                word_option[i] = { words: [], color: "" };\r\n            }\r\n            if (word.substr(0, 1) !== "/") {\r\n                word_option[i].words.push(word.replace(/_/g, " "));\r\n            }\r\n            else {\r\n                word_option[i].words.push(word);\r\n            }\r\n            word_option[i].color = colors[i];\r\n        });\r\n    });\r\n    return word_option;\r\n}\r\nfunction getQueryUnitArr(word, acc) {\r\n    if (word.substr(0, 1) !== "/") {\r\n        // 先頭は正規表現でない -> 最先の+を見つけてそこで区切る\r\n        const pos_plus = word.indexOf("+");\r\n        if (pos_plus === -1) {\r\n            acc.push(word);\r\n            return acc;\r\n        }\r\n        else {\r\n            acc.push(word.substring(0, pos_plus));\r\n            return getQueryUnitArr(word.substring(pos_plus + 1), acc);\r\n        }\r\n    }\r\n    else {\r\n        // 先頭は正規表現 -> 最先の/（ただし\\/は除外）を見つけてそこで区切る\r\n        const mt = word.match(/[^\\\\]\\/[dgimsuy]*/);\r\n        if (!mt)\r\n            return acc; // 何かがおかしい\r\n        acc.push(word.substring(0, mt.index + mt[0].length));\r\n        if (word.length === mt.index + mt[0].length) {\r\n            return acc;\r\n        }\r\n        else {\r\n            return getQueryUnitArr(word.substring(mt.index + mt[0].length + 1), acc);\r\n        }\r\n    }\r\n}\r\n/**\r\n * #word_query内に、キーワードを各反転色で反転させたHTMLをセット\r\n */\r\nfunction setColoredQuery() {\r\n    const query_div = document.getElementById("word_query");\r\n    query_div.innerHTML = "";\r\n    Object.keys(sat.word.option).forEach((color_id) => {\r\n        sat.word.option[color_id].words.forEach((word, j) => {\r\n            const span = document.createElement("span");\r\n            span.innerText = word.replace(/ /g, "_");\r\n            span.setAttribute("mode", "word_inversion");\r\n            span.setAttribute("color_id", color_id);\r\n            span.classList.add("query_unit");\r\n            span.classList.add(`word_inversion_class${color_id}`);\r\n            span.onclick = (e) => {\r\n                if (!(e.target instanceof HTMLElement))\r\n                    return;\r\n                const color_picker = document.getElementById("color_picker");\r\n                color_picker.setAttribute("color_id", e.target.getAttribute("color_id"));\r\n                color_picker.style.display = "block";\r\n                color_picker.style.left = `${sat.getOffset(e.target, document.body).offset_left +\r\n                    e.target.offsetWidth / 2 -\r\n                    document.getElementById("color_picker").offsetWidth / 2}px`;\r\n                color_picker.setAttribute("mode", "word_inversion");\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n            };\r\n            query_div.appendChild(span);\r\n            if (j !== sat.word.option[color_id].words.length - 1) {\r\n                query_div.appendChild(document.createTextNode("+"));\r\n            }\r\n        });\r\n        query_div.appendChild(document.createTextNode(" "));\r\n    });\r\n}\r\n/**\r\n * color pickerのマウスオーバーイベント\r\n * @param {string} color_code マウスオーバーされたカラーコード\r\n */\r\n// @ts-ignore\r\nfunction colorPickerMouseOver(color_code) {\r\n    const mode = document.getElementById("color_picker").getAttribute("mode");\r\n    if (mode === "highlight") {\r\n        return;\r\n    }\r\n    else if (mode === "comment") {\r\n        const comment_id = document\r\n            .getElementById("color_picker")\r\n            .getAttribute("comment_id");\r\n        if (comment_id) {\r\n            const comment_div = document\r\n                .getElementById("comment_div")\r\n                .querySelector(`div.comment[comment_id="${comment_id}"]`);\r\n            const polygon_element = document\r\n                .getElementById("comment_svg")\r\n                .querySelector(`polygon[comment_id="${comment_id}"]`);\r\n            const commented_span_arr = document.querySelectorAll(`span.commented[comment_id="${comment_id}"]`);\r\n            comment_div.style.backgroundColor = color_code;\r\n            comment_div.style.borderColor = color_code;\r\n            polygon_element.style.fill = color_code;\r\n            polygon_element.style.stroke = color_code;\r\n            commented_span_arr.forEach((span) => {\r\n                span.style.backgroundColor = color_code;\r\n                span.style.borderColor = color_code;\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        const color_id = document\r\n            .getElementById("color_picker")\r\n            .getAttribute("color_id");\r\n        Array.from(document.getElementById("word_query").querySelectorAll("span"))\r\n            .filter((span) => {\r\n            return span.getAttribute("color_id") === color_id;\r\n        })\r\n            .forEach((span) => {\r\n            console.log(color_code);\r\n            span.style.setProperty("background-color", color_code, "important");\r\n            span.style.color = sat.word.calcWordColor(color_code);\r\n        });\r\n    }\r\n}\r\n/**\r\n * color pickerのマウスアウトイベント\r\n */\r\n// @ts-ignore\r\nfunction colorPickerMouseOut() {\r\n    const mode = document.getElementById("color_picker").getAttribute("mode");\r\n    if (mode === "highlight") {\r\n        return;\r\n    }\r\n    else if (mode === "comment") {\r\n        const comment_id = document\r\n            .getElementById("color_picker")\r\n            .getAttribute("comment_id");\r\n        if (comment_id) {\r\n            const comment_div = document\r\n                .getElementById("comment_div")\r\n                .querySelector(`div.comment[comment_id="${comment_id}"]`);\r\n            const polygon_element = document\r\n                .getElementById("comment_svg")\r\n                .querySelector(`polygon[comment_id="${comment_id}"]`);\r\n            const commented_span_arr = document.querySelectorAll(`span.commented[comment_id="${comment_id}"]`);\r\n            let color_code = document\r\n                .getElementById("color_picker")\r\n                .getAttribute("comment_color");\r\n            comment_div.style.backgroundColor = color_code;\r\n            comment_div.style.borderColor = color_code;\r\n            polygon_element.style.fill = color_code;\r\n            polygon_element.style.stroke = color_code;\r\n            commented_span_arr.forEach((span) => {\r\n                span.style.backgroundColor = color_code;\r\n                span.style.borderColor = color_code;\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        const color_id = document\r\n            .getElementById("color_picker")\r\n            .getAttribute("color_id");\r\n        Array.from(document.getElementById("word_query").querySelectorAll("span"))\r\n            .filter((span) => {\r\n            return span.getAttribute("color_id") === color_id;\r\n        })\r\n            .forEach((span) => {\r\n            span.removeAttribute("style");\r\n        });\r\n    }\r\n}\r\n/**\r\n * color pickerがクリックされた時に実行。色を変更して反転処理を行う。\r\n * @param {string} color_code クリックされたカラーコード\r\n */\r\n// @ts-ignore\r\nfunction colorPickerClick(color_code) {\r\n    color_code = color_code.toLowerCase();\r\n    const mode = document.getElementById("color_picker").getAttribute("mode");\r\n    if (mode === "highlight") {\r\n        localStorage.setItem("SAT_highlight_color", color_code);\r\n        const btn_highlight = document.getElementById("btn_highlight");\r\n        btn_highlight.setAttribute("highlightColor", color_code);\r\n        btn_highlight.style.backgroundColor = color_code;\r\n    }\r\n    else if (mode === "comment") {\r\n        localStorage.setItem("SAT_comment_color", color_code);\r\n        document.getElementById("btn_comment").style.backgroundColor = color_code;\r\n        document\r\n            .getElementById("btn_comment")\r\n            .setAttribute("commentColor", color_code);\r\n        document.getElementById("color_picker").setAttribute("comment_id", "");\r\n        sat.cv.updateData();\r\n        sat.cv.draw();\r\n    }\r\n    else {\r\n        const color_id = document\r\n            .getElementById("color_picker")\r\n            .getAttribute("color_id");\r\n        showSpinner("ワード反転中...", 0, () => {\r\n            sat.word.setColor(Number(color_id), color_code);\r\n            sat.word.invert(sat.content_root);\r\n            setColoredQuery();\r\n            sat.cv.updateData();\r\n            sat.cv.draw();\r\n        });\r\n    }\r\n    document.getElementById("color_picker").style.display = "none";\r\n}\r\n/*\r\n * ====================== 多図面関連 ======================\r\n */\r\n/**\r\n * 図面等のデータをセット\r\n * @param {object} data 図面等のデータ\r\n */\r\n// @ts-ignore\r\nfunction setDataFromTazumenBrowser(data) {\r\n    document.getElementById("doc_title").value =\r\n        data.page_title;\r\n    document.title = data.page_title;\r\n    document.getElementById("content").innerHTML = data.text_content;\r\n    const zumen_container = document.getElementById("zumen");\r\n    const caption_dic = {};\r\n    const zumen_tags = document\r\n        .getElementById("content")\r\n        .innerText.match(/【図[^】]+】[^【]+/g);\r\n    if (zumen_tags) {\r\n        zumen_tags.forEach((caption) => {\r\n            const arr = caption.match(/【(図[^】]+)】([^【]+)/);\r\n            if ((arr === null || arr === void 0 ? void 0 : arr.length) === 3) {\r\n                caption_dic[zenkaku2Hankaku(arr[1])] = arr[2];\r\n            }\r\n        });\r\n    }\r\n    data.zumen_arr.forEach((zumen) => {\r\n        const container = document.createElement("div");\r\n        const title = document.createElement("h3");\r\n        title.innerHTML = zumen.title;\r\n        container.appendChild(title);\r\n        if (caption_dic[zumen.title]) {\r\n            const caption = document.createElement("div");\r\n            caption.innerText = caption_dic[zumen.title];\r\n            caption.classList.add("cap");\r\n            container.appendChild(caption);\r\n        }\r\n        const img = document.createElement("img");\r\n        img.src = zumen.data_url;\r\n        // if ((document.getElementById("dark_mode")! as HTMLInputElement).checked) {\r\n        //   img.classList.add("dark");\r\n        // }\r\n        container.appendChild(img);\r\n        const memo = document.createElement("div");\r\n        memo.setAttribute("contenteditable", "true");\r\n        memo.setAttribute("placeholder", "メモを入力...");\r\n        memo.classList.add("memo");\r\n        container.appendChild(memo);\r\n        const hr = document.createElement("hr");\r\n        container.appendChild(hr);\r\n        zumen_container.appendChild(container);\r\n    });\r\n    addZumenEventHandler();\r\n    // ワード反転\r\n    document.getElementById("word_query").innerText = data.word_arr\r\n        .map((words) => {\r\n        return words.join("+");\r\n    })\r\n        .join(" ");\r\n    sat.word.setOption(getWordOption());\r\n    sat.word.invert(sat.content_root);\r\n    setColoredQuery();\r\n    sat.cv.updateData();\r\n    sat.cv.draw();\r\n    document.getElementById("spinner").classList.remove("visible");\r\n    sat.updated = false;\r\n}\r\n/**\r\n * 図面のクリックイベントを設定\r\n */\r\nfunction addZumenEventHandler() {\r\n    // 図面の回転\r\n    Array.from(document.getElementById("zumen").querySelectorAll("img")).forEach((img) => {\r\n        img.addEventListener("click", (e) => {\r\n            if (!(e.target instanceof HTMLElement))\r\n                return;\r\n            if (g_zumen_clicked) {\r\n                // ダブルクリック判定（画像の別ウィンドウ起動）\r\n                const zumen_subwin = window.open("", "", `width=500,height=500,scrollbars=yes,resizable=yes,status=yes`);\r\n                // タイトル設定\r\n                let title = document.title;\r\n                if (e.target.parentElement.querySelector("h3")) {\r\n                    title = `図${e.target\r\n                        .parentElement.querySelector("h3")\r\n                        .innerText.substr(1)} - ${title}`;\r\n                }\r\n                zumen_subwin.document.title = title;\r\n                const h3 = document.createElement("h3");\r\n                h3.innerText = title;\r\n                h3.style.textAlign = "center";\r\n                h3.style.height = "20px";\r\n                zumen_subwin.document.body.append(h3);\r\n                // 画像設定\r\n                const img_div = document.createElement("div");\r\n                img_div.style.width = "90%";\r\n                img_div.style.height = "90%";\r\n                img_div.style.textAlign = "center";\r\n                const img_clone = e.target.cloneNode();\r\n                img_clone.style.objectFit = "contain";\r\n                img_clone.style.width = "90%";\r\n                img_clone.style.height = "90%";\r\n                if (document.body.classList.contains("dark")) {\r\n                    zumen_subwin.document.body.style.color = "#ddd";\r\n                    zumen_subwin.document.body.style.backgroundColor = "#333";\r\n                    img_clone.style.filter = "invert(100%)";\r\n                }\r\n                img_div.appendChild(img_clone);\r\n                zumen_subwin.document.body.append(img_div);\r\n                // 説明文設定\r\n                if (e.target.parentElement.querySelector("div.cap")) {\r\n                    const caption = document.createElement("div");\r\n                    caption.innerText = e.target.parentElement.querySelector("div.cap").innerText;\r\n                    caption.style.textAlign = "center";\r\n                    zumen_subwin.document.body.append(caption);\r\n                }\r\n                g_zumen_clicked = false;\r\n                return;\r\n            }\r\n            g_zumen_clicked = true;\r\n            setTimeout(() => {\r\n                return ((e) => {\r\n                    if (g_zumen_clicked && e.target instanceof HTMLImageElement) {\r\n                        // シングルクリック判定（画像の回転）\r\n                        e.target.src = rotateBase64Image90deg(e.target.src);\r\n                    }\r\n                    g_zumen_clicked = false;\r\n                })(e);\r\n            }, 300);\r\n        });\r\n    });\r\n    // 本文中の図面へのリンク\r\n    Array.from(document.getElementById("content").querySelectorAll("a")).forEach((a) => {\r\n        a.addEventListener("click", (e) => {\r\n            if (!(e.target instanceof HTMLElement))\r\n                return;\r\n            const fig_num = zenkaku2Hankaku(e.target.innerText);\r\n            Array.from(document.getElementById("zumen").querySelectorAll("h3")).some((h3) => {\r\n                if (h3.innerText === fig_num) {\r\n                    h3.scrollIntoView();\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n        });\r\n    });\r\n}\r\n/**\r\n * 図面の表示切り替え\r\n */\r\nfunction toggleZumenColumn() {\r\n    const zumen = document.getElementById("zumen");\r\n    if (zumen === null)\r\n        return;\r\n    if (window.getComputedStyle(zumen).display === "none") {\r\n        zumen.style.display = "inline";\r\n    }\r\n    else {\r\n        zumen.style.display = "none";\r\n    }\r\n    sat.cv.updateData();\r\n    sat.cv.draw();\r\n    sat.comment.sort();\r\n    sat.comment.arrange();\r\n}\r\n// https://stackoverflow.com/questions/17040360/javascript-function-to-rotate-a-base-64-image-by-x-degrees-and-return-new-base64\r\nfunction rotateBase64Image90deg(base64Image) {\r\n    // create an off-screen canvas\r\n    const offScreenCanvas = document.createElement("canvas");\r\n    const offScreenCanvasCtx = offScreenCanvas.getContext("2d");\r\n    // cteate Image\r\n    const img = new Image();\r\n    img.src = base64Image;\r\n    // set its dimension to rotated size\r\n    offScreenCanvas.height = img.width;\r\n    offScreenCanvas.width = img.height;\r\n    // rotate and draw source image into the off-screen canvas:\r\n    offScreenCanvasCtx.rotate((90 * Math.PI) / 180);\r\n    offScreenCanvasCtx.translate(0, -offScreenCanvas.width);\r\n    offScreenCanvasCtx.drawImage(img, 0, 0);\r\n    // encode image to data-uri with base64\r\n    return offScreenCanvas.toDataURL("image/jpeg", 100);\r\n}\r\n// @ts-ignore\r\nfunction invertImage() {\r\n    Array.from(document.getElementById("zumen").querySelectorAll("img")).forEach((img) => {\r\n        if (img.classList.contains("dark")) {\r\n            img.classList.remove("dark");\r\n        }\r\n        else {\r\n            img.classList.add("dark");\r\n        }\r\n    });\r\n}\r\n/*\r\n * ====================== PDF版関連 ======================\r\n */\r\n// /**\r\n//  * コメントなどの内容をJSONファイルとしてダウンロード\r\n//  */\r\n// async function downloadJSON() {\r\n//   const download_object = JSON.parse(\r\n//     JSON.stringify({\r\n//       word_option: sat.word.option,\r\n//       word_selected_color: sat.word.selected_color,\r\n//       word_query: document.getElementById("word_query")!.innerHTML,\r\n//       // decoration: sat.decoration.element_info,\r\n//       comment_span: sat.comment.span_info,\r\n//       comment_box: sat.comment.box_info,\r\n//     })\r\n//   );\r\n//   const blob = new Blob([JSON.stringify(download_object)], {\r\n//     type: "text/json",\r\n//   });\r\n//   const url = window.URL || window.webkitURL;\r\n//   const blobURL = url.createObjectURL(blob);\r\n//   // <a> を新たに作成し、ダウンロード用の設定をいろいろ\r\n//   const a = document.createElement("a");\r\n//   a.download = `${sat.pdf.file_name}.json`;\r\n//   a.href = blobURL;\r\n//   document.body.appendChild(a);\r\n//   a.click();\r\n//   document.body.removeChild(a);\r\n//   sat.updated = false;\r\n// }\r\n// /**\r\n//  * コメントなどの内容を含んだJSONデータのロード\r\n//  * @param {object} json_object ロードするJSONオブジェクト\r\n//  */\r\n// // @ts-ignore\r\n// function loadJSON(json_object: any) {\r\n//   sat.pdf.init();\r\n//   sat.word.option = json_object.word_option;\r\n//   sat.word.selected_color = json_object.word_selected_color;\r\n//   document.getElementById("word_query")!.innerHTML = json_object.word_query;\r\n//   // sat.decoration.element_info = json_object.decoration;\r\n//   sat.comment.span_info = json_object.comment_span;\r\n//   sat.comment.box_info = json_object.comment_box;\r\n// }\r\n// /**\r\n//  * PDFの読み込みや拡大縮小に合わせてコメント部分を調整\r\n//  */\r\n// // @ts-ignore\r\n// function updateCommentContainer() {\r\n//   if (!sat) return;\r\n//   const ifr = document.querySelector("iframe")!.contentWindow!.document;\r\n//   const ifr_scroll_height =\r\n//     ifr.getElementById("toolbarViewer")!.scrollHeight +\r\n//     ifr.getElementById("viewerContainer")!.scrollHeight;\r\n//   Array.from(\r\n//     document.getElementById("comment_div")!.querySelectorAll("div.comment")\r\n//   ).forEach((div) => {\r\n//     sat.comment.box_info[div.getAttribute("comment_id")!]!.content = (\r\n//       div as HTMLElement\r\n//     ).innerText;\r\n//   });\r\n//   sat.comment.box_sorted_info = [];\r\n//   const comment_svg = document.getElementById("comment_svg")!;\r\n//   const comment_div = document.getElementById("comment_div")!;\r\n//   (comment_svg.childNodes[0]! as HTMLElement).innerHTML = "";\r\n//   comment_svg.style.height = `${ifr_scroll_height}px`;\r\n//   comment_div.innerHTML = "";\r\n//   comment_div.style.height = `${ifr_scroll_height}px`;\r\n// }\r\n// @ts-ignore\r\nfunction decoratePage(page_number) {\r\n    // sat.pdf.restore(page_number);\r\n    const mark_content_root = sat.content_window.document\r\n        .getElementById("viewer")\r\n        .querySelector(`div.page[data-page-number="${page_number}"]`);\r\n    sat.word.invert(mark_content_root);\r\n    sat.cv.updateData();\r\n    sat.cv.draw();\r\n}\r\n// // @ts-ignore\r\n// function initPDFViewer() {\r\n//   sat.updated = false;\r\n//   (\r\n//     document.getElementById("comment_svg")!.childNodes[0]! as HTMLElement\r\n//   ).innerHTML = "";\r\n//   document.getElementById("comment_div")!.innerHTML = "";\r\n//   sat.pdf.init();\r\n// }\r\n/*\r\n * ====================== その他 ======================\r\n */\r\n/**\r\n * スピナー画面を表示して実行\r\n */\r\nfunction showSpinner(message, msec, exec_func) {\r\n    document.getElementById("loading_message").innerHTML = message;\r\n    const spinner = document.getElementById("spinner");\r\n    spinner.classList.add("visible");\r\n    new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            exec_func();\r\n            resolve(null);\r\n        }, msec);\r\n    }).then(() => {\r\n        spinner.classList.remove("visible");\r\n    });\r\n}\r\n/**\r\n * 英数字を半角にする\r\n * https://www.yoheim.net/blog.php?q=20191101\r\n * @param {string} str 英数字を半角にしたい文字列\r\n * @return {string} 英数字を半角にした文字列\r\n */\r\nfunction zenkaku2Hankaku(str) {\r\n    return str.replace(/[Ａ-Ｚａ-ｚ０-９]/g, (s) => {\r\n        return String.fromCharCode(s.charCodeAt(0) - 0xfee0);\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://sat/./src/main.ts?')},"./src/sat.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Sat": () => (/* binding */ Sat)\n/* harmony export */ });\n/* harmony import */ var _node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/rangy2/bundles/index.umd */ "./node_modules/rangy2/bundles/index.umd.js");\n/* harmony import */ var _node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_rangy_classapplier_bundles_index_umd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/rangy-classapplier/bundles/index.umd */ "./node_modules/rangy-classapplier/bundles/index.umd.js");\n/* harmony import */ var _node_modules_rangy_classapplier_bundles_index_umd__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_rangy_classapplier_bundles_index_umd__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_mark_js_dist_mark__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/mark.js/dist/mark */ "./node_modules/mark.js/dist/mark.js");\n/* harmony import */ var _node_modules_mark_js_dist_mark__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mark_js_dist_mark__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\nclass Sat {\r\n    // pdf: SatPDF; // PDF版の特別な処理を扱うオブジェクト\r\n    constructor(tool_type, content_root, content_window, cv, selected_color, dark_mode, block_mode) {\r\n        this.updated = false; // 内容が更新されているかのフラグ（ページ遷移に対して警告を出す用）\r\n        /**\r\n         * 対応するspan要素を削除。ただし、複数のクラスや属性があった場合は、指定したクラスや属性だけ削除してspanを残す\r\n         * @param {span_element} el 削除したいspan\r\n         * @param {class_name_arr} array 削除したいクラス名の配列\r\n         * @param {attribute_name_arr} array 削除したい属性名の配列\r\n         */\r\n        this.removeSpan = (span, class_name_arr, attribute_name_arr) => {\r\n            class_name_arr.forEach((class_name) => {\r\n                span.classList.remove(class_name);\r\n            });\r\n            attribute_name_arr.forEach((attribute_name) => {\r\n                span.removeAttribute(attribute_name);\r\n            });\r\n            // if (span.classList.length === 0 && span.getAttribute("style") === null) {\r\n            if (span.classList.length === 0) {\r\n                const parent = span.parentElement;\r\n                span.replaceWith(...Array.from(span.childNodes));\r\n                parent.normalize();\r\n            }\r\n        };\r\n        /**\r\n         * container要素におけるelement要素のxy座標を取得\r\n         * @return { offset_top: x座標, offset_left: y座標 }\r\n         */\r\n        this.getOffset = (element, container) => {\r\n            let offset_top = element.offsetTop;\r\n            let offset_left = element.offsetLeft;\r\n            let offset_parent = element.offsetParent;\r\n            while (offset_parent !== container && offset_parent !== null) {\r\n                offset_top +=\r\n                    offset_parent.offsetTop +\r\n                        Number(this.content_window\r\n                            .getComputedStyle(offset_parent)\r\n                            .borderWidth.slice(0, -2)) *\r\n                            2; // TODO ここは怪しいかも\r\n                offset_left += offset_parent.offsetLeft;\r\n                offset_parent = offset_parent.offsetParent;\r\n            }\r\n            return { offset_top: offset_top, offset_left: offset_left };\r\n        };\r\n        /**\r\n         * RGBをカラーコードに変換\r\n         * https://decks.hatenadiary.org/entry/20100907/1283843862\r\n         * @param col "rgb(R, G, B)"の形式の文字列\r\n         * @return "#000000"形式のカラーコード\r\n         */\r\n        this.rgbTo16 = (col) => {\r\n            var _a;\r\n            return ("#" +\r\n                ((_a = col\r\n                    .match(/\\d+/g)) === null || _a === void 0 ? void 0 : _a.map((a) => {\r\n                    return ("0" + parseInt(a).toString(16)).slice(-2);\r\n                }).join("")));\r\n        };\r\n        /**\r\n         * HSLをRGBのカラーコードに変換\r\n         * @param _h\r\n         * @param s\r\n         * @param l\r\n         * @returns "#000000"形式のカラーコード\r\n         */\r\n        this.hslToRgb = (_h, s, l) => {\r\n            const h = Math.min(_h, 359) / 60;\r\n            const c = (1 - Math.abs(2 * l - 1)) * s;\r\n            const x = c * (1 - Math.abs((h % 2) - 1));\r\n            const m = l - 0.5 * c;\r\n            let r = m, g = m, b = m;\r\n            if (h < 1) {\r\n                (r += c), (g = +x), (b += 0);\r\n            }\r\n            else if (h < 2) {\r\n                (r += x), (g += c), (b += 0);\r\n            }\r\n            else if (h < 3) {\r\n                (r += 0), (g += c), (b += x);\r\n            }\r\n            else if (h < 4) {\r\n                (r += 0), (g += x), (b += c);\r\n            }\r\n            else if (h < 5) {\r\n                (r += x), (g += 0), (b += c);\r\n            }\r\n            else if (h < 6) {\r\n                (r += c), (g += 0), (b += x);\r\n            }\r\n            else {\r\n                (r = 0), (g = 0), (b = 0);\r\n            }\r\n            return ("#" +\r\n                `0${Math.floor(r * 255).toString(16)}`.slice(-2) +\r\n                `0${Math.floor(g * 255).toString(16)}`.slice(-2) +\r\n                `0${Math.floor(b * 255).toString(16)}`.slice(-2));\r\n        };\r\n        /**\r\n         * 要素のセレクタを取得（参考：https://akabeko.me/blog/2015/06/get-element-selector/）\r\n         * @param {object} el セレクタを取得したいエレメント\r\n         * @returns {string} セレクタ\r\n         */\r\n        this.getSelectorFromElement = (el) => {\r\n            const names = [];\r\n            while (el) {\r\n                let name = el.nodeName.toLowerCase();\r\n                if (el.id) {\r\n                    name += "#" + el.id;\r\n                    names.unshift(name);\r\n                    break;\r\n                }\r\n                const index = this.getSiblingElementsIndex(el, name);\r\n                name += ":nth-of-type(" + index + ")";\r\n                names.unshift(name);\r\n                el = el.parentNode;\r\n            }\r\n            return names;\r\n        };\r\n        /**\r\n         * 親要素に対して何番目の子要素かを取得\r\n         * https://github.com/akabekobeko/examples-web-app/tree/get-element-selector/get-element-selector\r\n         * @param el 調べたい子要素\r\n         * @return index 何番目かを表す数値\r\n         */\r\n        this.getSiblingElementsIndex = (el, name) => {\r\n            let index = 1;\r\n            let sib = el;\r\n            while ((sib = sib.previousElementSibling)) {\r\n                if (sib.nodeName.toLowerCase() === name) {\r\n                    ++index;\r\n                }\r\n            }\r\n            return index;\r\n        };\r\n        this.tool_type = tool_type;\r\n        this.content_root = content_root;\r\n        this.content_window = content_window;\r\n        this.dark_mode = dark_mode;\r\n        this.word = new SatWord(this, selected_color, block_mode);\r\n        this.cv = new SatCanvas(this, cv);\r\n        this.comment = new SatComment(this);\r\n        this.decoration = new SatDecoration(this);\r\n        // this.pdf = new SatPDF(this);\r\n    }\r\n}\r\nclass SatWord {\r\n    constructor(sat, selected_color, block_mode) {\r\n        this.option = {};\r\n        this.selected_color = {};\r\n        this.block_mode = false;\r\n        this.setOption = (option) => {\r\n            this.option = option;\r\n            // 手動で選択した色があればそれをセットする\r\n            Object.keys(this.option).forEach((color_id) => {\r\n                if (this.option[color_id] && this.selected_color[color_id]) {\r\n                    this.option[color_id].color = this.selected_color[color_id];\r\n                }\r\n            });\r\n        };\r\n        this.setColor = (color_id, color) => {\r\n            this.selected_color[color_id] = color;\r\n            if (this.option[color_id])\r\n                this.option[color_id].color = color;\r\n        };\r\n        this.clear = (root) => {\r\n            Array.from(root.querySelectorAll("span.word_inversion")).forEach((span) => {\r\n                Array.from(span.classList).forEach((class_name) => {\r\n                    if (class_name.indexOf("word_inversion") !== -1) {\r\n                        span.classList.remove(class_name);\r\n                    }\r\n                });\r\n                span.removeAttribute("data-markjs");\r\n                if (span.classList.length === 0 && span.attributes.length === 1) {\r\n                    // spanを削除\r\n                    const parent = span.parentNode;\r\n                    while (span.firstChild)\r\n                        parent.insertBefore(span.firstChild, span);\r\n                    parent.removeChild(span);\r\n                    parent.normalize(); // 反転されていたテキストノードを周囲のテキストノードと結合\r\n                }\r\n            });\r\n            let preexisting_style = this.sat.content_window.document.head.querySelector("style#SAT_word_inversion");\r\n            if (preexisting_style !== null) {\r\n                preexisting_style.remove();\r\n            }\r\n            if (this.sat.tool_type === "pdf_canvas") {\r\n                preexisting_style = document.head.querySelector("style#SAT_word_inversion");\r\n                if (preexisting_style !== null) {\r\n                    preexisting_style.remove();\r\n                }\r\n            }\r\n        };\r\n        this.getWordColors = (length) => {\r\n            // https://gist.github.com/ibrechin/2489005 から拝借して一部改変\r\n            const colors = [];\r\n            const step = 360 / length;\r\n            const l = this.sat.dark_mode ? 0.3 : 0.7;\r\n            for (let i = 0; i < length; i++) {\r\n                // 適当に設定\r\n                colors.push(this.sat.hslToRgb((270 + i * step) % 360, 1.0, l));\r\n            }\r\n            return colors;\r\n        };\r\n        this.calcWordColor = (bg_color) => {\r\n            const brightness = parseInt(bg_color.substr(1, 2), 16) * 0.299 + // Red\r\n                parseInt(bg_color.substr(3, 2), 16) * 0.587 + // Green\r\n                parseInt(bg_color.substr(5, 2), 16) * 0.114; // Blue\r\n            return brightness >= 140 ? "#111" : "#eed";\r\n        };\r\n        this.sat = sat;\r\n        this.selected_color = selected_color;\r\n        this.block_mode = block_mode;\r\n    }\r\n    invert(root) {\r\n        // ワード反転解除\r\n        this.clear(root);\r\n        const mark_instance = new (_node_modules_mark_js_dist_mark__WEBPACK_IMPORTED_MODULE_2___default())(root);\r\n        const mark_options = {\r\n            element: "span",\r\n            accuracy: "partially",\r\n            separateWordSearch: false,\r\n            acrossElements: true,\r\n            ignoreJoiners: true,\r\n            ignorePunctuation: ":;.,-–—‒_(){}[]!\'\\"+=".split(""),\r\n            each: (elem) => {\r\n                elem.classList.add("word_inversion");\r\n            },\r\n            className: "",\r\n        };\r\n        if (this.sat.tool_type === "web") {\r\n            mark_options.accuracy = "complementary";\r\n        }\r\n        const colorStyle = document.createElement("style");\r\n        colorStyle.type = "text/css";\r\n        colorStyle.id = "SAT_word_inversion";\r\n        const colorStyle_pdf_parent = document.createElement("style");\r\n        colorStyle_pdf_parent.type = "text/css";\r\n        colorStyle_pdf_parent.id = "SAT_word_inversion";\r\n        this.sat.content_window.document.head.prepend(colorStyle);\r\n        if (this.sat.tool_type === "pdf_canvas") {\r\n            document.head.prepend(colorStyle_pdf_parent);\r\n        }\r\n        for (const color_id in this.option) {\r\n            mark_options.className = `word_inversion_class${Number(color_id)}`;\r\n            const color_code = this.option[color_id].color;\r\n            colorStyle.sheet.insertRule(`span.word_inversion_class${color_id} {background-color: ${color_code} !important; color: ${this.sat.tool_type === "pdf_canvas"\r\n                ? color_code\r\n                : this.calcWordColor(color_code)}}`, 0);\r\n            if (this.sat.tool_type === "pdf_canvas") {\r\n                colorStyle_pdf_parent.sheet.insertRule(`span.word_inversion_class${color_id} {background-color: ${color_code} ! important; color: ${this.calcWordColor(color_code)}}`, 0);\r\n            }\r\n            this.option[color_id].words.forEach((word) => {\r\n                if (/^\\/.*\\/[dgimsuy]*$/.test(word)) {\r\n                    // 元々正規表現の場合\r\n                    let re_option = "";\r\n                    if (word.match(/([dgimsuy]+)$/)) {\r\n                        re_option = word.match(/([dgimsuy]+)$/)[0];\r\n                        word = word.slice(0, -re_option.length);\r\n                    }\r\n                    let reg_ex;\r\n                    if (this.block_mode) {\r\n                        reg_ex = new RegExp(`[ア-ンー一-龥0-9０-９a-zA-Zａ-ｚＡ-Ｚ.．]*${word.slice(1, -1)}[ア-ンー一-龥0-9０-９a-zA-Zａ-ｚＡ-Ｚ.．]*`, re_option);\r\n                    }\r\n                    else {\r\n                        reg_ex = new RegExp(word.slice(1, -1), re_option);\r\n                    }\r\n                    mark_instance.markRegExp(reg_ex, mark_options);\r\n                }\r\n                else {\r\n                    // 正規表現でない場合\r\n                    if (this.block_mode) {\r\n                        const reg_ex = new RegExp(`[ア-ンー一-龥0-9０-９a-zA-Zａ-ｚＡ-Ｚ.．]*${word}[ア-ンー一-龥0-9０-９a-zA-Zａ-ｚＡ-Ｚ.．]*`, "i");\r\n                        mark_instance.markRegExp(reg_ex, mark_options);\r\n                    }\r\n                    else {\r\n                        mark_instance.mark(word, mark_options);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\nclass SatCanvas {\r\n    constructor(sat, element) {\r\n        this.word_rect = [];\r\n        this.comment_circle = [];\r\n        this.highlight_rect = [];\r\n        this.updateData = () => {\r\n            // ワード反転のバーの色や位置を更新\r\n            this.word_rect = [];\r\n            const color_dic = {};\r\n            Array.from(new Set(Object.keys(this.sat.word.option).map((color_id) => {\r\n                return this.sat.word.option[color_id].color;\r\n            })))\r\n                .filter((color) => {\r\n                return color !== "";\r\n            })\r\n                .forEach((color, i) => {\r\n                color_dic[color] = i;\r\n            });\r\n            const color_num = Object.keys(color_dic).length;\r\n            const span_parent_height = this.sat.content_root.parentElement.scrollHeight;\r\n            Array.from(this.sat.content_root.querySelectorAll("span.word_inversion")).forEach((span) => {\r\n                const fill_color = this.sat.rgbTo16(window.getComputedStyle(span).backgroundColor);\r\n                const left_offset = this.sat.tool_type === "web" || this.sat.tool_type === "pdf_canvas"\r\n                    ? 0\r\n                    : 35;\r\n                const rect_x = left_offset +\r\n                    (this.element.width - left_offset) *\r\n                        (color_dic[fill_color] / color_num);\r\n                const offset = this.sat.getOffset(span, this.sat.content_root.offsetParent);\r\n                const rect_y = this.element.height * (offset.offset_top / span_parent_height);\r\n                const rect_height = 3 * Math.max(span.offsetHeight / this.element.height, 2);\r\n                this.word_rect.push([\r\n                    fill_color,\r\n                    Math.round(rect_x) - 0.5,\r\n                    Math.round(rect_y - rect_height / 2.0) - 0.5,\r\n                    Math.round((this.element.width - left_offset) / color_num) + 0,\r\n                    5,\r\n                    Math.round(rect_height / 2.0),\r\n                ]);\r\n            });\r\n            // コメント部分の●の位置を更新\r\n            this.comment_circle = [];\r\n            // comment_idごとにグループ化したspan要素の配列を作成する\r\n            const span_element_dic = Array.from(this.sat.content_root.querySelectorAll("span.commented"))\r\n                .map((span) => {\r\n                // それぞれのspanの位置（ページ最初からのoffsetTop, offsetLeft）を計算しておく\r\n                const offset = this.sat.getOffset(span, this.sat.content_root.offsetParent);\r\n                span.setAttribute("offset_top", offset.offset_top.toString());\r\n                span.setAttribute("offset_left", offset.offset_left.toString());\r\n                return span;\r\n            })\r\n                .reduce((r, a) => {\r\n                r[a.getAttribute("comment_id")] = [\r\n                    ...(r[a.getAttribute("comment_id")] || []),\r\n                    a,\r\n                ];\r\n                return r;\r\n            }, {}); // ひとまずcommment_idごとにグループ化した連想配列を作成\r\n            const span_element_arr = Object.keys(span_element_dic)\r\n                .map((key) => {\r\n                // ここで連想配列を配列に変更\r\n                return span_element_dic[key].sort((a, b) => {\r\n                    // グループ内ではoffsetTop、offsetLeftの順にソートしておく\r\n                    if (a.getAttribute("offset_top") !== b.getAttribute("offset_top")) {\r\n                        return a.getAttribute("offset_top") <\r\n                            b.getAttribute("offset_top")\r\n                            ? -1\r\n                            : 1;\r\n                    }\r\n                    else {\r\n                        return a.getAttribute("offset_left") <\r\n                            b.getAttribute("offset_left")\r\n                            ? -1\r\n                            : 1;\r\n                    }\r\n                });\r\n            })\r\n                .sort((a, b) => {\r\n                // グループ間では、最初のspanのoffsetTop、offsetLeftの順にソートしておく\r\n                if (a[0].getAttribute("offset_top") !== b[0].getAttribute("offset_top")) {\r\n                    return a[0].getAttribute("offset_top") <\r\n                        b[0].getAttribute("offset_top")\r\n                        ? -1\r\n                        : 1;\r\n                }\r\n                else {\r\n                    return a[0].getAttribute("offset_left") <\r\n                        b[0].getAttribute("offset_left")\r\n                        ? -1\r\n                        : 1;\r\n                }\r\n            });\r\n            span_element_arr.forEach((span) => {\r\n                this.comment_circle.push({\r\n                    y: this.element.height *\r\n                        (this.sat.getOffset(span[0], this.sat.content_root.offsetParent).offset_top /\r\n                            span_parent_height),\r\n                    color: span[0].style.backgroundColor,\r\n                });\r\n            });\r\n            // ハイライト部分の●の位置を更新\r\n            this.highlight_rect = [];\r\n            Array.from(document.querySelectorAll("span.highlighted")).forEach((span) => {\r\n                this.highlight_rect.push({\r\n                    y: this.element.height *\r\n                        ((this.sat.getOffset(span, this.sat.content_root.offsetParent).offset_top -\r\n                            3) /\r\n                            span_parent_height),\r\n                    color: span.style.backgroundColor,\r\n                });\r\n            });\r\n        };\r\n        this.draw = () => {\r\n            const ctx = this.element.getContext("2d");\r\n            ctx.clearRect(0, 0, this.element.width, this.element.height);\r\n            if (this.sat.tool_type === "web" || this.sat.tool_type === "pdf_canvas") {\r\n                ctx.fillStyle = "black";\r\n                ctx.fillRect(0, 0, 200, window.innerHeight);\r\n            }\r\n            else {\r\n                ctx.fillStyle = "#333333";\r\n                ctx.fillRect(0, 0, 30, window.innerHeight);\r\n            }\r\n            this.word_rect.forEach((rect_arr) => {\r\n                ctx.fillStyle = rect_arr[0];\r\n                ctx.fillRect(rect_arr[1], rect_arr[2], rect_arr[3], rect_arr[4]);\r\n            });\r\n            // ctx.fillStyle = "red";\r\n            this.comment_circle.forEach((comment_circle) => {\r\n                ctx.fillStyle = comment_circle.color;\r\n                ctx.beginPath();\r\n                ctx.arc(10, comment_circle.y, 5, 0, 2 * Math.PI, false);\r\n                ctx.fill();\r\n            });\r\n            this.highlight_rect.forEach((highlight_rect) => {\r\n                ctx.fillStyle = highlight_rect.color;\r\n                ctx.fillRect(20, highlight_rect.y - 5, 10, 10);\r\n            });\r\n            ctx.strokeStyle = "white";\r\n            ctx.lineWidth = 5;\r\n            let scroll_div;\r\n            if (this.sat.tool_type === "pdf_canvas") {\r\n                scroll_div = this.sat.content_root.parentElement;\r\n            }\r\n            else if (this.sat.tool_type === "web") {\r\n                // @ts-ignore\r\n                scroll_div = document.scrollingElement;\r\n            }\r\n            else {\r\n                scroll_div = document.getElementById("main");\r\n            }\r\n            const scrollTop = scroll_div.scrollTop;\r\n            const span_parent_height = scroll_div.scrollHeight;\r\n            const top_height = document.querySelector("div.top")\r\n                ? document.querySelector("div.top").offsetHeight\r\n                : 0;\r\n            ctx.strokeRect(2.5, scrollTop * (this.element.height / span_parent_height), this.element.width - 2.5, (window.innerHeight - top_height) *\r\n                (this.element.height / span_parent_height));\r\n        };\r\n        this.sat = sat;\r\n        this.element = element;\r\n    }\r\n}\r\nclass SatDecoration {\r\n    // element_info: {\r\n    //   selector: string;\r\n    //   page_number: number;\r\n    //   class_name: string;\r\n    //   start: number;\r\n    //   length: number;\r\n    // }[] = [];\r\n    constructor(sat) {\r\n        this.add = (class_name) => {\r\n            (0,_node_modules_rangy_classapplier_bundles_index_umd__WEBPACK_IMPORTED_MODULE_1__.createClassApplier)(class_name, {\r\n                elementTagName: "span",\r\n                normalize: true,\r\n            }).toggleSelection(this.sat.content_window);\r\n        };\r\n        this.highlight = (color_code) => {\r\n            (0,_node_modules_rangy_classapplier_bundles_index_umd__WEBPACK_IMPORTED_MODULE_1__.createClassApplier)("highlighted_tmp", {\r\n                elementTagName: "span",\r\n                normalize: false,\r\n            }).toggleSelection(this.sat.content_window);\r\n            const sel = (0,_node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_0__.getSelection)(this.sat.content_window);\r\n            sel\r\n                .getRangeAt(0)\r\n                .getNodes([], (node) => {\r\n                return (node instanceof HTMLSpanElement &&\r\n                    node.classList.contains("highlighted_tmp"));\r\n            })\r\n                .forEach((span) => {\r\n                span.style.backgroundColor = color_code;\r\n                span.style.borderBottomColor = color_code;\r\n                span.classList.remove("highlighted_tmp");\r\n                span.classList.add("highlighted");\r\n            });\r\n            let parent_highlighted_span = sel\r\n                .getRangeAt(0)\r\n                .commonAncestorContainer.parentElement.closest("span.commented");\r\n            if (parent_highlighted_span) {\r\n                parent_highlighted_span.style.backgroundColor = color_code;\r\n                parent_highlighted_span.classList.remove("highlighted_tmp");\r\n                parent_highlighted_span.classList.add("highlighted");\r\n            }\r\n            this.sat.cv.updateData();\r\n            this.sat.cv.draw();\r\n        };\r\n        this.dehighlight = () => {\r\n            const sel = (0,_node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_0__.getSelection)(this.sat.content_window);\r\n            // 選択領域に包含されるspanのハイライトを削除\r\n            if (sel.rangeCount) {\r\n                sel\r\n                    .getRangeAt(0)\r\n                    .getNodes([1])\r\n                    .forEach((node) => {\r\n                    if (!(node instanceof HTMLSpanElement))\r\n                        return;\r\n                    if (node.classList.length > 0) {\r\n                        Array.from(node.classList).forEach((class_name) => {\r\n                            if (class_name === "highlighted") {\r\n                                node.style.backgroundColor = "";\r\n                                node.style.borderBottomColor = "";\r\n                                this.sat.removeSpan(node, [class_name], []);\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        node.style.backgroundColor = "";\r\n                    }\r\n                });\r\n                // 選択領域を包含するspanのハイライトを削除\r\n                [\r\n                    (0,_node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_0__.getSelection)(this.sat.content_window).getRangeAt(0).startContainer,\r\n                    (0,_node_modules_rangy2_bundles_index_umd__WEBPACK_IMPORTED_MODULE_0__.getSelection)(this.sat.content_window).getRangeAt(0).endContainer,\r\n                ].forEach((container) => {\r\n                    while (container && container !== this.sat.content_root) {\r\n                        const parent_element = container.parentElement;\r\n                        if (container instanceof HTMLSpanElement) {\r\n                            if (container.classList.length > 0) {\r\n                                Array.from(container.classList).forEach((class_name) => {\r\n                                    if (class_name === "highlighted") {\r\n                                        container.style.backgroundColor = "";\r\n                                        container.style.borderBottomColor = "";\r\n                                        this.sat.removeSpan(container, [class_name], []);\r\n                                    }\r\n                                });\r\n                            }\r\n                            else {\r\n                                container.style.backgroundColor = "";\r\n                            }\r\n                        }\r\n                        container = parent_element;\r\n                    }\r\n                });\r\n            }\r\n            this.sat.cv.updateData();\r\n            this.sat.cv.draw();\r\n        };\r\n        this.sat = sat;\r\n    }\r\n}\r\nclass SatComment {\r\n    constructor(sat) {\r\n        this.comment_index = 0;\r\n        this.span_info = {};\r\n        this.box_info = {}; // （PDF版用）コメント内容とページ番号を保持\r\n        this.box_sorted_info = [];\r\n        this.addComment = (color_code) => {\r\n            const comment_id = this.addSpan(color_code);\r\n            this.addBox(comment_id, color_code);\r\n            this.sort();\r\n            this.arrange();\r\n            // コメントボックスにカーソルを移動\r\n            const range = window.document.createRange();\r\n            const el = window.document.querySelector(`div.comment[comment_id="${comment_id}"] > p`);\r\n            range.setStart(el, 0);\r\n            range.setEnd(el, 0);\r\n            window.focus();\r\n            window.getSelection().removeAllRanges();\r\n            window.getSelection().addRange(range);\r\n            this.sat.cv.updateData();\r\n            this.sat.cv.draw();\r\n        };\r\n        this.remove = (comment_id) => {\r\n            var _a;\r\n            this.sat.content_root\r\n                .querySelectorAll(`span.commented[comment_id="${comment_id}"]`)\r\n                .forEach((element, i) => {\r\n                this.sat.removeSpan(element, ["commented", "span_onmouse"], ["comment_id"]);\r\n            });\r\n            // コメントに対応するdiv、polygonを削除\r\n            (_a = document\r\n                .getElementById("comment_div")\r\n                .querySelector(`div.comment[comment_id="${comment_id}"]`)) === null || _a === void 0 ? void 0 : _a.remove();\r\n            Array.from(document\r\n                .getElementById("comment_svg")\r\n                .querySelectorAll(`polygon[comment_id="${comment_id}"]`)).forEach((polygon) => {\r\n                polygon.remove();\r\n            });\r\n            // 記憶情報の対応部分を削除\r\n            delete this.span_info[comment_id];\r\n            delete this.box_info[comment_id];\r\n        };\r\n        this.addSpan = (color_code) => {\r\n            (0,_node_modules_rangy_classapplier_bundles_index_umd__WEBPACK_IMPORTED_MODULE_1__.createClassApplier)("commented", {\r\n                elementTagName: "span",\r\n                normalize: true,\r\n            }).toggleSelection(this.sat.content_window);\r\n            // comment_idを決定\r\n            const comment_id_arr = {};\r\n            const added_span_elements = [];\r\n            Array.from(this.sat.content_root.querySelectorAll(`span.commented`)).forEach((span) => {\r\n                if (span.getAttribute("comment_id") !== null) {\r\n                    comment_id_arr[span.getAttribute("comment_id")] = "commented";\r\n                }\r\n                else {\r\n                    added_span_elements.push(span);\r\n                }\r\n            });\r\n            while (comment_id_arr[this.comment_index]) {\r\n                this.comment_index++;\r\n            }\r\n            const comment_id = this.comment_index;\r\n            this.comment_index++;\r\n            // comment_id等の属性の付与\r\n            added_span_elements.forEach((span) => {\r\n                span.setAttribute("comment_id", comment_id.toString());\r\n                // if (!span.classList.contains("highlighted")) {\r\n                span.style.backgroundColor = color_code;\r\n                span.style.borderColor = color_code;\r\n                // }\r\n                const offset = this.sat.getOffset(span, this.sat.content_root.offsetParent);\r\n                span.setAttribute("offset_top", offset.offset_top.toString());\r\n                span.setAttribute("offset_left", offset.offset_left.toString());\r\n            });\r\n            // イベントハンドラ追加（span）\r\n            added_span_elements.forEach((span) => {\r\n                span.addEventListener("mouseover", (e) => {\r\n                    this.onMouseOver(span.getAttribute("comment_id"));\r\n                });\r\n            });\r\n            added_span_elements.forEach((span) => {\r\n                span.addEventListener("mouseout", (e) => {\r\n                    // 子要素への移動であれば無視\r\n                    if (e.relatedTarget instanceof HTMLElement &&\r\n                        e.relatedTarget.parentElement !== null &&\r\n                        e.relatedTarget.parentElement.closest(`span.commented[comment_id="${span.getAttribute("comment_id")}"]`) !== null) {\r\n                        return;\r\n                    }\r\n                    this.onMouseOut(span.getAttribute("comment_id"));\r\n                });\r\n            });\r\n            // if (this.sat.tool_type === "pdf_canvas") {\r\n            //   this.sat.pdf.memorize("commented");\r\n            // }\r\n            return comment_id.toString();\r\n        };\r\n        this.addBox = (comment_id, color_code) => {\r\n            var _a;\r\n            const p_element = document.createElement("p");\r\n            if (this.sat.tool_type === "pdf_canvas") {\r\n                if (this.box_info[comment_id]) {\r\n                    p_element.innerText = this.box_info[comment_id].content;\r\n                }\r\n                else {\r\n                    this.box_info[comment_id] = {\r\n                        content: "",\r\n                        page_number: (_a = this.span_info[comment_id]) === null || _a === void 0 ? void 0 : _a.map((info) => {\r\n                            return Number(info.page_number);\r\n                        }).reduce((a, b) => {\r\n                            return Math.min(a, b);\r\n                        }),\r\n                    };\r\n                }\r\n            }\r\n            const comment_div_element = document.createElement("div");\r\n            comment_div_element.classList.add("comment");\r\n            comment_div_element.contentEditable = "true";\r\n            comment_div_element.id = comment_id;\r\n            comment_div_element.setAttribute("comment_id", comment_id);\r\n            comment_div_element.style.backgroundColor = color_code;\r\n            comment_div_element.style.borderColor = color_code;\r\n            comment_div_element.appendChild(p_element);\r\n            document.getElementById("comment_div").appendChild(comment_div_element);\r\n            // 吹き出しのsvg（三角形）追加\r\n            const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");\r\n            polygon.setAttribute("comment_id", comment_id);\r\n            polygon.style.fill = color_code;\r\n            polygon.style.stroke = color_code;\r\n            document\r\n                .getElementById("comment_svg")\r\n                .querySelector("svg")\r\n                .appendChild(polygon);\r\n            // イベントハンドラ追加\r\n            comment_div_element.addEventListener("mouseover", (e) => {\r\n                this.onMouseOver(comment_div_element.getAttribute("comment_id"));\r\n            });\r\n            comment_div_element.addEventListener("mouseout", (e) => {\r\n                // 子要素への移動であれば無視\r\n                if (e.relatedTarget instanceof HTMLElement &&\r\n                    e.relatedTarget.parentElement !== null &&\r\n                    e.relatedTarget.parentElement.closest(`div.comment[comment_id="${comment_div_element.getAttribute("comment_id")}"]`) !== null) {\r\n                    return;\r\n                }\r\n                this.onMouseOut(comment_div_element.getAttribute("comment_id"));\r\n            });\r\n            comment_div_element.addEventListener("input", this.onInput);\r\n            polygon.addEventListener("click", (e) => {\r\n                this.onPolygonClick(comment_div_element.getAttribute("comment_id"));\r\n            });\r\n        };\r\n        this.onMouseOver = (comment_id) => {\r\n            var _a;\r\n            (_a = document\r\n                .getElementById("comment_div")\r\n                .querySelector(`div.comment[comment_id="${comment_id}"]`)) === null || _a === void 0 ? void 0 : _a.classList.add("div_onmouse");\r\n            // document\r\n            //   .getElementById("comment_svg")!\r\n            //   .querySelector(`polygon[comment_id="${comment_id}"]`)\r\n            //   ?.classList.add("polygon_onmouse");\r\n            Array.from(this.sat.content_root.querySelectorAll(`span.commented[comment_id="${comment_id}"]`)).forEach((span) => {\r\n                span.classList.add("span_onmouse");\r\n            });\r\n        };\r\n        this.onMouseOut = (comment_id) => {\r\n            var _a;\r\n            (_a = document\r\n                .getElementById("comment_div")\r\n                .querySelector(`div.comment[comment_id="${comment_id}"]`)) === null || _a === void 0 ? void 0 : _a.classList.remove("div_onmouse");\r\n            // document\r\n            //   .getElementById("comment_svg")!\r\n            //   .querySelector(`polygon[comment_id="${comment_id}"]`)\r\n            //   ?.classList.remove("polygon_onmouse");\r\n            Array.from(this.sat.content_root.querySelectorAll(`span.commented[comment_id="${comment_id}"]`)).forEach((span) => {\r\n                span.classList.remove("span_onmouse");\r\n            });\r\n        };\r\n        this.onInput = () => {\r\n            this.sat.updated = true;\r\n        };\r\n        this.onPolygonClick = (comment_id) => {\r\n            const comment_div = document\r\n                .getElementById("comment_div")\r\n                .querySelector(`div.comment[comment_id="${comment_id}"]`);\r\n            const color_picker = document.getElementById("color_picker");\r\n            const color_picker_comment = document.getElementById("color_picker_comment");\r\n            color_picker_comment.setAttribute("color_id", "comment_color");\r\n            color_picker_comment.style.display = "block";\r\n            const offsets = this.sat.getOffset(comment_div, this.sat.content_root);\r\n            color_picker_comment.style.top = `${Math.max(offsets.offset_top - color_picker_comment.offsetHeight / 2 + 10, 40)}px`;\r\n            const zumen_div = document.getElementById("zumen");\r\n            if (zumen_div) {\r\n                color_picker_comment.style.left = `${offsets.offset_left -\r\n                    color_picker_comment.offsetWidth -\r\n                    zumen_div.offsetWidth -\r\n                    15}px`;\r\n            }\r\n            else {\r\n                color_picker_comment.style.left = `${offsets.offset_left - color_picker_comment.offsetWidth - 15}px`;\r\n            }\r\n            color_picker.setAttribute("mode", "comment");\r\n            color_picker.setAttribute("comment_id", comment_id);\r\n            color_picker.setAttribute("comment_color", comment_div.style.backgroundColor);\r\n        };\r\n        // comment_boxの高さ順を判定し、this.box_sorted_infoを設定\r\n        this.sort = () => {\r\n            // comment_idごとにグループ化したspan要素の配列を作成する\r\n            const span_element_dic = Array.from(this.sat.content_root.querySelectorAll("span.commented")).reduce((r, a) => {\r\n                r[a.getAttribute("comment_id")] = [\r\n                    ...(r[a.getAttribute("comment_id")] || []),\r\n                    a,\r\n                ];\r\n                return r;\r\n            }, {}); // ひとまずcommment_idごとにグループ化した連想配列を作成\r\n            const span_element_arr = Object.keys(span_element_dic)\r\n                .map((key) => {\r\n                // ここで連想配列を配列に変更\r\n                return span_element_dic[key].sort((a, b) => {\r\n                    // グループ内ではoffsetTop、offsetLeftの順にソートしておく\r\n                    if (Number(a.getAttribute("offset_top")) !==\r\n                        Number(b.getAttribute("offset_top"))) {\r\n                        return Number(a.getAttribute("offset_top")) <\r\n                            Number(b.getAttribute("offset_top"))\r\n                            ? -1\r\n                            : 1;\r\n                    }\r\n                    else {\r\n                        return Number(a.getAttribute("offset_left")) <\r\n                            Number(b.getAttribute("offset_left"))\r\n                            ? -1\r\n                            : 1;\r\n                    }\r\n                });\r\n            })\r\n                .sort((a, b) => {\r\n                // グループ間では、最初のspanのoffsetTop、offsetLeftの順にソートしておく\r\n                if (Number(a[0].getAttribute("offset_top")) !==\r\n                    Number(b[0].getAttribute("offset_top"))) {\r\n                    return Number(a[0].getAttribute("offset_top")) <\r\n                        Number(b[0].getAttribute("offset_top"))\r\n                        ? -1\r\n                        : 1;\r\n                }\r\n                else {\r\n                    return Number(a[0].getAttribute("offset_left")) <\r\n                        Number(b[0].getAttribute("offset_left"))\r\n                        ? -1\r\n                        : 1;\r\n                }\r\n            });\r\n            const div_elements = Array.from(document\r\n                .getElementById("comment_div")\r\n                .querySelectorAll("div.comment")).reduce((result, current) => {\r\n                result[current.getAttribute("comment_id")] = current;\r\n                return result;\r\n            }, {});\r\n            const polygon_elements = Array.from(document\r\n                .getElementById("comment_svg")\r\n                .querySelectorAll("polygon")).reduce((result, current) => {\r\n                result[current.getAttribute("comment_id")] = current;\r\n                return result;\r\n            }, {});\r\n            this.box_sorted_info = span_element_arr.map((span) => {\r\n                return {\r\n                    comment_id: span[0].getAttribute("comment_id"),\r\n                    first_span: span[0],\r\n                    div: div_elements[span[0].getAttribute("comment_id")],\r\n                    polygon: polygon_elements[span[0].getAttribute("comment_id")],\r\n                };\r\n            });\r\n        };\r\n        // sort関数で生成されたthis.box_sorted_infoに従って、comment_boxのy方向の位置を調整\r\n        // （comment_boxのinputイベントなどではsortの必要がないため、arrange部分だけ別関数として作成）\r\n        this.arrange = (start_comment_id) => {\r\n            for (let i = 0; i < this.box_sorted_info.length; i++) {\r\n                let pos_prev = 0;\r\n                if (i > 0) {\r\n                    pos_prev =\r\n                        this.box_sorted_info[i - 1].div.offsetTop +\r\n                            this.box_sorted_info[i - 1].div.offsetHeight;\r\n                }\r\n                this.box_sorted_info[i].div.style.top = `${Math.max(pos_prev + 10, parseInt(this.box_sorted_info[i].first_span.getAttribute("offset_top")))}px`;\r\n                this.box_sorted_info[i].polygon.setAttribute("points", `0 ${Number(this.box_sorted_info[i].first_span.getAttribute("offset_top")) + 8}, 15 ${this.box_sorted_info[i].div.offsetTop + 5}, 15 ${this.box_sorted_info[i].div.offsetTop + 30}`);\r\n            }\r\n        };\r\n        this.sat = sat;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://sat/./src/sat.ts?')},"./node_modules/tslib/tslib.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "__extends": () => (/* binding */ __extends),\n/* harmony export */   "__assign": () => (/* binding */ __assign),\n/* harmony export */   "__rest": () => (/* binding */ __rest),\n/* harmony export */   "__decorate": () => (/* binding */ __decorate),\n/* harmony export */   "__param": () => (/* binding */ __param),\n/* harmony export */   "__metadata": () => (/* binding */ __metadata),\n/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),\n/* harmony export */   "__generator": () => (/* binding */ __generator),\n/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),\n/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),\n/* harmony export */   "__values": () => (/* binding */ __values),\n/* harmony export */   "__read": () => (/* binding */ __read),\n/* harmony export */   "__spread": () => (/* binding */ __spread),\n/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),\n/* harmony export */   "__await": () => (/* binding */ __await),\n/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),\n/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),\n/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),\n/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   "__importStar": () => (/* binding */ __importStar),\n/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),\n/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet)\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError("attempted to get private field on non-instance");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError("attempted to set private field on non-instance");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n\n\n//# sourceURL=webpack://sat/./node_modules/tslib/tslib.es6.js?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/main.ts")})();